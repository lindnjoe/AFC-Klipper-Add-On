# This file dynamically loads the AFC AMS customized modules.
# Generated to encapsulate AFC AMS modifications in a single module.
import sys
import types

AMS_MODULE_SOURCES = {
    'extras.AFC_utils': "# Armored Turtle Automated Filament Changer\n#\n# Copyright (C) 2024 Armored Turtle\n#\n# This file may be distributed under the terms of the GNU GPLv3 license.\n\n# File is used to hold common functions that can be called from anywhere and don't belong to a class\nimport traceback\nimport json\nimport inspect\n\nfrom datetime import datetime\nfrom urllib.request import (\n    Request,\n    urlopen\n)\nfrom urllib.parse import (\n    urlencode,\n    urljoin,\n    quote\n)\n\nERROR_STR = \"Error trying to import {import_lib}, please rerun install-afc.sh script in your AFC-Klipper-Add-On directory then restart klipper\\n\\n{trace}\"\n\ndef add_filament_switch( switch_name, switch_pin, printer, show_sensor=True, runout_callback = None, enable_runout=False, debounce_delay=0. ):\n    \"\"\"\n    Helper function to register pins as filament switch sensor so it will show up in web guis\n\n    :param switch_name: Name of switch to register, should be in the following format: `filament_switch_sensor <name>`\n    :param switch_pin: Pin to add to config for switch\n    :param printer: printer object\n\n    :return returns filament_switch_sensor object\n    \"\"\"\n    import configparser\n    import configfile\n    new_switch_name = f\"filament_switch_sensor {switch_name}\"\n    ppins = printer.lookup_object('pins')\n    ppins.allow_multi_use_pin(switch_pin.strip(\"!^\"))\n    filament_switch_config = configparser.RawConfigParser()\n    filament_switch_config.add_section( new_switch_name )\n    filament_switch_config.set( new_switch_name, 'switch_pin', switch_pin)\n    filament_switch_config.set( new_switch_name, 'pause_on_runout', 'False')\n    filament_switch_config.set( new_switch_name, 'debounce_delay', 0.0)\n\n    cfg_wrap = configfile.ConfigWrapper( printer, filament_switch_config, {}, new_switch_name)\n\n    fila = printer.load_object(cfg_wrap, new_switch_name)\n\n    # Commence the hacky stuff for delayed runout\n    if not show_sensor:\n        # Removing normal switch name from object and adding name with underscore if user does not want\n        # sensor showing up in gui. Doing this suppressed the sensor from showing up in gui  since the\n        # name is not exactly \"filament_switch_sensor\"\n        printer.objects[\"_\" + new_switch_name] = printer.objects.pop(new_switch_name)\n\n    fila.runout_helper.sensor_enabled = enable_runout\n    fila.runout_helper.runout_pause = False                 # AFC will deal with pause\n\n    filament_switch_config.set( new_switch_name, 'debounce_delay', debounce_delay)\n    # Using our own DebounceButton so that callback functions can be overridden to work correctly\n    debounce_button = DebounceButton(cfg_wrap, fila)\n\n    if runout_callback:\n        #fila.runout_helper.event_delay = 0.0                # Setting event delay to zero or total delay will be event_delay + debounce_delay\n        fila.runout_helper.insert_gcode = None\n        fila.runout_helper.runout_gcode = 1\n        fila.runout_helper._runout_event_handler = runout_callback # Overriding filament event handler with AFC handler\n\n    if enable_runout:\n        return fila, debounce_button\n\n    return fila\n\ndef check_and_return( value_str:str, data_values:dict ) -> str:\n    \"\"\"\n    Common function to check if value exists in dictionary and returns value if it does.\n\n    :param value_str: Key string to check if value exists in dictionary\n    :param data_values: Dictionary of values to check for key\n\n    :return: Returns string of value if found in dictionary\n    \"\"\"\n    value = \"0\"\n    if value_str in data_values:\n        value = data_values[value_str]\n\n    return value\n\n# Copied from klipper for kalico and older klipper support\nclass DebounceButton:\n    def __init__(self, config, filament_sensor):\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        sig = inspect.signature(filament_sensor.runout_helper.note_filament_present)\n        # Saving reference to normal function\n        self._old_note_filament_present = filament_sensor.runout_helper.note_filament_present\n        # Setting action callback to normal filament sensor not filament present\n        self.button_action = self._old_note_filament_present\n        # Overriding filament sensor filament present to button handler in this class\n        # Checking parameter length since kalico's note_filament_present function is different\n        # and also checking for older klipper versions before hash 272e8155\n        if len(sig.parameters) > 2 or len(sig.parameters) == 1:\n            filament_sensor.runout_helper.note_filament_present = self.button_handler\n        else:\n            filament_sensor.runout_helper.note_filament_present = self._button_handler\n        self.debounce_delay = config.getfloat('debounce_delay', 0., minval=0.)\n        self.logical_state = None\n        self.physical_state = None\n        self.latest_eventtime = None\n\n    def button_handler(self, state):\n        self._button_handler(self.reactor.monotonic(), state)\n\n    def _button_handler(self, eventtime, state):\n        self.physical_state = state\n        self.latest_eventtime = eventtime\n        # if there would be no state transition, ignore the event:\n        if self.logical_state == self.physical_state:\n            return\n        trigger_time = eventtime + self.debounce_delay\n        self.reactor.register_callback(self._debounce_event, trigger_time)\n\n    def _debounce_event(self, eventtime):\n        # if there would be no state transition, ignore the event:\n        if self.logical_state == self.physical_state:\n            return\n        # if there were more recent events, they supersede this one:\n        if (eventtime - self.debounce_delay) < self.latest_eventtime:\n            return\n        # enact state transition and trigger action\n        self.logical_state = self.physical_state\n        # Kalico is different from klipper and eventtime is not passed in\n        try:\n            self.button_action(self.logical_state)\n        except:\n            self.button_action(eventtime, self.logical_state)\n\n\nclass AFC_moonraker:\n    \"\"\"\n    This class is used to communicate with moonraker to look up information and post\n    data into moonrakers database\n\n    Parameters\n    ----------------\n    port: String\n        Port to connect to moonrakers localhost\n    logger: AFC_logger\n        AFC logger object to log and print to console\n    \"\"\"\n    ERROR_STRING = \"Error getting data from moonraker, check AFC.log for more information\"\n    def __init__(self, host:str, port:str, logger:object):\n        self.port           = port\n        self.logger         = logger\n        self.host           = f'{host.rstrip(\"/\")}:{port}'\n        self.database_url   = urljoin(self.host, \"server/database/item\")\n        self.afc_stats_key  = \"afc_stats\"\n        self.afc_stats      = None\n        self.last_stats_time= None\n        self.logger.debug(f\"Moonraker url: {self.host}\")\n\n    def _get_results(self, url_string, print_error=True):\n        \"\"\"\n        Helper function to get results, check for errors and return data if successful\n\n        :param url_string: URL encoded string to fetch/post data to moonraker\n        :param print_error: Set to True for error to be displayed in console/mainsail panel, setting\n                            to False will still write error to log via debug message\n\n        :returns: Returns result dictionary if data is valid, returns None if and error occurred\n        \"\"\"\n        data = None\n        # Only print error to console when set, else still print errors bug with debug\n        # logger so that messages are still written to log for debugging purposes\n        if print_error:\n            logger = self.logger.error\n        else:\n            logger = self.logger.debug\n\n        try:\n            resp = urlopen(url_string)\n            if resp.status >= 200 and resp.status <= 300:\n                data = json.load(resp)\n            else:\n                logger(self.ERROR_STRING)\n                logger(f\"Response: {resp.status} Reason: {resp.reason}\")\n        except:\n            logger(self.ERROR_STRING, traceback=traceback.format_exc())\n            data = None\n        return data['result'] if data is not None else data\n\n    def wait_for_moonraker(self, toolhead, timeout:int=30):\n        \"\"\"\n        Function to wait for moonraker to start, times out after passed in timeout value\n\n        :param toolhead: Toolhead object so that non blocking waits can happen\n        :param timeout: Timeout out trying after this many seconds\n\n        :return: Returns True if connected to moonraker and a timeout did no occur, returns False if\n                 not connected after waiting max timeout value\n        \"\"\"\n        self.logger.info(f\"Waiting max {timeout}s for moonraker to connect\")\n        for i in range(0,timeout):\n            resp = self._get_results(urljoin(self.host, 'server/info'), print_error=False)\n            if resp is not None:\n                self.logger.debug(f\"Connected to moonraker after {i} tries\")\n                return True\n            else:\n                toolhead.dwell(1)\n        self.logger.info(f\"Failed to connect to moonraker after {timeout} seconds, check AFC.log for more information\")\n        return False\n\n    def get_spoolman_server(self)->str:\n        \"\"\"\n        Queries moonraker to see if spoolman is configured, returns True when\n        spoolman is configured\n\n        :returns: Returns string for Spoolman IP, returns None if it is not configured\n        \"\"\"\n        resp = self._get_results(urljoin(self.host, 'server/config'))\n        # Check to make sure response is valid and spoolman exists in dictionary\n        if resp is not None and 'orig' in resp and 'spoolman' in resp['orig']:\n            return resp['orig']['spoolman']['server']     # check for spoolman and grab url\n        else:\n            self.logger.debug(\"Spoolman server is not defined\")\n            return None\n\n    def get_file_filament_change_count(self, filename:str ):\n        \"\"\"\n        Queries moonraker for files metadata and returns filament change count\n\n        :param filename: Filename to query moonraker and pull metadata\n        :return: Returns number of filament change counts if `filament_change_count` is in metadata.\n                 Returns zero if not found in metadata.\n        \"\"\"\n        change_count = 0\n        resp = self._get_results(urljoin(self.host,\n                                    'server/files/metadata?filename={}'.format(quote(filename))))\n        if resp is not None and 'filament_change_count' in resp:\n            change_count =  resp['filament_change_count']\n        else:\n            self.logger.debug(f\"Filament change count metadata not found for file:{filename}\")\n        return change_count\n\n    def get_afc_stats(self):\n        \"\"\"\n        Queries moonraker database for all `afc_stats` entries and returns results if afc_stats exist.\n        Function also caches results and refetches data if cache is older than 60s. This is done to help\n        cut down on how much data is fetched from moonraker.\n\n        :return: Dictionary of afc_stats entries, None if afc_stats entry does not exist\n        \"\"\"\n        resp = None\n        # Initially set to True since first time data always needs to be fetched\n        refetch_data = True\n        current_time = datetime.now()\n\n        # Check to see if data is older than 60 seconds and refreshes\n        if self.last_stats_time is not None:\n            refetch_data = False\n            delta = current_time - self.last_stats_time\n            if delta.seconds > 60:\n                refetch_data = True\n                self.last_stats_time = current_time\n        else:\n            self.last_stats_time = datetime.now()\n\n        # Cache results to keep queries to moonraker down\n        if self.afc_stats is None or refetch_data:\n            resp = self._get_results(urljoin(self.database_url, f\"?namespace={self.afc_stats_key}\"))\n            if resp is not None:\n                self.afc_stats = resp\n            else:\n                self.logger.debug(\"AFC_stats not in database\")\n\n        return self.afc_stats\n\n    def update_afc_stats(self, key, value):\n        \"\"\"\n        Updates afc_stats in moonrakers database with key, value pair\n\n        :param key: The key indicating the field where the value should be inserted\n        :param value: The value to insert into the database\n        \"\"\"\n        resp = None\n        post_payload = {\n            \"request_method\": \"POST\",\n            \"namespace\": self.afc_stats_key,\n            \"key\": key,\n            \"value\": value\n        }\n        req = Request(self.database_url, urlencode(post_payload).encode())\n\n        resp = self._get_results(req)\n        if resp is None:\n            self.logger.error(f\"Error when trying to update {key} in moonraker, see AFC.log for more info\")\n\n    def get_spool(self, id:int):\n        \"\"\"\n        Uses moonrakers proxy to query spoolID from spoolman\n\n        :param id: SpoolID to lookup and fetch data from spoolman\n        :return: Returns dictionary of spoolID, returns None if error occurred or ID does not exist\n        \"\"\"\n        resp = None\n        request_payload = {\n            \"request_method\": \"GET\",\n            \"path\": f\"/v1/spool/{id}\"\n        }\n        spool_url = urljoin(self.host, 'server/spoolman/proxy')\n        req = Request( spool_url, urlencode(request_payload).encode() )\n\n        resp = self._get_results(req)\n        if resp is not None:\n            resp = resp\n        else:\n            self.logger.info(f\"SpoolID: {id} not found\")\n        return resp",
    'extras.AFC_functions': "# Armored Turtle Automated Filament Control\n#\n# Copyright (C) 2024 Armored Turtle\n#\n# This file may be distributed under the terms of the GNU GPLv3 license.\n#\n# This file includes code modified from the Shaketune Project. https://github.com/Frix-x/klippain-shaketune\n# Originally authored by F\u00e9lix Boisselier and licensed under the GNU General Public License v3.0.\n#\n# Full license text available at: https://www.gnu.org/licenses/gpl-3.0.html\n\nimport os\nimport random\nimport re\nimport traceback\nimport configparser\n\nfrom configfile import error\nfrom datetime import datetime\nfrom pathlib import Path\n\ntry: from extras.AFC_utils import ERROR_STR\nexcept: raise error(\"Error when trying to import AFC_utils.ERROR_STR\\n{trace}\".format(trace=traceback.format_exc()))\n\ntry: from extras.AFC_respond import AFCprompt\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_respond\", trace=traceback.format_exc()))\n\ndef load_config(config):\n    return afcFunction(config)\n\nclass afcFunction:\n    def __init__(self, config):\n        self.config = config\n        self.printer = config.get_printer()\n        self.printer.register_event_handler(\"klippy:connect\", self.handle_connect)\n        self.printer.register_event_handler(\"afc_stepper:register_macros\",self.register_lane_macros)\n        self.printer.register_event_handler(\"afc_hub:register_macros\",self.register_hub_macros)\n        self.auto_var_file = None\n        self.errorLog = {}\n        self.pause    = False\n        self.afc      = None\n        self.logger   = None\n        self.mcu      = None\n\n        self.show_macros = True\n        self.register_commands(self.show_macros, 'AFC_CALIBRATION', self.cmd_AFC_CALIBRATION, self.cmd_AFC_CALIBRATION_help)\n        self.register_commands(self.show_macros, 'AFC_RESET', self.cmd_AFC_RESET, self.cmd_AFC_RESET_help,\n                               self.cmd_AFC_RESET_options)\n        self.register_commands(self.show_macros, 'AFC_LANE_RESET', self.cmd_AFC_LANE_RESET,\n                               self.cmd_AFC_LANE_RESET_help, self.cmd_AFC_LANE_RESET_options)\n        self.register_commands(self.show_macros, 'AFC_TEST_LANES', self.cmd_AFC_TEST_LANES,\n                               self.cmd_AFC_TEST_LANES_help)\n\n\n    def register_lane_macros(self, lane_obj):\n        \"\"\"\n        Callback function to register macros with proper lane names so that klipper errors out correctly when users supply lanes names that\n        are not valid\n\n        :param lane_obj: object for lane to register\n        \"\"\"\n        self.afc.gcode.register_mux_command('TEST', \"LANE\", lane_obj.name, self.cmd_TEST, desc=self.cmd_TEST_help)\n        self.afc.gcode.register_mux_command('HUB_CUT_TEST', \"LANE\", lane_obj.name, self.cmd_HUB_CUT_TEST, desc=self.cmd_HUB_CUT_TEST_help)\n\n    def register_hub_macros(self, hub_obj):\n        \"\"\"\n        Callback function to register macros with proper hub names so that klipper errors out correctly when users supply hub names that\n        are not valid\n\n        :param hub_obj: object for hub to register\n        \"\"\"\n        self.afc.gcode.register_mux_command('SET_BOWDEN_LENGTH', 'HUB', hub_obj.name, self.cmd_SET_BOWDEN_LENGTH, desc=self.cmd_SET_BOWDEN_LENGTH_help)\n\n    def handle_connect(self):\n        \"\"\"\n        Handle the connection event.\n        This function is called when the printer connects. It looks up AFC info\n        and assigns it to the instance variable `self.afc`.\n        \"\"\"\n        self.afc = self.printer.lookup_object('AFC')\n        self.logger = self.afc.logger\n        self.mcu = self.printer.lookup_object('mcu')\n\n        self.auto_var_file = Path(self.afc.VarFile).parent.joinpath(\"AFC_auto_vars.cfg\")\n\n        self.afc.gcode.register_command('CALIBRATE_AFC',   self.cmd_CALIBRATE_AFC,   desc=self.cmd_CALIBRATE_AFC_help)\n        self.afc.gcode.register_command('ALL_CALIBRATION', self.cmd_ALL_CALIBRATION, desc=self.cmd_ALL_CALIBRATION_help)\n        self.afc.gcode.register_command('AFC_CALI_COMP',   self.cmd_AFC_CALI_COMP,   desc=self.cmd_AFC_CALI_COMP_help)\n        self.afc.gcode.register_command('AFC_CALI_FAIL',   self.cmd_AFC_CALI_FAIL,   desc=self.cmd_AFC_CALI_FAIL_help)\n        self.afc.gcode.register_command('AFC_HAPPY_P',     self.cmd_AFC_HAPPY_P,     desc=self.cmd_AFC_HAPPY_P_help)\n        self.afc.gcode.register_command('TEST_LANE', self.cmd_TEST_LANE, desc=self.cmd_TEST_LANE_help)\n        self.afc.gcode.register_command('TEST_LANE_ITERATIONS', self.cmd_TEST_LANE_ITERATIONS, desc=self.cmd_TEST_LANE_ITERATIONS_help)\n\n    auto_save_top_comment = \"# This file is autogenerated and updated when variables are not in your normal AFC config files\\n\\n\"\n    def write_auto_variables(self, section_name, value_name, value):\n        \"\"\"\n        Function writes variables to a separate file defined by `auto_var_file` variable.\n        First checks if section_name exists, if section does not exist its added\n        and then key,value is added to section and then config is saved to disk.\n\n        :param section_name: Name of section to add key/value to\n        :param value_name: Name of key to add to section\n        :param value: Value to assign to key\n        \"\"\"\n        config = configparser.RawConfigParser( delimiters=(':', '=') )\n\n        if not os.path.exists(self.auto_var_file):\n            open(self.auto_var_file, 'a').close()\n\n        # Read in old config\n        with open(self.auto_var_file) as fp:\n            config.read_file(fp)\n\n        if not config.has_section( section_name ):\n            config.add_section( section_name )\n\n        config.set( section_name, value_name, value )\n\n        with open(self.auto_var_file, 'w') as fp:\n            fp.write(self.auto_save_top_comment)\n            config.write(fp)\n\n    def ConfigRewrite(self, rawsection, rawkey, rawvalue, msg=\"\"):\n        taskdone = False\n        sectionfound = False\n        # Creating regex pattern based off rawsection\n        pattern = re.compile(\"^\\[\\s*{}\\s*\\]\".format(rawsection))\n        for filename in os.listdir(self.afc.cfgloc):\n            file_path = os.path.join(self.afc.cfgloc, filename)\n            if os.path.isfile(file_path) and filename.endswith(\".cfg\"):\n                with open(file_path, 'r') as f:\n                    dataout = ''\n                    for line in f:\n                        # If previous section found and line starts with bracket, means that this line is another section\n                        # need to set section found to false in order to not update wrong sections if raw key is not\n                        # found\n                        if sectionfound and line.startswith(\"[\"): sectionfound = False\n\n                        if re.match(pattern, line) is not None: sectionfound = True\n                        if sectionfound == True and line.startswith(rawkey):\n                            comments = \"\"\n                            comment_index = 0\n                            try:\n                                comment_index = line.index('#')\n                                comments = line[comment_index:-1]\n                            except ValueError:\n                                pass\n                            line = \"{}: {}\".format(rawkey, rawvalue )\n                            # Left justifying comment with spaces so its in original position\n                            line = line.ljust(comment_index - 1, \" \")\n\n                            line = \"{} {}\\n\".format(line, comments)\n                            sectionfound = False\n                            taskdone = True\n                        dataout += line\n                if taskdone:\n                    f=open(file_path, 'w')\n                    f.write(dataout)\n                    f.close()\n                    taskdone = False\n                    msg +='\\n<span class=info--text>Saved {}:{} in {} section to configuration file</span>'.format(rawkey, rawvalue, rawsection)\n                    self.logger.info(msg)\n                    return\n        # Variables not found, write section and key to a separate file\n        self.write_auto_variables( rawsection, rawkey, rawvalue )\n        msg +='\\n<span class=info--text>Key {} not found in section {} added to AFC_auto_vars.cfg file</span>'.format(rawkey, rawsection)\n        self.logger.info(msg)\n\n    def TcmdAssign(self, cur_lane):\n        \"\"\"\n        Function automatically tries to generate T(n) macros for lanes. If user has already assigned mapping to `map`\n        variable in their configs, this is used instead of an auto assigned command. Before assigning command, checks\n        happen to make sure auto generated macro has not already be manually assigned in gcode or by something else.\n\n        Auto generated macro and manually assigned macro is then added to a dictionary to easily look up which lane\n        to switch to when T(n) command is called.\n\n        :param cur_lane: Lane to assign auto generated T(n) macro\n        \"\"\"\n        if cur_lane.map == None :\n            for x in range(99):\n                cmd = 'T{}'.format(x)\n                # Checking to see if cmd exists in lanes that have manually assigned mapping\n                # skip cmd and generate next if cmd is manually assigned by user\n                manually_assigned = any( cmd == lane._map for lane in self.afc.lanes.values() )\n                if not manually_assigned and cmd not in self.afc.tool_cmds:\n                    # Checking if macro already exists, generate next valid cmd if current generated cmd exists\n                    existing = self.afc.gcode.ready_gcode_handlers.get(cmd)\n                    if not existing:\n                        cur_lane._map = cur_lane.map = cmd\n                        break\n        self.afc.tool_cmds[cur_lane.map]=cur_lane.name\n        try:\n            self.afc.gcode.register_command(cur_lane.map, self.afc.cmd_CHANGE_TOOL, desc=self.afc.cmd_CHANGE_TOOL_help)\n        except:\n            self.logger.info(\"Error trying to map lane {lane} to {tool_macro}, please make sure there are no macros already setup for {tool_macro}\".format(lane=[cur_lane.name], tool_macro=cur_lane.map), )\n        self.afc.save_vars()\n\n    def check_homed(self):\n        \"\"\"\n        Helper function to determine if printer is currently homed, if not, then apply G28\n\n        :return boolean: True if xyz is homed\n        \"\"\"\n        if not self.is_homed():\n            if self.afc.auto_home:\n                self.afc.gcode.run_script_from_command(\"G28\")\n                self.afc.toolhead.wait_moves()\n                return True\n            else:\n                self.afc.error.AFC_error(\"Please home printer before doing a tool load\", False, level=2)\n                return False\n        else:\n            return True\n\n    def is_homed(self):\n        \"\"\"\n        Helper function to determine if printer is currently homed\n\n        :return boolean: True if xyz is homed\n        \"\"\"\n        curtime = self.afc.reactor.monotonic()\n        kin_status = self.afc.toolhead.get_kinematics().get_status(curtime)\n        if ('x' not in kin_status['homed_axes'] or 'y' not in kin_status['homed_axes'] or 'z' not in kin_status['homed_axes']):\n            return False\n        else:\n            return True\n\n    def is_moving(self):\n        \"\"\"\n        Helper function to return if the printer is moving or not. This is different from `is_printing` as it will return true if anything in the printer is moving.\n\n        :return boolean: True if anything in the printer is moving\n        \"\"\"\n        eventtime = self.afc.reactor.monotonic()\n        idle_timeout = self.printer.lookup_object(\"idle_timeout\")\n        return idle_timeout.get_status(eventtime)[\"state\"] == \"Printing\"\n\n    def in_print(self, return_file=False):\n        \"\"\"\n        Helper function to help determine if printer is in a print by checking print_stats object. Printer is printing if state is not in standby or error\n\n        :param return_file: Set to True to return current print filename if printer is in a print\n        :return boolean: True if state is not standby or error\n        \"\"\"\n        print_stats_idle_states = ['standby', 'error', 'complete', 'cancelled']\n        eventtime = self.afc.reactor.monotonic()\n        print_stats = self.printer.lookup_object(\"print_stats\")\n        print_state = print_stats.get_status(eventtime)[\"state\"]\n\n        in_print = print_state not in print_stats_idle_states\n        if return_file:\n            return in_print, print_stats.get_status(eventtime)[\"filename\"]\n        else:\n            return in_print\n\n    def is_printing(self, check_movement=False):\n        \"\"\"\n        Helper function to return if the printer is printing an object.\n\n        :param check_movement: When set to True will also return True if anything in the printer is also moving\n\n        :return boolean: True if printer is printing an object or if printer is moving when `check_movement` is True\n        \"\"\"\n        eventtime = self.afc.reactor.monotonic()\n        print_stats = self.printer.lookup_object(\"print_stats\")\n        moving = False\n\n        if check_movement:\n            moving = self.is_moving()\n\n        return print_stats.get_status(eventtime)[\"state\"] == \"printing\" or moving\n\n    def is_paused(self):\n        \"\"\"\n        Helper function that returns true if printer is currently paused\n\n        :return boolean: True when printer is paused\n        \"\"\"\n        eventtime = self.afc.reactor.monotonic()\n        pause_resume = self.printer.lookup_object(\"pause_resume\")\n        return bool(pause_resume.get_status(eventtime)[\"is_paused\"])\n\n    def get_current_lane(self):\n        \"\"\"\n        Helper function to lookup current lane name loaded into active toolhead\n\n        :return string: Current lane name that is loaded, None if nothing is loaded\n        \"\"\"\n        if self.printer.state_message == 'Printer is ready':\n            current_extruder = self.afc.toolhead.get_extruder().name\n            if current_extruder in self.afc.tools:\n                return self.afc.tools[current_extruder].lane_loaded\n        return None\n\n    def get_current_lane_obj(self):\n        \"\"\"\n        Helper function to lookup and return current lane object that is loaded into the active toolhead\n\n        :return object: None if nothing is loaded, AFC_stepper object if a lane is currently loaded\n        \"\"\"\n        curr_lane_obj = None\n        curr_lane = self.get_current_lane()\n        if curr_lane in self.afc.lanes:\n            curr_lane_obj = self.afc.lanes[curr_lane]\n        return curr_lane_obj\n\n    def verify_led_object(self, led_name):\n        \"\"\"\n        Helper function to lookup AFC_led object.\n\n        :params led_name: name of AFC_led object to lookup\n\n        :return (string, object): error_string if AFC_led object is not found, led object if found\n        \"\"\"\n        error_string = \"\"\n        led = None\n        afc_object = 'AFC_led {}'.format(led_name.split(':')[0])\n        try:\n            led = self.printer.lookup_object(afc_object)\n        except:\n            error_string = \"Error: Cannot find [{}] in config, make sure led_index in config is correct for AFC_stepper {}\".format(afc_object, led_name.split(':')[-1])\n        return error_string, led\n\n    def _get_led_indexes(self, index_values):\n        \"\"\"\n        Helper function for creating a list for index values that have dashes and commas\n        so the led's can be set correctly.\n\n        eg. 1-4,9,10 would turn in to [1,2,3,4,9,10]\n\n        :params index_value: String of index values to turn into a proper list\n        :return list: list of index values for led's\n        \"\"\"\n        led_indexes = []\n        for idx in index_values.split(\",\"):\n            if \"-\" not in idx:\n                led_indexes.append(int(idx))\n            else:\n                low, high = map(int, idx.split(\"-\"))\n                led_indexes += range(low, high+1)\n        return led_indexes\n\n    def afc_led (self, status, idx=None):\n        if idx is None:\n            return\n\n        error_string, led = self.verify_led_object(idx)\n        if led is not None:\n            led_indexes = idx.split(\":\")[1]\n            range_index = self._get_led_indexes(led_indexes)\n            led.led_change(range_index, status)\n        else:\n            self.logger.info( error_string )\n\n    def get_filament_status(self, cur_lane):\n        if cur_lane.prep_state:\n            if cur_lane.load_state:\n                if cur_lane.extruder_obj is not None and cur_lane.extruder_obj.lane_loaded == cur_lane.name:\n                    return 'In Tool:{}'.format(self.HexConvert(cur_lane.led_tool_loaded).split(':')[-1])\n                return \"Ready:{}\".format(self.HexConvert(cur_lane.led_ready).split(':')[-1])\n            return 'Prep:{}'.format(self.HexConvert(cur_lane.led_prep_loaded).split(':')[-1])\n        return 'Not Ready:{}'.format(self.HexConvert(cur_lane.led_not_ready).split(':')[-1])\n\n    def handle_activate_extruder(self):\n        \"\"\"\n        Function used to deactivate lanes motors and buffers, then enables current extruders lane\n\n        This will also be tied to a callback once multiple extruders are implemented\n        \"\"\"\n        cur_lane_loaded = self.get_current_lane_obj()\n\n        # Disable extruder steppers for non active lanes\n        for key, obj in self.afc.lanes.items():\n            if cur_lane_loaded is None or key != cur_lane_loaded.name:\n                obj.do_enable(False)\n                obj.disable_buffer()\n                if obj.prep_state and obj.load_state:\n                    self.afc_led(obj.led_ready, obj.led_index)\n                else:\n                    self.afc_led(obj.led_not_ready, obj.led_index)\n\n        # Exit early if lane is None\n        if cur_lane_loaded is None:\n            self.afc.spool.set_active_spool('')\n            return\n\n        # Switch spoolman ID\n        self.afc.spool.set_active_spool(cur_lane_loaded.spool_id)\n        # Set lanes tool loaded led\n        # TODO: Add check to see if users want to change status led to spool color if set\n        # if cur_lane_loaded.color is not None and cur_lane_loaded.color:\n        #     led_color = self.HexToLedString(cur_lane_loaded.color.replace(\"#\", \"\"))\n        #     self.afc_led( led_color, cur_lane_loaded.led_index )\n        # else:\n        cur_lane_loaded.unit_obj.lane_tool_loaded( cur_lane_loaded )\n        # Enable stepper\n        cur_lane_loaded.do_enable(True)\n        # Enable buffer\n        cur_lane_loaded.enable_buffer()\n\n    def unset_lane_loaded(self):\n        \"\"\"\n        Helper function to get current lane and unsync lane from toolhead extruder\n        \"\"\"\n        cur_lane_loaded = self.get_current_lane_obj()\n        if cur_lane_loaded is not None:\n            cur_lane_loaded.unsync_to_extruder()\n            cur_lane_loaded.set_unloaded()\n            cur_lane_loaded.unit_obj.return_to_home()\n            self.afc.function.handle_activate_extruder()\n            self.logger.info(\"Manually removing {} loaded from toolhead\".format(cur_lane_loaded.name))\n            self.afc.save_vars()\n\n    def select_loaded_lane(self):\n        \"\"\"\n        Function looks up what the current lane loaded is and calls a common `select_lane` function so\n        that units that have selectors this makes sure the correct lane is selected if user moves other\n        lanes outside of printing\n        \"\"\"\n        current_lane = self.get_current_lane_obj()\n        if current_lane is not None:\n            current_lane.unit_obj.select_lane(current_lane)\n\n    def log_toolhead_pos(self, move_pre=\"\"):\n        \"\"\"\n        Helper function for printing position data to log\n\n        :param move_pre: String that get appended before the position data\n        \"\"\"\n        msg = \"{}Position: {}\".format(move_pre, self.afc.toolhead.get_position())\n        msg += \" base_position: {}\".format(self.afc.gcode_move.base_position)\n        msg += \" last_position: {}\".format(self.afc.gcode_move.last_position)\n        msg += \" speed: {}\".format(self.afc.gcode_move.speed)\n        msg += \" speed_factor: {}\".format(self.afc.gcode_move.speed_factor)\n        msg += \" extrude_factor: {}\".format(self.afc.gcode_move.extrude_factor)\n        msg += \" absolute_coord: {}\".format(self.afc.gcode_move.absolute_coord)\n        msg += \" absolute_extrude: {}\\n\".format(self.afc.gcode_move.absolute_extrude)\n        self.logger.debug(msg, only_debug=True)\n\n    def check_absolute_mode( self, func_name:str=\"\" ):\n        \"\"\"\n        Function to verifies that coordinates and extruder is in absolute mode, sets back to absolute mode\n        if relative mode is set\n\n        :params func_name: String for name of function that function is being called from,\n                           this is added to debug log to aid in debugging\n        \"\"\"\n        # Verify that printer is in absolute mode, and set True if in relative mode to prevent out of bound moves\n        self.log_toolhead_pos(\"{}: check absolute mode, POS:\".format(func_name))\n        if not self.afc.gcode_move.absolute_coord:\n            self.logger.debug(\"Printer coords not in absolute mode, setting to absolute mode\")\n            self.afc.gcode_move.absolute_coord = True\n        if not self.afc.gcode_move.absolute_extrude:\n            self.logger.debug(\"Printer extruder not in absolute mode, setting to absolute mode\")\n            self.afc.gcode_move.absolute_extrude = True\n\n    def get_extruder_pos(self, eventtime=None, past_extruder_position=None):\n        \"\"\"\n        This function find the last position of the filament and only returns a value if it greater than\n        the previous passed in position.\n\n        :param eventtime: Current eventtime to calculate the position from, if time is not passed in uses current eventtime\n        :param past_extruder_position: Previous extruder position to compare current position against.\n        :return float: Returns current extruder position if its greater than previous position, else returns previous position\n        \"\"\"\n        if eventtime is None:\n            eventtime = self.afc.reactor.monotonic()\n        print_time = self.mcu.estimated_print_time(eventtime)\n        extruder = self.afc.toolhead.get_extruder()\n        last_extruder_position = extruder.find_past_position(print_time)\n\n        if past_extruder_position is None or last_extruder_position > past_extruder_position:\n            past_extruder_position = last_extruder_position\n            # if last_extruder_position > 0: self.logger.debug(\"Extruder last position: {}\".format(last_extruder_position))\n            return last_extruder_position\n        else:\n            return past_extruder_position\n\n    def gcode_get_value( self, gcmd, get_attr, variable, variable_name, section_name, key_name=None, cast_to_bool=False ):\n        \"\"\"\n        Helper type function to get values for macros. This function will also use passed in variable\n        as default value. If user passed in a new value for variable_name, then config file is updated\n        with new value. Do not call this function if a macro variable is required.\n\n        :param gcmd: Klipper gcode command\n        :param get_attr: gcode command get function type. Can only be the following: get, get_int, get_float\n        :param variable: Current variable value to use as default\n        :param variable_name: Variable name to get from gcode command\n        :param section_name: Section name to save variable to if new value is different from old value\n        :param key_name: Key name to save value to\n        :param cast_to_bool: Set to True to case int to boolean\n        :return value: New or current value from gcode command\n        \"\"\"\n        if not hasattr(gcmd, get_attr):\n            self.logger.error(f\"{get_attr} is not a value GCodeCommand function\")\n            return variable\n\n        old_value = variable\n        new_value = getattr( gcmd, get_attr)(variable_name, variable)\n\n        if key_name is None:\n            key_name = variable_name.lower()\n\n        if cast_to_bool: new_value = bool(new_value)\n\n        if old_value != new_value:\n            self.logger.info(f\"Updating {key_name}, New: {new_value} Old: {old_value}\")\n            self.ConfigRewrite(section_name, key_name, new_value)\n\n        return new_value\n\n    def HexConvert(self,tmp):\n        led=tmp.split(',')\n        if float(led[0])>0:\n            led[0]=int(255*float(led[0]))\n        else:\n            led[0]=0\n        if float(led[1])>0:\n            led[1]=int(255*float(led[1]))\n        else:\n            led[1]=0\n        if float(led[2])>0:\n            led[2]=int(255*float(led[2]))\n        else:\n            led[2]=0\n\n        return '#{:02x}{:02x}{:02x}'.format(*led)\n\n    def HexToLedString(self, led_value):\n        \"\"\"\n        Helper function for turning a hex value into a comma seperated list\n\n        :param led_value: Hex color value\n        :return list: List of comma seperated float values ranging from 0.0 to 1.0\n        \"\"\"\n        n = 2\n        new_value = [ int(led_value[i:i+n], base=16)/255.0 for i in range(0, len(led_value), n)]\n        if led_value == \"FFFFFF\":\n            new_value.append(1.0)\n        else:\n            new_value.append(0.0)\n        return new_value\n\n    def _create_options(self, macro_name, options):\n        option_str = \"\"\n\n        for key, value in options.items():\n            option_str += f\"{{%set dummy=params.{key}|default('{value['default']}')|{value['type']}%}}\\n\"\n\n        option_str += f\"_{macro_name} {{rawparams}}\"\n        return option_str\n\n    def _create_no_options(self, macro_name):\n        return f\"_{macro_name}\"\n\n    # Modified from the ShakeTune project\n    def register_mux_command(self, show_macros, macro_name, key, value, command, description, options=None):\n        gcode = self.printer.lookup_object('gcode')\n\n        # Register AFC macro commands using the official Klipper API (gcode.register_command)\n        # Doing this makes the commands available in Klipper, but they are not shown in the web interfaces\n        # and are only available by typing the full name in the console (like all the other Klipper commands)\n        # for name, command, description in afc_commands:\n        gcode.register_mux_command(f'_{macro_name}' if show_macros else macro_name, key, value, command,\n                                   desc=description)\n        self._register_klipper(show_macros, macro_name, command, description, options)\n\n    # Modified from the ShakeTune project\n    def register_commands(self, show_macros, macro_name, command, description, options=None):\n        gcode = self.printer.lookup_object('gcode')\n\n        # Register AFC macro commands using the official Klipper API (gcode.register_command)\n        # Doing this makes the commands available in Klipper, but they are not shown in the web interfaces\n        # and are only available by typing the full name in the console (like all the other Klipper commands)\n        # for name, command, description in afc_commands:\n        gcode.register_command(f'_{macro_name}' if show_macros else macro_name, command, desc=description)\n\n        self._register_klipper(show_macros, macro_name, command, description, options)\n\n    # Modified from the ShakeTune project\n    def _register_klipper(self, show_macros, macro_name, command, description, options=None):\n        # Then, a hack to inject the macros into Klipper's config system in order to show them in the web\n        # interfaces. This is not a good way to do it, but it's the only way to do it for now to get\n        # a good user experience while using AFC (it's indeed easier to just click a macro button)\n        if show_macros:\n            name = f'gcode_macro {macro_name}'\n            if not self.config.fileconfig.has_section(name):\n                self.config.fileconfig.add_section(name)\n                self.config.fileconfig.set(name, 'description', description)\n                if options is not None:\n                    self.config.fileconfig.set(name, 'gcode', self._create_options(macro_name, options))\n                else:\n                    self.config.fileconfig.set(name, 'gcode', self._create_no_options(macro_name))\n\n                for option in self.config.fileconfig.options(name):\n                    self.config.access_tracking[(name.lower(), option.lower())] = 1\n            self.printer.load_object(self.config, name)\n\n    def _safe_extrude(self, amount_mm, feedrate=100):\n        \"\"\"\n        Helper function to safely extrude a given amount of filament, checking if the lane is loaded and\n        if the toolhead is in absolute mode.\n\n        :param amount_mm: Amount of filament to extrude in mm\n        :param feedrate: Feedrate for extrusion in mm/min\n        \"\"\"\n        self.afc.gcode.run_script_from_command(\"M400\")  # Finish queued moves\n        self.afc.gcode.run_script_from_command(\"M83\")  # Relative extrusion mode\n        self.afc.gcode.run_script_from_command(\"G92 E0\")  # Zero extruder\n        self.afc.logger.info(f\"Extruding {amount_mm}mm\")\n        self.afc.gcode.run_script_from_command(f\"G1 E{amount_mm} F{feedrate}\")\n        self.afc.gcode.run_script_from_command(\"M82\")\n\n    cmd_AFC_TEST_LANES_help = 'Run load/unload tests on specified lanes'\n    def cmd_AFC_TEST_LANES(self, gcmd):\n        \"\"\"\n        Run load/unload tests on specified lanes. This command allows users to test the loading and unloading\n        mechanisms to serve as a stress test / diagnostic tool for the AFC system with an interactive prompt.\n\n        Usage\n        -----\n        `AFC_TEST_LANES`\n\n        Example\n        -----\n        ```\n        AFC_TEST_LANES\n        ```\n        \"\"\"\n\n        no_lanes_loaded = not any(lane.load_state for lane in self.afc.lanes.values())\n\n        if no_lanes_loaded:\n            self.logger.info('No lanes loaded, please load lanes before running tests.')\n            return\n\n        if self.afc.current is not None:\n            self.logger.info('Toolhead must be unloaded to run tests.')\n            return\n\n        prompt = AFCprompt(gcmd, self.logger)\n        buttons = []\n        title = 'AFC Test Lanes'\n        text = ('The following prompts will allow you to test the loading and unloading of your lanes.'\n                ' Lanes must be loaded before running tests.')\n\n        for index, (key, item) in enumerate(self.afc.lanes.items()):\n            if item.load_state and item.prep_state:\n                button_label = '{}'.format(key)\n                button_command = 'TEST_LANE_ITERATIONS LANE={}'.format(key)\n                button_style = \"primary\" if index % 2 == 0 else \"secondary\"\n                buttons.append((button_label, button_command, button_style))\n\n        bow_footer = [(\"All Lanes\", \"TEST_LANE_ITERATIONS LANE=all\", \"primary\")]\n        prompt.create_custom_p(title, text, buttons,\n                               True, None, bow_footer)\n\n    cmd_TEST_LANE_ITERATIONS_help = 'Specify number of iterations for lane tests'\n    def cmd_TEST_LANE_ITERATIONS(self, gcmd):\n        \"\"\"\n        This function creates a prompt to specify the number of iterations for lane tests.\n        \"\"\"\n\n        prompt = AFCprompt(gcmd, self.logger)\n        buttons = []\n        lane = gcmd.get('LANE', None)\n        title = 'Iteration Count'\n        text = ('How many iterations would you like to run?\\n'\n                'Note: This will run # of iterations * each lane selected.\\n'\n                'Please let all iterations run to completion before using any commands.')\n        iteration_max = 5\n        for iteration in range(1, iteration_max + 1):\n            button_label = \"{}\".format(iteration)\n            button_style = \"primary\" if iteration % 2 == 0 else \"secondary\"\n            button_command = \"TEST_LANE LANE={} ITERATION={}\".format(lane, iteration)\n            buttons.append((button_label, button_command, button_style))\n\n        prompt.create_custom_p(title, text, buttons, True, None, None)\n\n    cmd_TEST_LANE_help = 'Run load/unload tests on specified lane(s)'\n    def cmd_TEST_LANE(self, gcmd):\n        \"\"\"\n        This function runs a load/unload test on a specified lane or all lanes.\n\n        Usage\n        -----\n        `TEST_LANE LANE=<lane_name> ITERATION=<number_of_iterations>`\n\n        Example\n        -----\n        ```\n        TEST_LANE LANE=lane1 ITERATION=3\n        ```\n        ```\n        TEST_LANE LANE=all ITERATION=5\n        ```\n        \"\"\"\n\n        iterations = gcmd.get_int('ITERATION', 1)\n        lane = gcmd.get('LANE', None)\n\n        prompt = AFCprompt(gcmd, self.logger)\n        prompt.p_end()\n\n        if lane is not None:\n            self.afc.gcode.run_script_from_command('AFC_PARK')\n            self.logger.info('Starting test for lane(s): {}'.format(lane))\n            lane_obj = self.afc.lanes.get(lane)\n            if lane != 'all':\n                self.afc.logger.info('Running {} iterations for lane: {}'.format(iterations, lane))\n                for _ in range(iterations):\n                    self.afc.logger.info('Loading lane: {}'.format(lane))\n                    self.afc.CHANGE_TOOL(lane_obj)\n                    if not self.afc.error_state:\n                        self.afc.logger.info(\"Lane {} loaded successfully\".format(lane))\n                    else:\n                        self.afc.logger.error(\"Failed to load lane {}\".format(lane))\n                        self.afc.error.reset_failure()\n                        break\n                    self._safe_extrude(self.afc.test_extrude_amt)\n                    self.logger.info(\"Unloading lane {}\".format(lane))\n                    self.afc.TOOL_UNLOAD(lane_obj)\n                    if not self.afc.error_state:\n                        self.afc.logger.info(\"Lane {} unloaded successfully\".format(lane))\n                    else:\n                        self.afc.logger.error(\"Failed to unload lane {}\".format(lane))\n                        self.afc.error.reset_failure()\n                        return\n\n\n            else:\n                loaded_lanes = [item for key, item in self.afc.lanes.items() if item.load_state and item.prep_state]\n                self.afc.logger.info('Running {} iterations for all loaded lanes'.format(iterations))\n                for i in range(iterations):\n                    random.shuffle(loaded_lanes)\n                    for lane_obj in loaded_lanes:\n                        self.afc.logger.info('Loading lane: {}'.format(lane_obj))\n                        self.afc.CHANGE_TOOL(lane_obj)\n                        if not self.afc.error_state:\n                            self.afc.logger.info(\"Lane {} loaded successfully\".format(lane_obj))\n                        else:\n                            self.afc.logger.error(\"Failed to load lane {}\".format(lane_obj))\n                            self.afc.error.reset_failure()\n                            return\n                        self._safe_extrude(self.afc.test_extrude_amt)\n                        self.logger.info(\"Unloading lane {}\".format(lane_obj))\n                    if i == iterations - 1:\n                        self.afc.logger.info(\n                            \"Finished testing with {} iterations for all loaded lanes\".format(iterations)\n                        )\n                        self.afc.TOOL_UNLOAD(lane_obj)\n        prompt.p_end()\n\n\n    cmd_AFC_CALIBRATION_help = 'open prompt to begin calibration by selecting Unit to calibrate'\n    def cmd_AFC_CALIBRATION(self, gcmd):\n        \"\"\"\n        Open a prompt to start AFC calibration by selecting a unit to calibrate. Creates buttons for each unit and\n        allows the option to calibrate all lanes across all units.\n\n        Usage\n        -----\n        `AFC_CALIBRATION`\n\n        Example\n        -----\n        ```\n        AFC_CALIBRATION\n        ```\n        \"\"\"\n        prompt = AFCprompt(gcmd, self.logger)\n        buttons = []\n        title = 'AFC Calibration'\n        text = ('The following prompts will lead you through the calibration of your AFC unit(s).'\n                ' First, select a unit to calibrate.'\n                ' *All values will be automatically updated in the appropriate config sections.')\n        for index, (key, item) in enumerate(self.afc.units.items()):\n            # Create a button for each unit\n            button_label = \"{}\".format(key)\n            button_command = 'UNIT_CALIBRATION UNIT={}'.format(key)\n            button_style = \"primary\" if index % 2 == 0 else \"secondary\"\n            buttons.append((button_label, button_command, button_style))\n\n        bow_footer = [(\"All Lanes in all units\", \"ALL_CALIBRATION\", \"secondary\")]\n        prompt.create_custom_p(title, text, buttons,\n                               True, None, bow_footer)\n\n    cmd_ALL_CALIBRATION_help = 'open prompt to begin calibration to confirm calibrating all lanes'\n    def cmd_ALL_CALIBRATION(self, gcmd):\n        \"\"\"\n        Open a prompt to confirm calibration of all lanes in all units. Provides 'Yes' to confirm and 'Back' to\n        return to the previous menu.\n\n        Usage\n        -----\n        `ALL_CALIBRATION`\n\n        Example\n        -----\n        ```\n        ALL_CALIBRATION\n        ```\n        \"\"\"\n        prompt = AFCprompt(gcmd, self.logger)\n        footer = []\n        title = 'Calibrate all'\n        text = 'Press Yes to confirm calibrating all lanes in all units'\n        footer.append(('Back', 'AFC_CALIBRATION', 'info'))\n        footer.append((\"Yes\", \"CALIBRATE_AFC LANE=all\", \"error\"))\n\n        prompt.create_custom_p(title, text, None,\n                               True, None, footer)\n\n\n    cmd_CALIBRATE_AFC_help = 'calibrate the dist hub for lane and then afc_bowden_length'\n    def cmd_CALIBRATE_AFC(self, gcmd):\n        \"\"\"\n        This function performs the calibration of the hub and Bowden length for one or more lanes within an AFC\n        (Automated Filament Control) system. The function uses precise movements to adjust the positions of the\n        steppers, check the state of the hubs and tools, and calculate distances for calibration based on the\n        user-provided input. If no specific lane is provided, the function defaults to notifying the user that no lane has been selected. The function also includes\n        the option to calibrate the Bowden length for a particular lane, if specified.\n\n        Parameters:\n        - LANES: Specifies the lane to calibrate. If not provided, calibrates no lanes.\n        - DISTANCE: The distance to move during calibration (optional, defaults to 25mm).\n        - TOLERANCE: The tolerance for fine adjustments during calibration (optional, defaults to 5mm).\n        - BOWDEN: Specifies the lane to perform Bowden length calibration (optional).\n        - UNIT: Specifies the unit to be used in calibration (optional)\n\n        Usage\n        -----\n        `CALIBRATE_AFC LANE=<lane> DISTANCE=<distance> TOLERANCE=<tolerance> BOWDEN=<lane>`\n\n        Example\n        -----\n        ```\n        CALIBRATE_AFC LANE=all Bowden=lane1 DISTANCE=30 TOLERANCE=3\n        ```\n        ```\n        CALIBRATE_AFC BOWDEN=lane1` (Calibrates the Bowden length for 'lane1')\n        ```\n        \"\"\"\n        prompt = AFCprompt(gcmd, self.logger)\n        dis    = gcmd.get_float('DISTANCE' , 25)\n        tol    = gcmd.get_float('TOLERANCE', 5)\n        afc_bl = gcmd.get(      'BOWDEN'   , None)\n        lanes  = gcmd.get(      'LANE'     , None)\n        unit   = gcmd.get(      'UNIT'     , None)\n\n        prompt.p_end()\n\n        if self.afc.current is not None:\n            self.logger.info('Tool must be unloaded to calibrate system')\n            return\n\n        calibrated = []\n        checked    = False\n        # Check to make sure lane and unit is valid\n        if lanes is not None and lanes != 'all' and lanes not in self.afc.lanes:\n            self.afc.error.AFC_error(\"'{}' is not a valid lane\".format(lanes), pause=False)\n            return\n\n        if unit is not None and unit not in self.afc.units:\n            self.afc.error.AFC_error(\"'{}' is not a valid unit\".format(unit), pause=False)\n            return\n\n        if afc_bl is not None and afc_bl not in self.afc.lanes:\n            self.afc.error.AFC_error(\"'{}' is not a valid lane to calibrate bowden length\".format(afc_bl), pause=False)\n            return\n\n        # Determine if a specific lane is provided\n        if lanes is not None:\n            self.logger.info('Starting AFC distance Calibrations')\n            if unit is None:\n                if lanes != 'all':\n                    cur_lane = self.afc.lanes[lanes]\n                    checked, msg, pos = cur_lane.unit_obj.calibrate_lane(cur_lane, tol)\n                    if(not checked):\n                        self.afc.error.AFC_error(msg, False)\n                        if pos > 0:\n                            self.afc.gcode.run_script_from_command('AFC_CALI_FAIL FAIL={} DISTANCE={}'.format(cur_lane, pos))\n                        return\n                    else: calibrated.append(lanes)\n                else:\n                    # Calibrate all lanes if no specific lane is provided\n                    for cur_lane in self.afc.lanes.values():\n                        if not cur_lane.load_state or not cur_lane.prep_state:\n                            self.logger.info(\"{} not loaded skipping to next loaded lane\".format(cur_lane.name))\n                            continue\n                        # Calibrate the specific lane\n                        checked, msg, pos = cur_lane.unit_obj.calibrate_lane(cur_lane, tol)\n                        if(not checked):\n                            self.afc.error.AFC_error(msg, False)\n                            self.afc.gcode.run_script_from_command('AFC_CALI_FAIL FAIL={} DISTANCE={}'.format(cur_lane, pos))\n                            return\n                        else: calibrated.append(cur_lane.name)\n            else:\n                if lanes != 'all':\n                    cur_lane = self.afc.lanes[lanes]\n                    checked, msg, pos = cur_lane.unit_obj.calibrate_lane(cur_lane, tol)\n                    if(not checked):\n                        self.afc.error.AFC_error(msg, False)\n                        self.afc.gcode.run_script_from_command('AFC_CALI_FAIL FAIL={} DISTANCE={}'.format(cur_lane, pos))\n                        return\n                    else: calibrated.append(lanes)\n                else:\n                    CUR_UNIT = self.afc.units[unit]\n                    self.logger.info('{}'.format(CUR_UNIT.name))\n                    # Calibrate all lanes if no specific lane is provided\n                    for cur_lane in CUR_UNIT.lanes.values():\n                        if not cur_lane.load_state or  not cur_lane.prep_state:\n                            self.logger.info(\"{} not loaded skipping to next loaded lane\".format(cur_lane.name))\n                            continue\n                        # Calibrate the specific lane\n                        checked, msg, pos = CUR_UNIT.calibrate_lane(cur_lane, tol)\n                        if(not checked):\n                            self.afc.error.AFC_error(msg, False)\n                            self.afc.gcode.run_script_from_command('AFC_CALI_FAIL FAIL={} DISTANCE={}'.format(cur_lane, pos))\n                            return\n                        else: calibrated.append(cur_lane.name)\n\n            self.logger.info(\"Lane calibration Done!\")\n\n        else:\n            self.logger.info('No lanes selected to calibrate dist_hub')\n\n        # Calibrate Bowden length with specified lane\n        if afc_bl is not None:\n            set_tool_start_back_to_none = False\n            cur_lane=self.afc.lanes[afc_bl]\n\n            # Setting tool start to buffer if only tool_end is set and user has buffer so calibration can run\n            if cur_lane.extruder_obj.tool_start is None:\n                if cur_lane.extruder_obj.tool_end is not None and cur_lane.buffer_obj is not None:\n                    self.logger.info(\"Cannot run calibration using post extruder sensor, using buffer to calibrate bowden length\")\n                    cur_lane.extruder_obj.tool_start = \"buffer\"\n                    set_tool_start_back_to_none = True\n                else:\n                    # Cannot calibrate\n                    self.afc.error.AFC_error(\"Cannot calibrate with only post extruder sensor and no turtleneck buffer defined in config\", pause=False)\n                    return\n\n            self.logger.info('Starting AFC distance Calibrations')\n\n            checked, msg, pos = cur_lane.unit_obj.calibrate_bowden(cur_lane, dis, tol)\n            if not checked:\n                self.afc.error.AFC_error('{} failed to calibrate bowden length {}'.format(afc_bl, msg), pause=False)\n                self.afc.gcode.run_script_from_command('AFC_CALI_FAIL FAIL={} DISTANCE={}'.format(afc_bl, pos))\n                return\n            else: calibrated.append('Bowden_length:_{}'.format(afc_bl))\n\n            self.logger.info(\"Bowden length calibration Done!\")\n\n            if set_tool_start_back_to_none:\n                cur_lane.extruder_obj.tool_start = None\n\n        if checked:\n            lanes_calibrated = ','.join(calibrated)\n            self.afc.gcode.run_script_from_command('AFC_CALI_COMP CALI={}'.format(lanes_calibrated))\n\n    cmd_AFC_CALI_COMP_help = 'Opens prompt after calibration is complete'\n    def cmd_AFC_CALI_COMP(self, gcmd):\n        \"\"\"\n        This function handles the completion of the AFC calibration process by displaying a prompt to the user, asking\n        whether they want to perform more calibrations.\n\n        Usage\n        -----\n        `AFC_CALI_COMP CALI=<calibration context>`\n\n        Examples\n        -----\n        ```\n        AFC_CALI_COMP CALI=lane1\n        ```\n        (Shows a prompt indicating that calibration for 'lane1' has been completed)\n        \"\"\"\n\n        cali = gcmd.get(\"CALI\", None)\n\n        prompt = AFCprompt(gcmd, self.logger)\n        buttons = []\n        title = 'AFC Calibration Completed'\n        text = 'Calibration was completed for {}, would you like to do more calibrations?'.format(cali)\n        buttons.append((\"Yes\", \"AFC_Calibration\", \"primary\"))\n        buttons.append((\"No\", \"AFC_HAPPY_P STEP='AFC Calibration'\", \"info\"))\n\n        prompt.create_custom_p(title, text, buttons,\n                               True, None)\n\n    cmd_AFC_HAPPY_P_help = 'Opens prompt after calibration is complete'\n    def cmd_AFC_HAPPY_P(self, gcmd):\n        \"\"\"\n        This function opens a prompt after calibration is complete, displaying a message to the user that the calibration\n        step has been successfully completed.\n\n        Usage: `AFC_HAPPY_P STEP=<step>`\n\n        Examples:\n            - `AFC_HAPPY_P STEP='AFC Calibration lane3'` (Shows the completion message for AFC Calibration)\n\n        Args:\n            gcmd: The G-code command object containing the parameters for the command.\n                Parameters:\n                - STEP: Specifies the step that has been completed (e.g., AFC Calibration, Extruder Calibration).\n\n        Returns:\n            None\n        NO_DOC: True\n        \"\"\"\n\n        step = gcmd.get(\"STEP\", None)\n\n        prompt = AFCprompt(gcmd, self.logger)\n        buttons = None\n        footer = []\n        title = '{} Completed'.format(step)\n        text = 'Happy Printing!'\n        prompt.create_custom_p(title, text, buttons,\n                               False, None, footer)\n        self.afc.reactor.pause(self.afc.reactor.monotonic() + 3)\n        self.afc.gcode.respond_raw(\"// action:prompt_end\")\n\n    cmd_AFC_CALI_FAIL_help = 'Opens prompt after calibration fails'\n    def cmd_AFC_CALI_FAIL(self, gcmd):\n        \"\"\"\n        This function opens a prompt after an AFC calibration failure. It informs the user about the failure and provides\n        instructions to reset the lane and review the error messages in the console. The user is prompted to take corrective\n        action and re-run the calibration.\n\n        Usage: `AFC_CALI_FAIL FAIL=<lane> DISTANCE=<distance>`\n\n        Examples:\n            - `AFC_CALI_FAIL FAIL=lane1 DISTANCE=30` (Indicates that the calibration for lane1 failed at a 30mm distance)\n\n        Args:\n            gcmd: The G-code command object containing the parameters for the command.\n                Parameters:\n                - FAIL: Specifies the lane where the calibration failed.\n                - DISTANCE: The distance value that caused the failure (optional).\n\n        Returns:\n            None\n        NO_DOC: True\n        \"\"\"\n\n        cali = gcmd.get(\"FAIL\", None)\n        dis = gcmd.get(\"DISTANCE\", None)\n\n        prompt = AFCprompt(gcmd, self.logger)\n        buttons = []\n        footer = []\n        title = 'AFC Calibration Failed'\n        text = 'Calibration failed  for {}. First: reset lane, Second: review messages in console and take necessary action and re-run calibration.'.format(cali)\n        buttons.append((\"Reset lane\", \"AFC_LANE_RESET LANE={} DISTANCE={}\".format(cali, dis), \"primary\"))\n        footer.append(('EXIT', 'prompt_end', 'info'))\n\n        prompt.create_custom_p(title, text, buttons,\n                               True, None)\n\n    cmd_AFC_RESET_help = 'Opens prompt to select lane to reset.'\n    cmd_AFC_RESET_options = {\"DISTANCE\": {\"default\": \"30\", \"type\": \"float\"}}\n    def cmd_AFC_RESET(self, gcmd):\n        \"\"\"\n        This function opens a prompt allowing the user to select a loaded lane for reset. It displays a list of loaded lanes\n        and provides a reset button for each lane. If no lanes are loaded, an informative message is displayed indicating\n        that a lane must be loaded to proceed with resetting.\n\n        Usage\n        -----\n        `AFC_RESET DISTANCE=<distance>`\n\n        Example\n        -----\n        (Shows the prompt for resetting lanes with a distance value of 30mm)\n        ```\n        AFC_RESET DISTANCE=30\n        ```\n        (Shows the prompt for resetting lanes without specifying a distance)\n        ```\n        AFC_RESET\n        ```\n        \"\"\"\n\n        prompt = AFCprompt(gcmd, self.logger)\n        dis = gcmd.get(\"DISTANCE\", None)\n        buttons = []\n        title = 'AFC RESET'\n        text = 'Select a loaded lane to reset'\n\n        # Create buttons for each loaded lane\n        for index, LANE in enumerate(self.afc.lanes.values()):\n            if LANE.load_state:\n                button_label = \"{}\".format(LANE.name)\n                if dis is not None:\n                    button_command = \"AFC_LANE_RESET LANE={} DISTANCE={}\".format(LANE.name, dis)\n                else:\n                    button_command = \"AFC_LANE_RESET LANE={}\".format(LANE.name)\n\n                button_style = \"primary\" if index % 2 == 0 else \"secondary\"\n                buttons.append((button_label, button_command, button_style))\n\n        total_buttons = sum(len(group) for group in buttons)\n        if total_buttons == 0:\n            text = 'No lanes are loaded, a lane must be loaded to be reset'\n\n        prompt.create_custom_p(title, text, buttons,\n                        True, None)\n\n    cmd_AFC_LANE_RESET_help = 'reset a loaded lane to hub'\n    cmd_AFC_LANE_RESET_options = {\"DISTANCE\": {\"default\": \"50\", \"type\": \"float\"},\n                                  \"LANE\": {\"default\": \"lane1\", \"type\": \"string\"}}\n    def cmd_AFC_LANE_RESET(self, gcmd):\n        \"\"\"\n        This function resets a specified lane to the hub position in the AFC system. It checks for various error conditions,\n        such as whether the toolhead is loaded or whether the hub is already clear. The function moves the lane back to the\n        hub based on the specified or default distances, ensuring the lane's correct state before completing the reset.\n\n        Usage\n        -----\n        `AFC_LANE_RESET LANE=<lane> DISTANCE=<distance>`\n\n        Example\n        -----\n        (Resets lane1 to the hub with a move of 50mm)\n        ```\n        AFC_LANE_RESET LANE=lane1 DISTANCE=50\n        ```\n        (Resets lane2 to the hub using default settings)\n        ```\n        AFC_LANE_RESET LANE=lane2\n        ```\n        \"\"\"\n\n        prompt = AFCprompt(gcmd, self.logger)\n        lane = gcmd.get('LANE', None)\n        long_dis = gcmd.get('DISTANCE', None)\n        cur_lane = self.afc.lanes[lane]\n        CUR_HUB = cur_lane.hub_obj\n        short_move = cur_lane.short_move_dis * 2\n\n        if lane is not None and lane not in self.afc.lanes:\n            prompt.p_end()\n            self.afc.error.AFC_error(\"'{}' is not a valid lane\".format(lane), pause=False)\n            return\n\n        if not CUR_HUB.state:\n            prompt.p_end()\n            self.afc.error.AFC_error(\"Hub is already clear while trying to reset '{}'\".format(lane), pause=False)\n            return\n\n        if (tool_load := self.get_current_lane_obj()) is not None:\n            prompt.p_end()\n            self.afc.error.AFC_error(\"Toolhead is loaded with '{}', unload or check sensor before resetting lane\".format(tool_load.name), pause=False)\n\n        prompt.p_end()\n        self.afc.gcode.respond_info('Resetting {} to hub'.format(lane))\n        pos = 0\n        fail_state_msg = \"'{}' failed to reset to hub, {} switch became false during reset\"\n\n        if long_dis is not None:\n            cur_lane.move(float(long_dis) * -1, cur_lane.long_moves_speed, cur_lane.long_moves_accel, True)\n\n        while CUR_HUB.state:\n            cur_lane.move(short_move * -1, cur_lane.short_moves_speed, cur_lane.short_moves_accel, True)\n            pos -= short_move\n\n            if not cur_lane.load_state:\n                self.afc.error.AFC_error(fail_state_msg.format(cur_lane, \"load\"), pause=False)\n                return\n\n            if not cur_lane.prep_state:\n                self.afc.error.AFC_error(fail_state_msg.format(cur_lane, \"prep\"), pause=False)\n                return\n\n            if abs(pos) >= CUR_HUB.afc_bowden_length:\n                self.afc.error.AFC_error(\"'{}' failed to reset to hub\".format(cur_lane), pause=False)\n                return\n\n        cur_lane.move(CUR_HUB.move_dis * -1, cur_lane.short_moves_speed, cur_lane.short_moves_accel, True)\n        cur_lane.loaded_to_hub = True\n        cur_lane.do_enable(False)\n\n        self.afc.gcode.respond_info('{} reset to hub, take necessary action'.format(lane))\n\n    def _calc_length(self, config_length, current_length, new_length):\n        \"\"\"\n        Common function to calculate length for afc_bowden_length, afc_unload_bowden_length, and hub_dist\n\n        :param config_length: Current configuration length that's in config file\n        :param current_length: Current length for bowden or hub_dist\n        :param new_length: New length to set, increase(+), decrease(-), or reset to config value\n\n        :returns length: Calculated length value\n        \"\"\"\n        length = 0.0\n\n        if new_length.lower() == 'reset':\n            length = config_length\n        else:\n            if new_length[0] in ('+', '-'):\n                try:\n                    bowden_value = float(new_length)\n                    length = current_length + bowden_value\n                except ValueError:\n                    length = current_length\n                    self.logger.error(\"Invalid length: {}\".format(new_length))\n            else:\n                length = float(new_length)\n\n        return length\n\n    cmd_SET_BOWDEN_LENGTH_help = \"Helper to dynamically set length of bowden between hub and toolhead. Pass in HUB if using multiple box turtles\"\n    def cmd_SET_BOWDEN_LENGTH(self, gcmd):\n        \"\"\"\n        This function adjusts the length of the Bowden tube between the hub and the toolhead.\n        It retrieves the hub specified by the 'HUB' parameter and the length adjustment specified\n        by the 'LENGTH' parameter. UNLOAD_LENGTH adjusts unload Bowden length. If the hub is not specified\n        and a lane is currently loaded, it uses the hub of the current lane. To reset length back to config\n        value, pass in `reset` for each length to reset to value in config file. Adding +/- in front of the\n        length will increase/decrease bowden length by that amount.\n\n        Usage\n        -----\n        `SET_BOWDEN_LENGTH HUB=<hub> LENGTH=<length> UNLOAD_LENGTH=<length>`\n\n        Example\n        -----\n        ```\n        SET_BOWDEN_LENGTH HUB=Turtle_1 LENGTH=+100 UNLOAD_LENGTH=-100\n        ```\n\n        Args:\n        \"\"\"\n        hub           = gcmd.get(\"HUB\", None )\n        length_param  = gcmd.get('LENGTH', None)\n        unload_length = gcmd.get('UNLOAD_LENGTH', None)\n\n        # If hub is not passed in try and get hub if a lane is currently loaded\n        if hub is None and self.afc.current is not None:\n            cur_lane = self.afc.lanes[self.current]\n            hub     = cur_lane.hub_obj.name\n        elif hub is None and self.current is None:\n            self.logger.info(\"A lane is not loaded please specify hub to adjust bowden length\")\n            return\n\n        CUR_HUB                 = self.afc.hubs[hub]\n        cur_bowden_len          = CUR_HUB.afc_bowden_length\n        cur_unload_bowden_len   = CUR_HUB.afc_unload_bowden_length\n\n        if length_param is not None:\n            CUR_HUB.afc_bowden_length = self._calc_length(CUR_HUB.config_bowden_length, cur_bowden_len, length_param)\n\n        if unload_length is not None:\n            CUR_HUB.afc_unload_bowden_length = self._calc_length(CUR_HUB.config_unload_bowden_length, cur_unload_bowden_len, unload_length)\n\n        msg =  '// Hub : {}\\n'.format( hub )\n        msg += '// afc_bowden_length:\\n'\n        msg += '//   Config Bowden Length:   {}\\n'.format(CUR_HUB.config_bowden_length)\n        msg += '//   Previous Bowden Length: {}\\n'.format(cur_bowden_len)\n        msg += '//   New Bowden Length:      {}\\n'.format(CUR_HUB.afc_bowden_length)\n        msg += '// afc_unload_bowden_length:\\n'\n        msg += '//   Config Bowden Length:   {}\\n'.format(CUR_HUB.config_unload_bowden_length)\n        msg += '//   Previous Bowden Length: {}\\n'.format(cur_unload_bowden_len)\n        msg += '//   New Bowden Length:      {}\\n'.format(CUR_HUB.afc_unload_bowden_length)\n        msg += '\\n// TO SAVE BOWDEN LENGTH afc_bowden_length MUST BE UPDATED IN AFC_Turtle_(n).cfg for each AFC_hub if there are multiple'\n        self.logger.raw(msg)\n\n    cmd_HUB_CUT_TEST_help = \"Test the cutting sequence of the hub cutter, expects LANE=laneN\"\n    def cmd_HUB_CUT_TEST(self, gcmd):\n        \"\"\"\n        This function tests the cutting sequence of the hub cutter for a specified lane.\n        It retrieves the lane specified by the 'LANE' parameter, performs the hub cut,\n        and responds with the status of the operation.\n\n        Usage\n        -----\n        `HUB_CUT_TEST LANE=<lane>`\n\n        Example\n        -----\n        ```\n        HUB_CUT_TEST LANE=lane1\n        ```\n        \"\"\"\n        lane = gcmd.get('LANE', None)\n        self.logger.info('Testing Hub Cut on Lane: {}'.format(lane))\n        if lane not in self.afc.lanes:\n            self.logger.info('{} Unknown'.format(lane))\n            return\n        cur_lane = self.afc.lanes[lane]\n        CUR_HUB = cur_lane.hub_obj\n        CUR_HUB.hub_cut(cur_lane)\n        self.logger.info('Hub cut Done!')\n\n    cmd_TEST_help = \"Test Assist Motors, spins spoolers like rewinding spool\"\n    def cmd_TEST(self, gcmd):\n        \"\"\"\n        This function tests the assist motors of a specified lane at various speeds.\n        Spins the spoolers in reverse like trying to rewind the spool.<br>\n        It performs the following steps:<br>\n        1. Retrieves the lane specified by the 'LANE' parameter.<br>\n        2. Tests the assist motor at full speed, 50%, 30%, and 10% speeds.<br>\n        3. Reports the status of each test step.<br>\n\n        Usage\n        -----\n        `TEST LANE=<lane>`\n\n        Example\n        -----\n        ```\n        TEST LANE=lane1\n        ```\n        \"\"\"\n        lane = gcmd.get('LANE', None)\n        if lane is None:\n            self.afc.error.AFC_error('Must select LANE', False)\n            return\n\n        if lane not in self.afc.lanes:\n            self.logger.info('{} Unknown'.format(lane))\n            return\n\n        cur_lane = self.afc.lanes[lane]\n        if cur_lane.espooler.afc_motor_rwd is None:\n            message = \"afc_motor_rwd is not defined in config for {}, cannot perform test.\\n\".format(lane)\n            message += \"If your unit does not have spooler motors then you can ignore this message.\\n\"\n            message += \"If your unit has spooler motors please verify your config is setup properly\"\n            self.logger.info(message)\n            return\n\n        self.logger.info('Testing at full speed')\n        cur_lane.espooler.assist(-1)\n        self.afc.reactor.pause(self.afc.reactor.monotonic() + 1)\n        if cur_lane.espooler.afc_motor_rwd.is_pwm:\n            self.logger.info('Testing at 50 percent speed')\n            cur_lane.espooler.assist(-.5)\n            self.afc.reactor.pause(self.afc.reactor.monotonic() + 1)\n            self.logger.info('Testing at 30 percent speed')\n            cur_lane.espooler.assist(-.3)\n            self.afc.reactor.pause(self.afc.reactor.monotonic() + 1)\n            self.logger.info('Testing at 10 percent speed')\n            cur_lane.espooler.assist(-.1)\n            self.afc.reactor.pause(self.afc.reactor.monotonic() + 1)\n        self.logger.info('Test routine complete')\n        cur_lane.espooler.assist(0)\n\nclass afcDeltaTime:\n    def __init__(self, AFC):\n        self.logger = AFC.logger\n        self.start_time = None\n        self.last_time  = None\n\n    def set_start_time(self):\n        self.major_delta_time = self.last_time = self.start_time = datetime.now()\n\n    def log_with_time(self, msg, debug=True):\n        try:\n            curr_time = datetime.now()\n            delta_time = (curr_time - self.last_time ).total_seconds()\n            total_time = (curr_time - self.start_time).total_seconds()\n            msg = \"{} (\u0394t:{:.3f}s, t:{:.3f})\".format( msg, delta_time, total_time )\n            if debug:\n                self.logger.debug( msg )\n            else:\n                self.logger.info( msg )\n            self.last_time = curr_time\n        except Exception as e:\n            self.logger.debug(\"Error in log_with_time function {}\".format(e))\n\n    def log_major_delta(self, msg, debug=True):\n        delta_time = 0\n        try:\n            curr_time = datetime.now()\n            delta_time = (curr_time - self.major_delta_time ).total_seconds()\n            msg = \"{} t:{:.3f}\".format( msg, delta_time )\n            self.logger.info( msg )\n            self.major_delta_time = curr_time\n        except Exception as e:\n            self.logger.debug(\"Error in log_major_delta function {}\".format(e))\n\n        return delta_time\n\n    def log_total_time(self, msg):\n        total_time = 0\n        try:\n            total_time = (datetime.now() - self.start_time).total_seconds()\n            msg = \"{} t:{:.3f}\".format( msg, total_time )\n\n            self.logger.info( msg )\n        except Exception as e:\n            self.logger.debug(\"Error in log_total_time function {}\".format(e))\n\n        return total_time\n",
    'extras.AFC_logger': "# Armored Turtle Automated Filament Control\n#\n# Copyright (C) 2024 Armored Turtle\n#\n# This file may be distributed under the terms of the GNU GPLv3 license.\n\nimport logging\nimport re\nimport os\nfrom queuelogger import QueueListener, QueueHandler\nfrom pathlib import Path\nfrom webhooks import GCodeHelper\n\nclass AFC_QueueListener(QueueListener):\n    def __init__(self, filename):\n        try:\n            # Kalico needs an extra parameter passed in for log rollover\n            super().__init__(filename, False)\n        except:\n            super().__init__(filename)\n\n        logging.handlers.TimedRotatingFileHandler.__init__(\n            self, filename, when=\"S\", interval=60 * 60 * 24, backupCount=5\n        )\n\n        # Commenting out log rollover for now as it causes more of a hassle when getting users logs\n        # and causes information to disappear if a user restart alot\n        # logging.handlers.TimedRotatingFileHandler.doRollover(self)\n\nclass AFC_logger:\n    def __init__(self, printer, afc_obj):\n        self.reactor = printer.reactor\n        self.afc     = afc_obj\n        self.gcode   = printer.lookup_object('gcode')\n        self.webhooks = printer.lookup_object('webhooks')\n        printer.register_event_handler( \"gcode:request_restart\", self._stop)\n\n        log_path = printer.start_args['log_file']\n        dirname = Path(log_path).parent\n        log_file = Path(dirname).joinpath(\"AFC.log\")\n        logger_name = os.path.splitext(os.path.basename(log_file))[0]\n\n        self.afc_ql = AFC_QueueListener(log_file)\n        self.afc_ql.setFormatter(logging.Formatter('%(asctime)s %(message)s', datefmt='%H:%M:%S'))\n        self.afc_queue_handler = QueueHandler(self.afc_ql.bg_queue)\n        self.logger = logging.getLogger(logger_name)\n        self.logger.propagate = False               # Stops logs from going into klippy.log\n        self.logger.addHandler(self.afc_queue_handler)\n        self.logger.setLevel(logging.DEBUG)\n        self.print_debug_console = False\n\n    def _stop(self, eventtime):\n        self.afc_ql.stop()\n\n    def _add_monotonic(self, message):\n        return \"{:10.3f} {}\".format(self.reactor.monotonic(), message)\n\n    def _remove_tags(self, message):\n        return re.sub(\"<.*?>\", \"\", message)\n\n    def _format(self, message):\n        s = self._remove_tags(message.lstrip())\n        return self._add_monotonic(s)\n\n    def send_callback(self, msg):\n        for cb in self.gcode.output_callbacks:\n            if isinstance(cb.__self__, GCodeHelper): cb(msg.lstrip())\n\n    def raw(self, message):\n        for line in message.lstrip().rstrip().split(\"\\n\"):\n            self.logger.info(self._format(line))\n        self.send_callback(message)\n\n    def info(self, message, console_only=False):\n        if not console_only:\n            for line in message.lstrip().split(\"\\n\"):\n                self.logger.info(self._format(line))\n        self.send_callback(message)\n\n    def warning(self, message):\n        for line in message.lstrip().rstrip().split(\"\\n\"):\n            self.logger.debug(self._format(\"WARNING: {}\".format(line)))\n\n        self.send_callback(f\"<span class=warning--text>WARNING: {message}</span>\")\n\n        self.afc.message_queue.append((message, \"warning\"))\n\n    def debug(self, message, only_debug=False, traceback=None):\n        for line in message.lstrip().rstrip().split(\"\\n\"):\n            self.logger.debug(self._format(\"DEBUG: {}\".format(line)))\n\n        if self.print_debug_console and not only_debug:\n            self.send_callback(message)\n\n        if traceback is not None:\n            for line in traceback.lstrip().rstrip().split(\"\\n\"):\n                self.logger.debug( self._format(\"DEBUG: {}\".format(line)))\n\n    def error(self, message, traceback=None, stack_name=\"\"):\n        \"\"\"\n        Prints error to console and log, also adds error to message queue when is then displayed\n        in mainsail/fluidd guis\n\n        :param message: Error message to print to console and log\n        :param traceback: Trackback to log to AFC.log file\n        \"\"\"\n        stack_name = f\"{stack_name}: \" if stack_name else \"\"\n        for line in message.lstrip().rstrip().split(\"\\n\"):\n            self.logger.error( self._format(f\"ERROR: {stack_name}{line}\") )\n        self.send_callback( \"!! {}\".format(message) )\n\n        self.afc.message_queue.append((message, \"error\"))\n\n        if traceback is not None:\n            for line in traceback.lstrip().rstrip().split(\"\\n\"):\n                self.logger.error( self._format(\"ERROR: {}\".format(line)))\n\n\n    def set_debug(self, debug ):\n        self.print_debug_console = debug",
    'extras.AFC_spool': "# Armored Turtle Automated Filament Changer\n#\n# Copyright (C) 2024 Armored Turtle\n#\n# This file may be distributed under the terms of the GNU GPLv3 license.\n\n\nclass AFCSpool:\n    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.printer.register_event_handler(\"klippy:connect\", self.handle_connect)\n\n        # Temporary status variables\n        self.next_spool_id      = ''\n\n    def handle_connect(self):\n        \"\"\"\n        Handle the connection event.\n        This function is called when the printer connects. It looks up the AFC object\n        and assigns it to the instance variable `self.AFC`.\n        \"\"\"\n        self.afc        = self.printer.lookup_object('AFC')\n        self.error      = self.afc.error\n        self.reactor    = self.afc.reactor\n        self.gcode      = self.afc.gcode\n        self.logger     = self.afc.logger\n\n        # Registering stepper callback so that mux macro can be set properly with valid lane names\n        self.printer.register_event_handler(\"afc_stepper:register_macros\",self.register_lane_macros)\n\n        self.gcode.register_command(\"RESET_AFC_MAPPING\", self.cmd_RESET_AFC_MAPPING, desc=self.cmd_RESET_AFC_MAPPING_help)\n        self.gcode.register_command(\"SET_NEXT_SPOOL_ID\", self.cmd_SET_NEXT_SPOOL_ID, desc=self.cmd_SET_NEXT_SPOOL_ID_help)\n\n    def register_lane_macros(self, lane_obj):\n        \"\"\"\n        Callback function to register macros with proper lane names so that klipper errors out correctly when users supply lanes that\n        are not valid\n\n        :param lane_obj: object for lane to register\n        \"\"\"\n        self.gcode.register_mux_command('SET_COLOR',    \"LANE\", lane_obj.name, self.cmd_SET_COLOR,      desc=self.cmd_SET_COLOR_help)\n        self.gcode.register_mux_command('SET_WEIGHT',   \"LANE\", lane_obj.name, self.cmd_SET_WEIGHT,     desc=self.cmd_SET_WEIGHT_help)\n        self.gcode.register_mux_command('SET_MATERIAL', \"LANE\", lane_obj.name, self.cmd_SET_MATERIAL,   desc=self.cmd_SET_MATERIAL_help)\n        self.gcode.register_mux_command('SET_SPOOL_ID', \"LANE\", lane_obj.name, self.cmd_SET_SPOOL_ID,   desc=self.cmd_SET_SPOOL_ID_help)\n        self.gcode.register_mux_command('SET_RUNOUT',   \"LANE\", lane_obj.name, self.cmd_SET_RUNOUT,     desc=self.cmd_SET_RUNOUT_help)\n        self.gcode.register_mux_command('SET_MAP',      \"LANE\", lane_obj.name, self.cmd_SET_MAP,        desc=self.cmd_SET_MAP_help)\n\n    cmd_SET_MAP_help = \"Changes T(n) mapping for a lane\"\n    def cmd_SET_MAP(self, gcmd):\n        \"\"\"\n        This function handles changing the GCODE tool change command for a Lane.\n\n        Usage\n        -----\n        `SET_MAP LANE=<lane> MAP=<cmd>`\n\n        Example\n        -----\n        ```\n        SET_MAP LANE=lane1 MAP=T1\n        ```\n        \"\"\"\n        lane = gcmd.get('LANE', None)\n        if lane is None:\n            self.logger.info(\"No LANE parameter provided, please specify a valid LANE parameter.\")\n            return\n\n        map_cmd = gcmd.get('MAP', None)\n\n        if map_cmd is None:\n            self.logger.info(\"No MAP parameter provided, please specify a valid MAP parameter.\")\n            return\n\n        map_cmd = map_cmd.upper()\n\n        if map_cmd not in self.afc.tool_cmds:\n            self.logger.error(\"Invalid map command: {}\".format(map_cmd))\n            return\n\n        lane_switch = self.afc.tool_cmds[map_cmd]\n        self.logger.debug(\"lane to switch is {}\".format(lane_switch))\n        if lane not in self.afc.lanes:\n            self.logger.info('{} Unknown'.format(lane))\n            return\n        cur_lane = self.afc.lanes[lane]\n        self.afc.tool_cmds[map_cmd]=lane\n        map_switch = cur_lane.map\n        cur_lane.map = map_cmd\n\n        sw_lane = self.afc.lanes[lane_switch]\n        self.afc.tool_cmds[map_switch] = lane_switch\n        sw_lane.map = map_switch\n        self.afc.save_vars()\n\n    cmd_SET_COLOR_help = \"Set filaments color for a lane\"\n    def cmd_SET_COLOR(self, gcmd):\n        \"\"\"\n        This function handles changing the color of a specified lane. It retrieves the lane\n        specified by the 'LANE' parameter and sets its color to the value provided by the 'COLOR' parameter.\n        The 'COLOR' parameter should be a hex color code.\n\n        Usage\n        -----\n        `SET_COLOR LANE=<lane> COLOR=<color>`\n\n        Example\n        -----\n        ```\n        SET_COLOR LANE=lane1 COLOR=FF0000\n        ```\n        \"\"\"\n        lane = gcmd.get('LANE', None)\n        if lane is None:\n            self.logger.info(\"No LANE Defined\")\n            return\n        color = gcmd.get('COLOR', '#000000')\n        if lane not in self.afc.lanes:\n            self.logger.info('{} Unknown'.format(lane))\n            return\n        cur_lane = self.afc.lanes[lane]\n        cur_lane.color = '#{}'.format(color.replace('#',''))\n        self.afc.save_vars()\n\n    cmd_SET_WEIGHT_help = \"Sets filaments weight for a lane\"\n    def cmd_SET_WEIGHT(self, gcmd):\n        \"\"\"\n        This function handles changing the weight remaining of a spool loaded in a specified lane. It retrieves the lane\n        specified by the 'LANE' parameter and sets its weight to the value provided by the 'WEIGHT' parameter.\n\n        Usage\n        -----\n        `SET_WEIGHT LANE=<lane> WEIGHT=<weight>`\n\n        Example\n        -----\n        ```\n        SET_WEIGHT LANE=lane1 WEIGHT=850\n        ```\n        \"\"\"\n        lane = gcmd.get('LANE', None)\n        if lane is None:\n            self.logger.info(\"No LANE Defined\")\n            return\n        weight = gcmd.get_float('WEIGHT', 1000.0)\n        if lane not in self.afc.lanes:\n            self.logger.info('{} Unknown'.format(lane))\n            return\n        cur_lane = self.afc.lanes[lane]\n        cur_lane.weight = weight\n        self.afc.save_vars()\n\n    cmd_SET_MATERIAL_help = \"Sets filaments material for a lane\"\n    def cmd_SET_MATERIAL(self, gcmd):\n        \"\"\"\n        This function handles changing the material of a specified lane. It retrieves the lane\n        specified by the 'LANE' parameter and sets its material to the value provided by the 'MATERIAL' parameter.\n\n        Values\n        ----\n        MATERIAL - Material type to set to lane. eg. PLA, ASA, ABS, PETG etc.\n\n        Optional Values\n        ----\n        DENSITY - Density value to assign to lane. If this is not provided then a default value will be selected based\n                   of material. Current default values: PLA: 1.24, PETG:1.23, ABS:1.04, ASA:1.07\n        DIAMETER - Diameter of filament, defaults to 1.75\n        EMPTY_SPOOL_WEIGHT - Weight of spool once its empty. Defaults to 190.\n\n        Usage\n        -----\n        `SET_MATERIAL LANE=<lane> MATERIAL=<material>`\n\n        Example\n        -----\n        ```\n        SET_MATERIAL LANE=lane1 MATERIAL=ABS\n        ```\n        \"\"\"\n        lane = gcmd.get('LANE', None)\n        if lane is None:\n            self.logger.info(\"No LANE Defined\")\n            return\n        if lane not in self.afc.lanes:\n            self.logger.info('{} Unknown'.format(lane))\n            return\n        cur_lane = self.afc.lanes[lane]\n        density = gcmd.get_float('DENSITY', None)\n\n        cur_lane.material = gcmd.get('MATERIAL')\n        cur_lane.filament_diameter = gcmd.get('DIAMETER', cur_lane.filament_diameter)\n        cur_lane.empty_spool_weight = gcmd.get('EMPTY_SPOOL_WEIGHT', cur_lane.empty_spool_weight)\n\n        # Setting density if its not none, doing this after setting material as material setter\n        # automatically sets density based on material name\n        if density is not None:\n            cur_lane.filament_density = density\n\n        self.afc.save_vars()\n\n    def set_active_spool(self, ID):\n        webhooks = self.printer.lookup_object('webhooks')\n        if self.afc.spoolman is not None:\n            if ID and ID is not None:\n                id = int(ID)\n            else:\n                id = None\n\n            args = {'spool_id' : id }\n            try:\n                webhooks.call_remote_method(\"spoolman_set_active_spool\", **args)\n            except self.printer.command_error as e:\n                self.logger.error(\"Error trying to set active spool \\n{}\".format(e))\n\n    cmd_SET_SPOOL_ID_help = \"Set lanes spoolman ID\"\n    def cmd_SET_SPOOL_ID(self, gcmd):\n        \"\"\"\n        This function handles setting the spool ID for a specified lane. It retrieves the lane\n        specified by the 'LANE' parameter and updates its spool ID, material, color, and weight\n        based on the information retrieved from the Spoolman API.\n\n        Usage\n        -----\n        `SET_SPOOL_ID LANE=<lane> SPOOL_ID=<spool_id>`\n\n        Example\n        -----\n        ```\n        SET_SPOOL_ID LANE=lane1 SPOOL_ID=12345\n        ```\n        \"\"\"\n        if self.afc.spoolman is not None:\n            lane = gcmd.get('LANE', None)\n            if lane is None:\n                self.logger.info(\"No LANE Defined\")\n                return\n            SpoolID = gcmd.get('SPOOL_ID', '')\n            if lane not in self.afc.lanes:\n                self.logger.info('{} Unknown'.format(lane))\n                return\n\n            cur_lane = self.afc.lanes[lane]\n            # Check if spool id is already assigned to a different lane, don't assign to current lane if id\n            # is already assigned\n            if SpoolID != '':\n                SpoolID = int(SpoolID)\n                if cur_lane.spool_id != SpoolID and any( SpoolID == lane.spool_id for lane in self.afc.lanes.values()):\n                    self.logger.error(f\"SpoolId {SpoolID} already assigned to a lane, cannot assign to {lane}.\")\n                    return\n\n            self.set_spoolID(cur_lane, SpoolID)\n\n    def _get_filament_values( self, filament, field, default=None):\n        '''\n        Helper function for checking if field is set and returns value if it exists,\n        otherwise returns None\n\n        :param filament: Dictionary for filament values\n        :param field:    Field name to check for in dictionary\n        :return:         Returns value if field exists or None if field does not exist\n        '''\n        value = default\n        if field in filament:\n            value = filament[field]\n        return value\n\n    def _set_values(self, cur_lane):\n        \"\"\"\n        Helper function for setting lane spool values\n        \"\"\"\n        # set defaults if there's no spool id, or the spoolman lookup fails\n        cur_lane.material = self.afc.default_material_type\n        cur_lane.weight = 1000 # Defaulting weight to 1000 upon load\n\n        if self.afc.spoolman is not None and self.next_spool_id != '':\n            spool_id = self.next_spool_id\n            self.next_spool_id = ''\n            self.set_spoolID(cur_lane, spool_id)\n\n    def _clear_values(self, cur_lane):\n        \"\"\"\n        Helper function for clearing out lane spool values\n        \"\"\"\n        cur_lane.spool_id = ''\n        cur_lane.material = ''\n        cur_lane.color = ''\n        cur_lane.weight = 0\n        cur_lane.extruder_temp = None\n\n    def set_spoolID(self, cur_lane, SpoolID, save_vars=True):\n        if self.afc.spoolman is not None:\n            if SpoolID !='':\n                try:\n                    result = self.afc.moonraker.get_spool(SpoolID)\n                    cur_lane.spool_id = SpoolID\n\n                    cur_lane.material           = self._get_filament_values(result['filament'], 'material')\n                    cur_lane.extruder_temp      = self._get_filament_values(result['filament'], 'settings_extruder_temp')\n                    cur_lane.filament_density   = self._get_filament_values(result['filament'], 'density')\n                    cur_lane.filament_diameter  = self._get_filament_values(result['filament'], 'diameter')\n                    cur_lane.empty_spool_weight = self._get_filament_values(result, 'spool_weight', default=190)\n                    cur_lane.weight             = self._get_filament_values(result, 'remaining_weight')\n                    # Check to see if filament is defined as multi color and take the first color for now\n                    # Once support for multicolor is added this needs to be updated\n                    if \"multi_color_hexes\" in result['filament']:\n                        cur_lane.color = '#{}'.format(self._get_filament_values(result['filament'], 'multi_color_hexes').split(\",\")[0])\n                    else:\n                        cur_lane.color = '#{}'.format(self._get_filament_values(result['filament'], 'color_hex'))\n\n                except Exception as e:\n                    self.afc.error.AFC_error(\"Error when trying to get Spoolman data for ID:{}, Error: {}\".format(SpoolID, e), False)\n            else:\n                self._clear_values(cur_lane)\n        else:\n            # Clears out values if users are not using spoolman, this is to cover this function being called from LANE UNLOAD and clearing out\n            # Manually entered information\n            self._clear_values(cur_lane)\n        if save_vars: self.afc.save_vars()\n\n    cmd_SET_RUNOUT_help = \"Set runout lane\"\n    def cmd_SET_RUNOUT(self, gcmd):\n        \"\"\"\n        This function handles setting the runout lane (infinite spool) for a specified lane. It retrieves the lane\n        specified by the 'LANE' parameter and updates it's the lane to use if filament runs out by un-triggering prep sensor.\n\n        Usage\n        -----\n        `SET_RUNOUT LANE=<lane> RUNOUT=<lane>`\n\n        Example\n        -----\n        ```\n        SET_RUNOUT LANE=lane1 RUNOUT=lane4\n        ```\n        \"\"\"\n        lane = gcmd.get('LANE', None)\n        if lane is None:\n            self.logger.info(\"No LANE Defined\")\n            return\n\n        runout = gcmd.get('RUNOUT', 'NONE')\n        # Check to make sure runout does not equal lane\n        if lane == runout:\n            self.logger.error(\"Lane({}) and runout({}) cannot be the same\".format(lane, runout))\n            return\n        # Check to make sure specified lane exists\n        if lane not in self.afc.lanes:\n            self.logger.error('Unknown lane: {}'.format(lane))\n            return\n        # Check to make sure specified runout lane exists as long as runout is not set as 'NONE'\n        if runout != 'NONE' and runout not in self.afc.lanes:\n            self.logger.error('Unknown runout lane: {}'.format(runout))\n            return\n\n        cur_lane = self.afc.lanes[lane]\n        cur_lane.runout_lane = None if runout == 'NONE' else runout\n        self.afc.save_vars()\n\n    cmd_RESET_AFC_MAPPING_help = \"Resets all lane mapping in AFC\"\n    def cmd_RESET_AFC_MAPPING(self, gcmd):\n        \"\"\"\n        Resets all tool lane mapping to the order set up in the configuration.\n        Optionally resets runout lanes unless RUNOUT=no is specified.\n\n        Useful to put in your PRINT_END macro to reset mapping\n\n        Usage\n        -----\n        `RESET_AFC_MAPPING [RUNOUT=yes|no]`\n\n        Example\n        -----\n        ```\n        RESET_AFC_MAPPING RUNOUT=no\n        ```\n        \"\"\"\n\n        # Gathering existing lane mapping and add to list\n        existing_cmds = [lane.map for lane in self.afc.lanes.values()]\n        # Gather manually assigned mappings and add to list\n        manually_assigned = [ lane._map for lane in self.afc.lanes.values()]\n        # Remove manually assigned mappings from auto assigned mappings\n        existing_cmds = list(set(existing_cmds) - set(manually_assigned))\n        # Sort list in numerical order\n        existing_cmds = sorted(existing_cmds, key=lambda x: int(\"\".join([i for i in x if i.isdigit()])))\n        for key, unit in self.afc.units.items():\n            for lane in unit.lanes.values():\n\t\t\t\t# Reassigning manually assigned mapping to lane\n                if lane._map is not None:\n                    map_cmd = lane._map\n                else:\n                    map_cmd = existing_cmds.pop(0)\n\n                self.afc.tool_cmds[map_cmd] = lane.name\n                self.afc.lanes[lane.name].map = map_cmd\n\n        # Resetting runout lanes to None\n        runout_opt = gcmd.get('RUNOUT', 'yes').lower()\n        if runout_opt != 'no':\n            for lane in self.afc.lanes.values():\n                lane.runout_lane = None\n\n        self.afc.save_vars()\n        self.logger.info(\"Tool mappings reset\" + (\"\" if runout_opt == \"no\" else \" and runout lanes reset\"))\n\n    cmd_SET_NEXT_SPOOL_ID_help = \"Set the spool id to be loaded next into AFC\"\n    def cmd_SET_NEXT_SPOOL_ID(self, gcmd):\n        \"\"\"\n        Sets the spool ID to be loaded next into the AFC.\n\n        This can be used in a scanning macro to prepare the AFC for the next spool to be loaded.\n\n        Omit the SPOOL_ID parameter to clear the next spool ID.\n\n        Usage\n        -----\n        `SET_NEXT_SPOOL_ID SPOOL_ID=<spool_id>`\n\n        Example\n        -----\n        ```\n        SET_NEXT_SPOOL_ID SPOOL_ID=12345\n        ```\n        \"\"\"\n        SpoolID = gcmd.get('SPOOL_ID', '')\n        previous_id = self.next_spool_id\n        if SpoolID != '':\n            try:\n                self.next_spool_id = str(int(SpoolID)) # make sure spool ID will round trip later\n            except ValueError:\n                self.logger.error(\"Invalid spool ID: {}\".format(SpoolID))\n                self.next_spool_id = ''\n        else:\n            self.next_spool_id = ''\n        if previous_id:\n            self.logger.info(f\"Spool ID '{previous_id}' being overwritten for next load: '{self.next_spool_id}'\")\n        else:\n            self.logger.info(f\"Spool ID set for next load: '{self.next_spool_id}'\")\n\ndef load_config(config):\n    return AFCSpool(config)\n",
    'extras.AFC_buffer': "# Armored Turtle Automated Filament Changer\n#\n# Copyright (C) 2024 Armored Turtle\n#\n# This file may be distributed under the terms of the GNU GPLv3 license.\nimport traceback\n\nfrom configparser import Error as error\n\ntry: from extras.AFC_utils import add_filament_switch\nexcept: raise error(\"Error when trying to import AFC_utils.add_filament_switch\\n{trace}\".format(trace=traceback.format_exc()))\n\nADVANCE_STATE_NAME = \"Trailing\"\nTRAILING_STATE_NAME = \"Advancing\"\n\nclass AFCTrigger:\n\n    def __init__(self, config):\n        self.printer    = config.get_printer()\n        self.afc        = self.printer.lookup_object('AFC')\n        self.reactor    = self.afc.reactor\n        self.gcode      = self.afc.gcode\n        self.logger     = self.afc.logger\n\n        self.name       = config.get_name().split(' ')[-1]\n        self.lanes      = {}\n        self.turtleneck = False\n        self.last_state = \"Unknown\"\n        self.enable     = False\n        self.current    = ''\n        self.advance_state = False\n        self.trailing_state = False\n\n        self.debug                  = config.getboolean(\"debug\", False)\n        self.enable_sensors_in_gui  = config.getboolean(\"enable_sensors_in_gui\", self.afc.enable_sensors_in_gui)  # Set to True toolhead sensors switches as filament sensors in mainsail/fluidd gui, overrides value set in AFC.cfg\n        self.buttons                = self.printer.load_object(config, \"buttons\")\n\n        # LED SETTINGS\n        self.led                    = False\n        self.led_index              = config.get('led_index', None)\n        self.led_advancing          = config.get('led_buffer_advancing','0,0,1,0')\n        self.led_trailing           = config.get('led_buffer_trailing','0,1,0,0')\n        self.led_buffer_disabled    = config.get('led_buffer_disable', '0,0,0,0.25')\n\n        if self.led_index is not None:\n            self.led = True\n            self.led_index = config.get('led_index')\n\n        # Try and get one of each pin to see how user has configured buffer\n        self.advance_pin        = config.get('advance_pin', None)\n        self.buffer_distance    = config.getfloat('distance', None)\n\n        # Pull config for Turtleneck style buffer (advance and training switches)\n        self.turtleneck         = True\n        self.advance_pin        = config.get('advance_pin') # Advance pin for buffer\n        self.trailing_pin       = config.get('trailing_pin') # Trailing pin for buffer\n        self.multiplier_high    = config.getfloat(\"multiplier_high\", default=1.1, minval=1.0)\n        self.multiplier_low     = config.getfloat(\"multiplier_low\", default=0.9, minval=0.0, maxval=1.0)\n\n        self.adv_filament_switch_name = \"{}_{}\".format(self.name, \"expanded\")\n        self.fila_avd = add_filament_switch(self.adv_filament_switch_name, self.advance_pin, self.printer, show_sensor=self.enable_sensors_in_gui )\n\n        self.trail_filament_switch_name = \"{}_{}\".format(self.name, \"compressed\")\n        self.fila_trail = add_filament_switch(self.trail_filament_switch_name, self.trailing_pin, self.printer, show_sensor=self.enable_sensors_in_gui )\n\n        self.printer.register_event_handler(\"klippy:ready\", self._handle_ready)\n\n        self.function = self.printer.load_object(config, 'AFC_functions')\n        self.show_macros = self.afc.show_macros\n\n        self.function.register_mux_command(self.show_macros, \"QUERY_BUFFER\", \"BUFFER\", self.name,\n                                            self.cmd_QUERY_BUFFER,\n                                        self.cmd_QUERY_BUFFER_help, self.cmd_QUERY_BUFFER_options)\n        self.gcode.register_mux_command(\"ENABLE_BUFFER\",        \"BUFFER\", self.name, self.cmd_ENABLE_BUFFER)\n        self.gcode.register_mux_command(\"DISABLE_BUFFER\",       \"BUFFER\", self.name, self.cmd_DISABLE_BUFFER)\n\n        # Turtleneck Buffer\n        if self.turtleneck:\n            self.buttons.register_buttons([self.advance_pin], self.advance_callback)\n            self.buttons.register_buttons([self.trailing_pin], self.trailing_callback)\n\n            self.gcode.register_mux_command(\"SET_ROTATION_FACTOR\",      \"BUFFER\", self.name, self.cmd_SET_ROTATION_FACTOR,  desc=self.cmd_LANE_ROT_FACTOR_help)\n            self.gcode.register_mux_command(\"SET_BUFFER_MULTIPLIER\",    \"BUFFER\", self.name, self.cmd_SET_BUFFER_MULTIPLIER,desc=self.cmd_SET_BUFFER_MULTIPLIER_help)\n\n        self.afc.buffers[self.name] = self\n\n    def __str__(self):\n        return self.name\n\n    def _handle_ready(self):\n        self.min_event_systime = self.reactor.monotonic() + 2.\n\n        if self.led_index is not None:\n            # Verify that LED config is found\n            error_string, led = self.afc.function.verify_led_object(self.led_index)\n            if led is None:\n                raise error(error_string)\n\n    def enable_buffer(self):\n        if self.led:\n            self.afc.function.afc_led(self.led_buffer_disabled, self.led_index)\n        if self.turtleneck:\n            self.enable = True\n            multiplier = 1.0\n            if self.last_state == ADVANCE_STATE_NAME:\n                multiplier = self.multiplier_low\n            else:\n                multiplier = self.multiplier_high\n            self.set_multiplier( multiplier )\n            if self.debug: self.logger.info(\"{} buffer enabled\".format(self.name))\n\n    def disable_buffer(self):\n        self.enable = False\n        if self.debug: self.logger.info(\"{} buffer disabled\".format(self.name))\n        if self.led:\n            self.afc.function.afc_led(self.led_buffer_disabled, self.led_index)\n        if self.turtleneck:\n            self.reset_multiplier()\n\n    # Turtleneck commands\n    def set_multiplier(self, multiplier):\n        if not self.enable: return\n        cur_stepper = self.afc.function.get_current_lane_obj()\n        if cur_stepper is None: return\n\n        cur_stepper.update_rotation_distance( multiplier )\n        if multiplier > 1:\n            self.last_state = TRAILING_STATE_NAME\n            if self.led:\n                self.afc.function.afc_led(self.led_trailing, self.led_index)\n        elif multiplier < 1:\n            self.last_state = ADVANCE_STATE_NAME\n            if self.led:\n                self.afc.function.afc_led(self.led_advancing, self.led_index)\n        if self.debug:\n            stepper = cur_stepper.extruder_stepper.stepper\n            self.logger.info(\"New rotation distance after applying factor: {:.4f}\".format(stepper.get_rotation_distance()[0]))\n\n    def reset_multiplier(self):\n        if self.debug: self.logger.info(\"Buffer multiplier reset\")\n\n        cur_stepper = self.afc.function.get_current_lane_obj()\n        if cur_stepper is None: return\n\n        cur_stepper.update_rotation_distance( 1 )\n        self.logger.info(\"Rotation distance reset : {:.4f}\".format(cur_stepper.extruder_stepper.stepper.get_rotation_distance()[0]))\n\n    def advance_callback(self, eventime, state):\n        self.advance_state = state\n        if self.printer.state_message == 'Printer is ready' and self.enable:\n            cur_lane = self.afc.function.get_current_lane_obj()\n\n            if cur_lane is not None and state:\n                self.set_multiplier( self.multiplier_low )\n                if self.debug: self.logger.info(\"Buffer Triggered State: Advanced\")\n        self.last_state = ADVANCE_STATE_NAME\n\n    def trailing_callback(self, eventime, state):\n        self.trailing_state = state\n        if self.printer.state_message == 'Printer is ready' and self.enable:\n            cur_lane = self.afc.function.get_current_lane_obj()\n\n            if cur_lane is not None and state:\n                self.set_multiplier( self.multiplier_high )\n                if self.debug: self.logger.info(\"Buffer Triggered State: Trailing\")\n        self.last_state = TRAILING_STATE_NAME\n\n    def buffer_status(self):\n        state_info = ''\n        if self.turtleneck:\n            state_info = self.last_state\n        else:\n            if self.last_state:\n                state_info += \"compressed\"\n            else:\n                state_info += \"expanded\"\n        return state_info\n\n    cmd_SET_BUFFER_MULTIPLIER_help = \"live adjust buffer high and low multiplier\"\n    def cmd_SET_BUFFER_MULTIPLIER(self, gcmd):\n        \"\"\"\n        This function handles the adjustment of the buffer multipliers for the turtleneck buffer.\n        It retrieves the multiplier type ('HIGH' or 'LOW') and the factor to be applied. The function\n        ensures that the factor is valid and updates the corresponding multiplier.\n\n        Usage\n        -----\n        `SET_BUFFER_MULTIPLIER BUFFER=<buffer_name> MULTIPLIER=<HIGH/LOW> FACTOR=<factor>`\n\n        Example\n        -----\n        ```\n        SET_BUFFER_MULTIPLIER BUFFER=TN MULTIPLIER=HIGH FACTOR=1.2\n        ```\n        \"\"\"\n        if self.turtleneck:\n            cur_stepper = self.afc.function.get_current_lane_obj()\n            if cur_stepper is not None and self.enable:\n                chg_multiplier = gcmd.get('MULTIPLIER', None)\n                if chg_multiplier is None:\n                    self.logger.info(\"Multiplier must be provided, HIGH or LOW\")\n                    return\n                chg_factor = gcmd.get_float('FACTOR')\n                if chg_factor <= 0:\n                    self.logger.info(\"FACTOR must be greater than 0\")\n                    return\n                if chg_multiplier == \"HIGH\" and chg_factor > 1:\n                    self.multiplier_high = chg_factor\n                    self.set_multiplier(chg_factor)\n                    self.logger.info(\"multiplier_high set to {}\".format(chg_factor))\n                    self.logger.info('multiplier_high: {} MUST be updated under buffer config for value to be saved'.format(chg_factor))\n                elif chg_multiplier == \"LOW\" and chg_factor < 1:\n                    self.multiplier_low = chg_factor\n                    self.set_multiplier(chg_factor)\n                    self.logger.info(\"multiplier_low set to {}\".format(chg_factor))\n                    self.logger.info('multiplier_low: {} MUST be updated under buffer config for value to be saved'.format(chg_factor))\n                else:\n                    self.logger.info('multiplier_high must be greater than 1, multiplier_low must be less than 1')\n\n    cmd_LANE_ROT_FACTOR_help = \"change rotation distance by factor specified\"\n    def cmd_SET_ROTATION_FACTOR(self, gcmd):\n        \"\"\"\n        Adjusts the rotation distance of the current AFC stepper motor by applying a\n        specified factor. If no factor is provided, it defaults to 1.0, which resets\n        the rotation distance to the base value.\n\n        Behavior:\n\n        - The `FACTOR` must be greater than 0.\n        - If the buffer is enabled and active, and a valid factor is provided, the function adjusts the rotation\n          distance for the current AFC stepper.\n        - If `FACTOR` is 1.0, the rotation distance is reset to the base value.\n        - If `FACTOR` is a valid non-zero number, the rotation distance is updated by the provided factor.\n        - If `FACTOR` is 0 or AFC is not enabled, an appropriate message is sent back through the G-code interface.\n\n        Usage\n        -----\n        `SET_ROTATION_FACTOR BUFFER=<buffer_name> FACTOR=<factor>`\n\n        Example\n        -----\n        ```\n        SET_ROTATION_FACTOR BUFFER=TN FACTOR=1.2\n        ```\n        \"\"\"\n        if self.turtleneck:\n            cur_stepper = self.afc.function.get_current_lane_obj()\n            if cur_stepper is not None and self.enable:\n                change_factor = gcmd.get_float('FACTOR', 1.0)\n                if change_factor <= 0:\n                    self.logger.info(\"FACTOR must be greater than 0\")\n                    return\n                elif change_factor == 1.0:\n                    self.set_multiplier ( 1 )\n                    self.logger.info(\"Rotation distance reset to base value\")\n                else:\n                    self.set_multiplier( change_factor )\n            else:\n                self.logger.info(\"BUFFER {} NOT ENABLED\".format(self.name))\n        else:\n            self.logger.info(\"BUFFER {} CAN'T CHANGE ROTATION DISTANCE\".format(self.name))\n\n    cmd_QUERY_BUFFER_help = \"Report Buffer sensor state\"\n    cmd_QUERY_BUFFER_options = {\"BUFFER\": {\"type\": \"string\", \"default\": \"Turtle_1\"}}\n    def cmd_QUERY_BUFFER(self, gcmd):\n        \"\"\"\n        Reports the current state of the buffer sensor and, if applicable, the rotation\n        distance of the current AFC stepper motor.\n\n        Behavior\n\n        - If the `turtleneck` feature is enabled and a tool is loaded, the rotation\n          distance of the current AFC stepper motor is reported, along with the\n          current state of the buffer sensor.\n        - If the `turtleneck` feature is not enabled, only the buffer state is reported.\n        - Both the buffer state and, if applicable, the stepper motor's rotation\n          distance are sent back as G-code responses.\n\n        Usage\n        -----\n        `QUERY_BUFFER BUFFER=<buffer_name>`\n\n        Example\n        ------\n        ```\n        QUERY_BUFFER BUFFER=TN\n        ```\n        \"\"\"\n        state_mapping = {\n            TRAILING_STATE_NAME: ' (Compressed)',\n            ADVANCE_STATE_NAME: ' (Expanded)',\n            }\n        state_info = self.buffer_status()\n        state_info += state_mapping.get(state_info, '')\n        if self.turtleneck:\n            if self.enable:\n                lane = self.afc.function.get_current_lane_obj()\n                stepper = lane.extruder_stepper.stepper\n                rotation_dist = stepper.get_rotation_distance()[0]\n                state_info += (\"\\n{} Rotation distance: {:.4f}\".format(lane.name, rotation_dist))\n\n        self.logger.info(\"{} : {}\".format(self.name, state_info))\n\n    def cmd_ENABLE_BUFFER(self, gcmd):\n        \"\"\"\n        Manually enables the buffer. This command is useful for debugging and testing purposes.\n\n        Usage\n        -----\n        `ENABLE_BUFFER`\n        \"\"\"\n        self.enable_buffer()\n\n    def cmd_DISABLE_BUFFER(self, gcmd):\n        \"\"\"\n        Manually disables the buffer. This command is useful for debugging and testing purposes.\n\n        Usage\n        -----\n        `DISABLE_BUFFER`\n        \"\"\"\n        self.disable_buffer()\n\n    def get_status(self, eventtime=None):\n        self.response = {}\n        self.response['state'] = self.last_state\n        self.response['lanes'] = [lane.name for lane in self.lanes.values()]\n        self.response['enabled'] = self.enable\n        return self.response\n\ndef load_config_prefix(config):\n    return AFCTrigger(config)",
    'extras.AFC_extruder': "# Armored Turtle Automated Filament Changer\n#\n# Copyright (C) 2024 Armored Turtle\n#\n# This file may be distributed under the terms of the GNU GPLv3 license.\nimport traceback\n\nfrom configparser import Error as error\n\ntry: from extras.AFC_utils import ERROR_STR\nexcept: raise error(\"Error when trying to import AFC_utils.ERROR_STR\\n{trace}\".format(trace=traceback.format_exc()))\n\ntry: from extras.AFC_utils import add_filament_switch\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_utils\", trace=traceback.format_exc()))\n\nclass AFCExtruder:\n    def __init__(self, config):\n        self.printer    = config.get_printer()\n        buttons         = self.printer.load_object(config, \"buttons\")\n        self.afc        = self.printer.lookup_object('AFC')\n        self.gcode      = self.printer.lookup_object('gcode')\n        self.logger     = self.afc.logger\n        self.reactor    = None\n        self.printer.register_event_handler(\"klippy:connect\", self.handle_connect)\n\n        self.fullname                   = config.get_name()\n        self.name                       = self.fullname.split(' ')[-1]\n        self.tool_start                 = config.get('pin_tool_start', None)                                            # Pin for sensor before(pre) extruder gears\n        self.tool_end                   = config.get('pin_tool_end', None)                                              # Pin for sensor after(post) extruder gears (optional)\n        self.tool_stn                   = config.getfloat(\"tool_stn\", 72)                                               # Distance in mm from the toolhead sensor to the tip of the nozzle in mm, if `tool_end` is defined then distance is from this sensor\n        self.tool_stn_unload            = config.getfloat(\"tool_stn_unload\", 100)                                       # Distance to move in mm while unloading toolhead\n        self.tool_sensor_after_extruder = config.getfloat(\"tool_sensor_after_extruder\", 0)                              # Extra distance to move in mm once the pre- / post-sensors are clear. Useful for when only using post sensor, so this distance can be the amount to move to clear extruder gears\n        self.tool_unload_speed          = config.getfloat(\"tool_unload_speed\", 25)                                      # Unload speed in mm/s when unloading toolhead. Default is 25mm/s.\n        self.tool_load_speed            = config.getfloat(\"tool_load_speed\", 25)                                        # Load speed in mm/s when loading toolhead. Default is 25mm/s.\n        self.buffer_name                = config.get('buffer', None)                                                    # Buffer to use for extruder, this variable can be overridden per lane\n        self.enable_sensors_in_gui      = config.getboolean(\"enable_sensors_in_gui\",    self.afc.enable_sensors_in_gui) # Set to True toolhead sensors switches as filament sensors in mainsail/fluidd gui, overrides value set in AFC.cfg\n        self.enable_runout              = config.getboolean(\"enable_tool_runout\",       self.afc.enable_tool_runout)\n        self.debounce_delay             = config.getfloat(\"debounce_delay\",             self.afc.debounce_delay)\n\n        self.lane_loaded                = None\n        self.lanes                      = {}\n\n        self.tool_start_state = False\n        if self.tool_start is not None:\n            if \"unknown\" == self.tool_start.lower():\n                raise error(f\"Unknown is not valid for pin_tool_start in [{self.fullname}] config.\")\n\n            if self.tool_start == \"buffer\":\n                self.logger.info(\"Setting up as buffer\")\n            else:\n                buttons.register_buttons([self.tool_start], self.tool_start_callback)\n                self.fila_tool_start, self.debounce_button_start = add_filament_switch(\"tool_start\", self.tool_start, self.printer,\n                                                                                        self.enable_sensors_in_gui, self.handle_start_runout, self.enable_runout,\n                                                                                        self.debounce_delay )\n\n        self.tool_end_state = False\n        if self.tool_end is not None:\n            if \"unknown\" == self.tool_end.lower():\n                raise error(f\"Unknown is not valid for pin_tool_end in [{self.fullname}] config.\")\n\n            buttons.register_buttons([self.tool_end], self.tool_end_callback)\n            self.fila_tool_end, self.debounce_button_end = add_filament_switch(\"tool_end\", self.tool_end, self.printer,\n                                                                                self.enable_sensors_in_gui, self.handle_end_runout, self.enable_runout,\n                                                                                self.debounce_delay )\n\n        self.common_save_msg = \"\\nRun SAVE_EXTRUDER_VALUES EXTRUDER={} once done to update values in config\".format(self.name)\n\n        self.show_macros = self.afc.show_macros\n        self.function = self.printer.load_object(config, 'AFC_functions')\n\n        self.function.register_mux_command(self.show_macros, 'UPDATE_TOOLHEAD_SENSORS', \"EXTRUDER\", self.name,\n                                           self.cmd_UPDATE_TOOLHEAD_SENSORS, self.cmd_UPDATE_TOOLHEAD_SENSORS_help,\n                                           self.cmd_UPDATE_TOOLHEAD_SENSORS_options)\n        self.function.register_mux_command(self.show_macros, 'SAVE_EXTRUDER_VALUES', \"EXTRUDER\", self.name,\n                                           self.cmd_SAVE_EXTRUDER_VALUES, self.cmd_SAVE_EXTRUDER_VALUES_help,\n                                           self.cmd_SAVE_EXTRUDER_VALUES_options)\n\n    def __str__(self):\n        return self.name\n\n    def handle_connect(self):\n        \"\"\"\n        Handle the connection event.\n        This function is called when the printer connects. It looks up AFC info\n        and assigns it to the instance variable `self.AFC`.\n        \"\"\"\n        self.reactor = self.afc.reactor\n        self.afc.tools[self.name] = self\n\n    def _handle_toolhead_sensor_runout(self, state, sensor_name):\n        \"\"\"\n        Handles runout detection at the toolhead sensors (tool_start or tool_end).\n        Notifies the currently loaded lane if filament is missing at the toolhead sensor.\n        :param state: Boolean indicating sensor state (True = filament present, False = runout)\n        :param sensor_name: Name of the triggering sensor (\"tool_start\" or \"tool_end\")\n        \"\"\"\n        # Notify the currently loaded lane if filament is missing at toolhead\n        if not state and self.lane_loaded and self.lane_loaded in self.lanes:\n            lane = self.lanes[self.lane_loaded]\n            if hasattr(lane, \"handle_toolhead_runout\"):\n                lane.handle_toolhead_runout(sensor=sensor_name)\n\n    def handle_start_runout( self, eventtime):\n        \"\"\"\n        Callback function for tool start runout, this is different than `tool_start_callback` function as this function\n        can be delayed and is called from filament_switch_sensor class when it detects a runout event.\n\n        Before exiting `min_event_systime` is updated as this mimics how its done in `_exec_gcode` function in RunoutHelper class\n        as AFC overrides `_runout_event_handler` function with this function callback. If `min_event_systime` does not get\n        updated then future switch changes will not be detected.\n\n        :param eventtime: Event time from the button press\n        \"\"\"\n        self._handle_toolhead_sensor_runout(self.fila_tool_start.runout_helper.filament_present, \"tool_start\")\n        self.fila_tool_start.runout_helper.min_event_systime = self.reactor.monotonic() + self.fila_tool_start.runout_helper.event_delay\n\n    def tool_start_callback(self, eventtime, state):\n        \"\"\"\n        Callback for the tool_start (pre-extruder) filament sensor.\n        Updates the sensor state and triggers runout handling if filament is missing.\n        :param eventtime: Event time from the button press\n        :param state: Boolean indicating sensor state (True = filament present, False = runout)\n        \"\"\"\n        self.tool_start_state = state\n\n    def buffer_trailing_callback(self, eventtime, state):\n        self.buffer_trailing = state\n\n    def handle_end_runout( self, eventtime):\n        \"\"\"\n        Callback function for tool end runout, this is different than `tool_end_callback` function as this function\n        can be delayed and is called from filament_switch_sensor class when it detects a runout event.\n\n        Before exiting `min_event_systime` is updated as this mimics how its done in `_exec_gcode` function in RunoutHelper class\n        as AFC overrides `_runout_event_handler` function with this function callback. If `min_event_systime` does not get\n        updated then future switch changes will not be detected.\n\n        :param eventtime: Event time from the button press\n        \"\"\"\n        self._handle_toolhead_sensor_runout(self.fila_tool_end.runout_helper.filament_present, \"tool_end\")\n        self.fila_tool_end.runout_helper.min_event_systime = self.reactor.monotonic() + self.fila_tool_end.runout_helper.event_delay\n\n    def tool_end_callback(self, eventtime, state):\n        \"\"\"\n        Callback for the tool_end (post-extruder) filament sensor.\n        Updates the sensor state and triggers runout handling if filament is missing.\n        :param eventtime: Event time from the button press\n        :param state: Boolean indicating sensor state (True = filament present, False = runout)\n        \"\"\"\n        self.tool_end_state = state\n\n    def _update_tool_stn(self, length):\n        \"\"\"\n        Helper function to set tool_stn length\n\n        :param length: Length to set to tool_stn parameter\n        \"\"\"\n        if length > 0:\n            msg = \"tool_stn updated old: {}, new: {}\".format(self.tool_stn, length)\n            msg += self.common_save_msg\n            self.tool_stn = length\n            self.logger.info(msg)\n        else:\n            self.logger.error(\"tool_stn length should be greater than zero\")\n\n    def _update_tool_stn_unload(self, length):\n        \"\"\"\n        Helper function to set tool_stn_unload length\n\n        :param length: Length to set to tool_stn_unload parameter\n        \"\"\"\n        if length > 0:\n            msg = \"tool_stn_unload updated old: {}, new: {}\".format(self.tool_stn_unload, length)\n            msg += self.common_save_msg\n            self.tool_stn_unload = length\n            self.logger.info(msg)\n        else:\n            self.logger.error(\"tool_stn_unload length should be greater than zero\")\n\n    def _update_tool_after_extr(self, length):\n        \"\"\"\n        Helper function to set tool_sensor_after_extruder length\n\n        :param length: Length to set to tool_sensor_after_extruder parameter\n        \"\"\"\n        if length > 0:\n            msg = \"tool_sensor_after_extruder updated old: {}, new: {}\".format(self.tool_sensor_after_extruder, length)\n            msg += self.common_save_msg\n            self.tool_sensor_after_extruder = length\n            self.logger.info(msg)\n        else:\n            self.logger.error(\"tool_sensor_after_extruder length should be greater than zero\")\n\n    cmd_UPDATE_TOOLHEAD_SENSORS_help = \"Gives ability to update tool_stn, tool_stn_unload, tool_sensor_after_extruder values without restarting klipper\"\n    cmd_UPDATE_TOOLHEAD_SENSORS_options = {\n        \"EXTRUDER\": {\"type\": \"string\", \"default\": \"extruder\"},\n        \"TOOL_STN\": {\"type\": \"float\", \"default\": 0},\n        \"TOOL_STN_UNLOAD\": {\"type\": \"float\", \"default\": 0},\n        \"TOOL_AFTER_EXTRUDER\": {\"type\": \"float\", \"default\": 0}\n    }\n\n    def cmd_UPDATE_TOOLHEAD_SENSORS(self, gcmd):\n        \"\"\"\n        Macro call to adjust `tool_stn` `tool_stn_unload` `tool_sensor_after_extruder` lengths for specified extruder without having to\n        update config file and restart klipper.\n\n        `tool_stn length` is the length from the sensor before extruder gears (tool_start) to nozzle. If sensor after extruder gears(tool_end)\n        is set then the value if from tool_end sensor.\n\n        `tool_stn_unload` length is the length to unload so that filament is not in extruder gears anymore.\n\n        `tool_sensor_after_extruder` length is mainly used for those that have a filament sensor after extruder gears, target this\n        length to retract filament enough so that it's not in the extruder gears anymore.  <nl>\n\n        Please pause print if you need to adjust this value while printing\n\n        Usage\n        -----\n        `UPDATE_TOOLHEAD_SENSORS EXTRUDER=<extruder> TOOL_STN=<length> TOOL_STN_UNLOAD=<length> TOOL_AFTER_EXTRUDER=<length>`\n\n        Example\n        -----\n        ```\n        UPDATE_TOOLHEAD_SENSORS EXTRUDER=extruder TOOL_STN=100\n        ```\n\n        \"\"\"\n        tool_stn                    = gcmd.get_float(\"TOOL_STN\",            self.tool_stn)\n        tool_stn_unload             = gcmd.get_float(\"TOOL_STN_UNLOAD\",     self.tool_stn_unload)\n        tool_sensor_after_extruder  = gcmd.get_float(\"TOOL_AFTER_EXTRUDER\", self.tool_sensor_after_extruder)\n\n        if tool_stn != self.tool_stn:\n            self._update_tool_stn( tool_stn )\n        if tool_stn_unload != self.tool_stn_unload:\n            self._update_tool_stn_unload( tool_stn_unload )\n        if tool_sensor_after_extruder != self.tool_sensor_after_extruder:\n            self._update_tool_after_extr( tool_sensor_after_extruder )\n\n    cmd_SAVE_EXTRUDER_VALUES_help = (\"Saves tool_stn, tool_stn_unload and tool_sensor_after_extruder values to config \"\n                                     \"file.\")\n    cmd_SAVE_EXTRUDER_VALUES_options = {\"EXTRUDER\": {\"type\": \"string\", \"default\": \"extruder\"}}\n    def cmd_SAVE_EXTRUDER_VALUES(self, gcmd):\n        \"\"\"\n        Macro call to write tool_stn, tool_stn_unload and tool_sensor_after_extruder variables to config file for specified extruder.\n\n        Usage\n        -----\n        `SAVE_EXTRUDER_VALUES EXTRUDER=<extruder>`\n\n        Example\n        -----\n        ```\n        SAVE_EXTRUDER_VALUES EXTRUDER=extruder\n        ```\n        \"\"\"\n        self.afc.function.ConfigRewrite(self.fullname, 'tool_stn', self.tool_stn, '')\n        self.afc.function.ConfigRewrite(self.fullname, 'tool_stn_unload', self.tool_stn_unload, '')\n        self.afc.function.ConfigRewrite(self.fullname, 'tool_sensor_after_extruder', self.tool_sensor_after_extruder, '')\n\n    def get_status(self, eventtime=None):\n        self.response = {}\n        self.response['tool_stn'] = self.tool_stn\n        self.response['tool_stn_unload'] = self.tool_stn_unload\n        self.response['tool_sensor_after_extruder'] = self.tool_sensor_after_extruder\n        self.response['tool_unload_speed'] = self.tool_unload_speed\n        self.response['tool_load_speed'] = self.tool_load_speed\n        self.response['buffer'] = self.buffer_name\n        self.response['lane_loaded'] = self.lane_loaded\n        self.response['tool_start'] = self.tool_start\n        self.response['tool_start_status'] = bool(self.tool_start_state)\n        self.response['tool_end'] = self.tool_end\n        self.response['tool_end_status'] = bool(self.tool_end_state)\n        self.response['lanes'] = [lane.name for lane in self.lanes.values()]\n        return self.response\n\ndef load_config_prefix(config):\n    return AFCExtruder(config)\n",
    'extras.AFC_prep': "# Armored Turtle Automated Filament Changer\n#\n# Copyright (C) 2024 Armored Turtle\n#\n# This file may be distributed under the terms of the GNU GPLv3 license.\n\nimport os\nimport json\n\nclass afcPrep:\n    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.printer.register_event_handler(\"klippy:connect\", self.handle_connect)\n        self.delay              = config.getfloat('delay_time', 0.1, minval=0.0)                # Time to delay when moving extruders and spoolers during PREP routine\n        self.enable             = config.getboolean(\"enable\", False)                            # Set True to disable PREP checks\n        self.dis_unload_macro   = config.getboolean(\"disable_unload_filament_remapping\", False) # Set to True to disable remapping UNLOAD_FILAMENT macro to TOOL_UNLOAD macro\n\n        # Flag to set once resume rename as occurred for the first time\n        self.rename_occurred = False\n        # Value gets set to false once prep has been run for the first time after restarting klipper\n        self.assignTcmd = True\n\n    def handle_connect(self):\n        \"\"\"\n        Handle the connection event.\n        This function is called when the printer connects. It looks up AFC info\n        and assigns it to the instance variable `self.AFC`.\n        \"\"\"\n        self.afc = self.printer.lookup_object('AFC')\n        self.afc.gcode.register_command('PREP', self.PREP, desc=None)\n        self.logger = self.afc.logger\n\n    def _rename(self, base_name, rename_name, rename_macro, rename_help):\n        \"\"\"\n        Helper function to get stock macros, rename to something and replace stock macro with AFC functions\n        \"\"\"\n        # Renaming users Resume macro so that RESUME calls AFC_Resume function instead\n        prev_cmd = self.afc.gcode.register_command(base_name, None)\n        if prev_cmd is not None:\n            pdesc = \"Renamed builtin of '%s'\" % (base_name,)\n            self.afc.gcode.register_command(rename_name, prev_cmd, desc=pdesc)\n        else:\n            self.logger.debug(\"{}Existing command {} not found in gcode_macros{}\".format(\"<span class=warning--text>\", base_name, \"</span>\",))\n        self.logger.debug(\"PREP-renaming macro {}\".format(base_name))\n        self.afc.gcode.register_command(base_name, rename_macro, desc=rename_help)\n\n    def _rename_macros(self):\n        \"\"\"\n        Helper function to rename multiple macros and substitute with AFC macros.\n        - Replaces stock RESUME macro and reassigns to AFC_RESUME function\n        - Replaces stock UNLOAD macro and reassigns to TOOL_UNLOAD function. This can be disabled in AFC_prep config\n        - Replaces stock/users PAUSE macro and reassigns to AFC_PAUSE function.\n        \"\"\"\n        # Checking to see if rename has already been done, don't want to rename again if prep was already ran\n        if not self.rename_occurred:\n            self.rename_occurred = True\n            self._rename(self.afc.error.BASE_RESUME_NAME, self.afc.error.AFC_RENAME_RESUME_NAME, self.afc.error.cmd_AFC_RESUME, self.afc.error.cmd_AFC_RESUME_help)\n            self._rename(self.afc.error.BASE_PAUSE_NAME, self.afc.error.AFC_RENAME_PAUSE_NAME, self.afc.error.cmd_AFC_PAUSE, self.afc.error.cmd_AFC_RESUME_help)\n\n            # Check to see if the user does not want to rename UNLOAD_FILAMENT macro\n            if not self.dis_unload_macro:\n                self._rename(self.afc.BASE_UNLOAD_FILAMENT, self.afc.RENAMED_UNLOAD_FILAMENT, self.afc.cmd_TOOL_UNLOAD, self.afc.cmd_TOOL_UNLOAD_help)\n\n    def PREP(self, gcmd):\n        while self.printer.state_message != 'Printer is ready':\n            self.afc.reactor.pause(self.afc.reactor.monotonic() + 1)\n        self._rename_macros()\n        self.afc.print_version(console_only=True)\n\n        # Try and connect to moonraker\n        moonraker_connected = self.afc.handle_moonraker_connect()\n\n        ## load Unit stored variables\n        units={}\n        if os.path.exists('{}.unit'.format(self.afc.VarFile)) and os.stat('{}.unit'.format(self.afc.VarFile)).st_size > 0:\n            try:\n                units=json.load(open('{}.unit'.format(self.afc.VarFile)))\n            except json.JSONDecodeError as e:\n                # Displaying error for user to fix, do not want to continue just in case\n                # there is actual data in this file as we do not want to overwrite and put\n                # users boxturtles into a weird state if prep continues.\n                self.afc.error.AFC_error(f\"Error when trying to open and decode {self.afc.VarFile}.unit file.\\n\" + \\\n                                          \"Please fix file or delete if file is empty, then restart klipper.\", False)\n                self.logger.error(\"\", traceback=f\"{e}\")\n                return\n\n        else:\n            error_string = 'Error: {}.unit file not found. Please check the path in the '.format(self.afc.VarFile)\n            error_string += 'AFC.cfg file and make sure the file and path exists.'\n            self.afc.error.AFC_error(error_string, False)\n\n        # check if Lane is supposed to be loaded in tool head from saved file\n        for extruder in self.afc.tools.keys():\n            PrinterObject=self.afc.tools[extruder]\n            self.afc.tools[PrinterObject.name]=PrinterObject\n            if 'system' in units and \"extruders\" in units[\"system\"]:\n                # Check to see if lane_loaded is in dictionary and its not an empty string\n                if PrinterObject.name in units[\"system\"][\"extruders\"] and \\\n                  'lane_loaded' in units[\"system\"][\"extruders\"][PrinterObject.name] and \\\n                  units[\"system\"][\"extruders\"][PrinterObject.name]['lane_loaded']:\n                    PrinterObject.lane_loaded = units[\"system\"][\"extruders\"][PrinterObject.name]['lane_loaded']\n                    self.afc.current = PrinterObject.lane_loaded\n\n        for lane in self.afc.lanes.keys():\n            cur_lane = self.afc.lanes[lane]\n\n            # If moonraker is connected gather all stats\n            if moonraker_connected:\n                cur_lane.handle_moonraker_connect()\n\n            cur_lane.unit_obj = self.afc.units[cur_lane.unit]\n            if cur_lane.name not in cur_lane.unit_obj.lanes: cur_lane.unit_obj.lanes.append(cur_lane.name)    #add lanes to units list\n            # If units section exists in vars file add currently stored data to AFC.units array\n            if cur_lane.unit in units:\n                if cur_lane.name in units[cur_lane.unit]:\n                    if 'spool_id' in units[cur_lane.unit][cur_lane.name]: cur_lane.spool_id = units[cur_lane.unit][cur_lane.name]['spool_id']\n                    if self.afc.spoolman is not None and cur_lane.spool_id:\n                        self.afc.spool.set_spoolID(cur_lane, cur_lane.spool_id, save_vars=False)\n                    else:\n                        if 'material' in units[cur_lane.unit][cur_lane.name]:\n                            cur_lane.material = units[cur_lane.unit][cur_lane.name]['material']\n                        if 'color' in units[cur_lane.unit][cur_lane.name]:\n                            cur_lane.color = units[cur_lane.unit][cur_lane.name]['color']\n                        if 'weight' in units[cur_lane.unit][cur_lane.name]:\n                            cur_lane.weight = units[cur_lane.unit][cur_lane.name]['weight']\n                        if 'density' in units[cur_lane.unit][cur_lane.name]:\n                            cur_lane.filament_density= units[cur_lane.unit][cur_lane.name][\"density\"]\n                        if 'diameter' in units[cur_lane.unit][cur_lane.name]:\n                            cur_lane.filament_diameter= units[cur_lane.unit][cur_lane.name][\"diameter\"]\n                        if 'empty_spool_weight' in units[cur_lane.unit][cur_lane.name]:\n                            cur_lane.empty_spool_weight= units[cur_lane.unit][cur_lane.name][\"empty_spool_weight\"]\n\n                        if not isinstance(cur_lane.weight, int):\n                            if cur_lane.weight:\n                                cur_lane.weight = int(cur_lane.weight)\n                            else:\n                                cur_lane.weight = 0\n\n                    if 'runout_lane' in units[cur_lane.unit][cur_lane.name]: cur_lane.runout_lane = units[cur_lane.unit][cur_lane.name]['runout_lane']\n                    if cur_lane.runout_lane == '' or cur_lane.runout_lane == 'NONE': cur_lane.runout_lane = None\n                    if 'map' in units[cur_lane.unit][cur_lane.name]: cur_lane.map = units[cur_lane.unit][cur_lane.name]['map']\n                    if cur_lane.map != None:\n                        self.afc.tool_cmds[cur_lane.map] = cur_lane.name\n                    # Check first for hub_loaded as this was the old name in software with version <= 1030\n                    if 'hub_loaded' in units[cur_lane.unit][cur_lane.name]: lane.loaded_to_hub = units[cur_lane.unit][cur_lane.name]['hub_loaded']\n                    # Check for loaded_to_hub as this is how its being saved version > 1030\n                    if 'loaded_to_hub' in units[cur_lane.unit][cur_lane.name]: cur_lane.loaded_to_hub = units[cur_lane.unit][cur_lane.name]['loaded_to_hub']\n                    if 'tool_loaded' in units[cur_lane.unit][cur_lane.name]: cur_lane.tool_loaded = units[cur_lane.unit][cur_lane.name]['tool_loaded']\n                    # Commenting out until there is better handling of this variable as it could cause someone to not be able to load their lane if klipper crashes\n                    # if 'status' in units[cur_lane.unit][cur_lane.name]: cur_lane.status = units[cur_lane.unit][cur_lane.name]['status']\n\n        for unit in self.afc.units.keys():\n            try: cur_unit = self.afc.units[unit]\n            except:\n                error_string = 'Error: {} Unit not found in  config section.'.format(unit)\n                self.afc.error.AFC_error(error_string, False)\n                return\n            self.logger.info('{} {} Prepping lanes'.format(cur_unit.type, unit))\n            lanes_for_first_hub = []\n            hub_name = \"\"\n            LaneCheck = True\n            for lane in cur_unit.lanes.values():\n                # Used to print out warning message that multiple hubs are found\n                if lane.multi_hubs_found:\n                    lanes_for_first_hub.append(lane.name)\n                    hub_name = lane.hub_obj.fullname\n\n                if not cur_unit.system_Test(lane, self.delay, self.assignTcmd, self.enable):\n                    LaneCheck = False\n            # Warn user if multiple hubs were found and hub was not assigned to unit/stepper\n            if len(lanes_for_first_hub) != 0:\n                self.logger.raw(\"<span class=warning--text>No hub defined in lanes or unit for {unit}. Defaulting to {hub}</span>\".format(\n                                            unit=\" \".join(cur_unit.full_name), hub=hub_name))\n\n            if LaneCheck:\n                self.logger.raw(cur_unit.logo)\n            else:\n                self.logger.raw(cur_unit.logo_error)\n        try:\n            if self.afc._get_bypass_state():\n                self.logger.info(\"Filament loaded in bypass, toolchanges deactivated\")\n        except:\n            pass\n\n        # look up what current lane should be a call select lane, this is more for units that\n        # have selectors to make sure the selector is on the correct lane\n        current_lane = self.afc.function.get_current_lane_obj()\n        if current_lane is not None:\n            current_lane.unit_obj.select_lane(current_lane)\n            current_lane.sync_to_extruder()\n\n        # Restore previous bypass state if virtual bypass is active\n        bypass_name = \"Bypass\"\n        if 'virtual' in self.afc.bypass.name:\n            bypass_name = \"Virtual bypass\"\n            if \"system\" in units and 'bypass' in units[\"system\"]:\n                self.afc.bypass.filament_present = self.afc.bypass.sensor_enabled = units[\"system\"][\"bypass\"][\"enabled\"]\n            else:\n                self.afc.bypass.filament_present = self.afc.bypass.sensor_enabled = False\n        # Add warning message so users know that either bypass or virtual bypass is enabled\n        if self.afc.bypass.filament_present:\n            self.logger.raw(f\"<span class=warning--text>{bypass_name} enabled</span>\")\n\n        self.afc.afc_stats.check_cut_threshold()\n\n        # Defaulting to no active spool, putting at end so endpoint has time to register\n        if self.afc.current is None:\n            self.afc.spool.set_active_spool(None)\n        # Setting value to False so the T commands don't try to get reassigned when users manually\n        # run PREP after it has already been run once upon boot\n        self.assignTcmd = False\n        self.afc.prep_done = True\n        self.afc.save_vars()\n\n        if self.afc.buffers:\n            for buffer_name, buffer_obj in self.afc.buffers.items():\n                if buffer_obj.advance_state and buffer_obj.trailing_state:\n                    self.logger.raw(\"<span class=warning--text>Warning: Both advance and trailing \"\n                                    \"switches are triggered on Buffer {}. \"\n                                    \"Please check your buffer switches or configuration.</span>\".format(buffer_name))\n\ndef load_config(config):\n    return afcPrep(config)\n\n",
    'extras.AFC_unit': "# Armored Turtle Automated Filament Control\n#\n# Copyright (C) 2024 Armored Turtle\n#\n# This file may be distributed under the terms of the GNU GPLv3 license.\nimport traceback\n\nfrom configfile import error\n\ntry: from extras.AFC_utils import ERROR_STR\nexcept: raise error(\"Error when trying to import AFC_utils.ERROR_STR\\n{trace}\".format(trace=traceback.format_exc()))\n\ntry: from extras.AFC_respond import AFCprompt\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_respond\", trace=traceback.format_exc()))\n\nclass afcUnit:\n    def __init__(self, config):\n        self.printer        = config.get_printer()\n        self.gcode          = self.printer.lookup_object('gcode')\n        self.printer.register_event_handler(\"klippy:connect\", self.handle_connect)\n        self.afc            = self.printer.lookup_object('AFC')\n        self.logger         = self.afc.logger\n\n        self.lanes      = {}\n\n        # Objects\n        self.buffer_obj     = None\n        self.hub_obj        = None\n        self.extruder_obj   = None\n\n        # Config get section\n        self.full_name                   = config.get_name().split()\n        self.name                        = self.full_name[-1]\n        self.screen_mac                  = config.get('screen_mac', None)\n        self.hub                         = config.get(\"hub\", None)                                           # Hub name(AFC_hub) that belongs to this unit, can be overridden in AFC_stepper section\n        self.extruder                    = config.get(\"extruder\", None)                                      # Extruder name(AFC_extruder) that belongs to this unit, can be overridden in AFC_stepper section\n        self.buffer_name                 = config.get('buffer', None)                                        # Buffer name(AFC_buffer) that belongs to this unit, can be overridden in AFC_stepper section\n        self.led_fault                   = config.get('led_fault', self.afc.led_fault)                       # LED color to set when faults occur in lane        (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in AFC.cfg file\n        self.led_ready                   = config.get('led_ready', self.afc.led_ready)                       # LED color to set when lane is ready               (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in AFC.cfg file\n        self.led_not_ready               = config.get('led_not_ready', self.afc.led_not_ready)               # LED color to set when lane not ready              (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in AFC.cfg file\n        self.led_loading                 = config.get('led_loading', self.afc.led_loading)                   # LED color to set when lane is loading             (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in AFC.cfg file\n        self.led_prep_loaded             = config.get('led_loading', self.afc.led_loading)                   # LED color to set when lane is loaded              (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in AFC.cfg file\n        self.led_unloading               = config.get('led_unloading', self.afc.led_unloading)               # LED color to set when lane is unloading           (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in AFC.cfg file\n        self.led_tool_loaded             = config.get('led_tool_loaded', self.afc.led_tool_loaded)           # LED color to set when lane is loaded into tool    (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in AFC.cfg file\n        self.led_spool_illum             = config.get('led_spool_illuminate', self.afc.led_spool_illum)      # LED color to illuminate under spool\n        self.led_logo_index              = config.get('led_logo_index', None)                                # LED Logo index\n        self.led_logo_color              = self.afc.function.HexConvert(config.get('led_logo_color', '0,0,0,0'))# Default logo color when nothing is loaded\n        self.led_logo_loading            = self.afc.function.HexConvert(config.get('led_logo_loading', self.led_loading ))\n\n        self.long_moves_speed            = config.getfloat(\"long_moves_speed\", self.afc.long_moves_speed)   # Speed in mm/s to move filament when doing long moves. Setting value here overrides values set in AFC.cfg file\n        self.long_moves_accel            = config.getfloat(\"long_moves_accel\", self.afc.long_moves_accel)   # Acceleration in mm/s squared when doing long moves. Setting value here overrides values set in AFC.cfg file\n        self.short_moves_speed           = config.getfloat(\"short_moves_speed\", self.afc.short_moves_speed) # Speed in mm/s to move filament when doing short moves. Setting value here overrides values set in AFC.cfg file\n        self.short_moves_accel           = config.getfloat(\"short_moves_accel\", self.afc.short_moves_accel) # Acceleration in mm/s squared when doing short moves. Setting value here overrides values set in AFC.cfg file\n        self.short_move_dis              = config.getfloat(\"short_move_dis\", self.afc.short_move_dis)       # Move distance in mm for failsafe moves. Setting value here overrides values set in AFC.cfg file\n        self.max_move_dis                = config.getfloat(\"max_move_dis\", self.afc.max_move_dis)            # Maximum distance to move filament. AFC breaks filament moves over this number into multiple moves. Useful to lower this number if running into timer too close errors when doing long filament moves. Setting value here overrides values set in AFC.cfg file\n        self.debug                       = config.getboolean(\"debug\",            False)                      # Turns on/off debug messages to console\n        self.rev_long_moves_speed_factor = config.getfloat(\"rev_long_moves_speed_factor\", self.afc.rev_long_moves_speed_factor)\n\n        # Espooler defines\n        # Time in seconds to wait between breaking n20 motors(nSleep/FWD/RWD all 1) and then releasing the break to allow coasting. Setting value here overrides values set in AFC.cfg file\n        self.n20_break_delay_time   = config.getfloat(\"n20_break_delay_time\",   self.afc.n20_break_delay_time)\n        # Setting to True enables espooler assist while printing\n        self.enable_assist          = config.getboolean(\"enable_assist\",        self.afc.enable_assist)\n        # Weight spool has to be below to activate print assist\n        self.enable_assist_weight   = config.getfloat(\"enable_assist_weight\",   self.afc.enable_assist_weight)\n        # Number of seconds to wait before checking filament movement for espooler assist\n        self.timer_delay            = config.getfloat(\"timer_delay\",            5)\n        # Setting to True enables full speed espoolers for kick_start_time amount\n        self.enable_kick_start      = config.getboolean(\"enable_kick_start\",    True)\n\n        # Time in seconds to enable spooler at full speed to help with getting the spool to spin\n        self.kick_start_time        = config.getfloat(\"kick_start_time\",        0.070)\n        # Cycles per rotation in milliseconds\n        self.cycles_per_rotation    = config.getfloat(\"cycles_per_rotation\",    800)\n        # PWM cycle time\n        self.pwm_value              = config.getfloat(\"pwm_value\",              0.6706)\n        # Delta amount in mm from last move to trigger assist\n        self.delta_movement         = config.getfloat(\"delta_movement\",         150)\n        # Amount to move in mm once filament has moved by delta movement amount\n        self.mm_movement            = config.getfloat(\"mm_movement\",            150)\n        # Scaling factor for the following variables: kick_start_time, spool_outer_diameter, cycles_per_rotation, pwm_value, delta_movement, mm_movement\n        self.scaling                = config.getfloat(\"spoolrate\",              1.0)\n\n        # If True, the unload retract is assisted to prevent loose windings, especially on full spools. This can prevent loops from slipping off the spool. Setting value here overrides values set in AFC.cfg file\n        self.assisted_unload    = config.getboolean(\"assisted_unload\", self.afc.assisted_unload)\n        # When True AFC will unload lane and then pause when runout is triggered and spool to swap to is not set(infinite spool). Setting value here overrides values set in AFC.cfg file\n        self.unload_on_runout   = config.getboolean(\"unload_on_runout\", self.afc.unload_on_runout)\n\n    def __str__(self):\n        return self.name\n\n    def handle_connect(self):\n        \"\"\"\n        Handles klippy:connect event, and does error checking to make sure users have hub/extruder/buffers sections if these variables are defined at the unit level\n        \"\"\"\n        self.afc = self.printer.lookup_object('AFC')\n        self.afc.units[self.name] = self\n\n        # Error checking for hub\n        # TODO: once supported add check if users is not using a hub\n        if self.hub is not None:\n            try:\n                self.hub_obj = self.printer.lookup_object(\"AFC_hub {}\".format(self.hub))\n            except:\n                error_string = 'Error: No config found for hub: {hub} in [AFC_{unit_type} {unit_name}]. Please make sure [AFC_hub {hub}] section exists in your config'.format(\n                hub=self.hub, unit_type=self.type.replace(\"_\", \"\"), unit_name=self.name )\n                raise error(error_string)\n\n        # Error checking for extruder\n        if self.extruder is not None:\n            try:\n                self.extruder_obj = self.printer.lookup_object(\"AFC_extruder {}\".format(self.extruder))\n            except:\n                error_string = 'Error: No config found for extruder: {extruder} in [AFC_{unit_type} {unit_name}]. Please make sure [AFC_extruder {extruder}] section exists in your config'.format(\n                    extruder=self.extruder, unit_type=self.type.replace(\"_\", \"\"), unit_name=self.name )\n                raise error(error_string)\n\n        # Error checking for buffer\n        if self.buffer_name is not None:\n            try:\n                self.buffer_obj = self.printer.lookup_object('AFC_buffer {}'.format(self.buffer_name))\n            except:\n                error_string = 'Error: No config found for buffer: {buffer} in [AFC_{unit_type} {unit_name}]. Please make sure [AFC_buffer {buffer}] section exists in your config'.format(\n                    buffer=self.buffer_name, unit_type=self.type.replace(\"_\", \"\"), unit_name=self.name )\n                raise error(error_string)\n\n        # Send out event so lanes can store units object\n        self.printer.send_event(\"AFC_unit_{}:connect\".format(self.name), self)\n\n        self.gcode.register_mux_command('UNIT_CALIBRATION', \"UNIT\", self.name, self.cmd_UNIT_CALIBRATION, desc=self.cmd_UNIT_CALIBRATION_help)\n        self.gcode.register_mux_command('UNIT_LANE_CALIBRATION', \"UNIT\", self.name, self.cmd_UNIT_LANE_CALIBRATION, desc=self.cmd_UNIT_LANE_CALIBRATION_help)\n        self.gcode.register_mux_command('UNIT_BOW_CALIBRATION', \"UNIT\", self.name, self.cmd_UNIT_BOW_CALIBRATION, desc=self.cmd_UNIT_BOW_CALIBRATION_help)\n\n    def get_status(self, eventtime=None):\n        response = {}\n        response['lanes'] = [lane.name for lane in self.lanes.values()]\n        response[\"extruders\"]=[]\n        response[\"hubs\"] = []\n        response[\"buffers\"] = []\n\n        for lane in self.lanes.values():\n            if lane.hub is not None and lane.hub not in response[\"hubs\"]: response[\"hubs\"].append(lane.hub)\n            if lane.extruder_name is not None and lane.extruder_name not in response[\"extruders\"]: response[\"extruders\"].append(lane.extruder_name)\n            if lane.buffer_name is not None and lane.buffer_name not in response[\"buffers\"]: response[\"buffers\"].append(lane.buffer_name)\n\n        return response\n\n    cmd_UNIT_CALIBRATION_help = 'open prompt to calibrate the dist hub for lanes in selected unit'\n    def cmd_UNIT_CALIBRATION(self, gcmd):\n        \"\"\"\n        Open a prompt to calibrate either the distance between the extruder and the hub or the Bowden length\n        for the selected unit. Provides buttons for lane calibration, Bowden length calibration, and a back option.\n\n        Usage\n        -----\n        `UNIT_CALIBRATION UNIT=<unit>`\n\n        Example\n        -----\n        ```\n        UNIT_CALIBRATION UNIT=Turtle_1\n        ```\n        \"\"\"\n        prompt = AFCprompt(gcmd, self.logger)\n        buttons = []\n        title = '{} Calibration'.format(self.name)\n        text = 'Select to calibrate the distance from extruder to hub or bowden length'\n        # Selection buttons\n        buttons.append((\"Calibrate Lanes\", \"UNIT_LANE_CALIBRATION UNIT={}\".format(self.name), \"primary\"))\n        buttons.append((\"Calibrate afc_bowden_length\", \"UNIT_BOW_CALIBRATION UNIT={}\".format(self.name), \"secondary\"))\n        # Button back to previous step\n        back = [('Back to unit selection', 'AFC_CALIBRATION', 'info')]\n\n        prompt.create_custom_p(title, text, buttons, True, None, back)\n\n    cmd_UNIT_LANE_CALIBRATION_help = 'open prompt to calibrate the length from extruder to hub'\n    def cmd_UNIT_LANE_CALIBRATION(self, gcmd):\n        \"\"\"\n        Open a prompt to calibrate the extruder-to-hub distance for each lane in the selected unit. Creates buttons\n        for each lane, grouped in sets of two, and allows calibration for all lanes or individual lanes.\n\n        Usage\n        -----\n        `UNIT_LANE_CALIBRATION UNIT=<unit>`\n\n        Example\n        -----\n        ```\n        UNIT_LANE_CALIBRATION UNIT=Turtle_1\n        ```\n        \"\"\"\n        prompt = AFCprompt(gcmd, self.logger)\n        buttons = []\n        group_buttons = []\n        title = '{} Lane Calibration'.format(self.name)\n        text  = ('Select a loaded lane from {} to calibrate length from extruder to hub. '\n                 'Config option: dist_hub').format(self.name)\n\n        # Create buttons for each lane and group every 4 lanes together\n        for index, lane in enumerate(self.lanes):\n            cur_lane = self.lanes[lane]\n            if cur_lane.load_state:\n                button_label = \"{}\".format(lane)\n                button_command = \"CALIBRATE_AFC LANE={}\".format(lane)\n                button_style = \"primary\" if index % 2 == 0 else \"secondary\"\n                group_buttons.append((button_label, button_command, button_style))\n\n                # Add group to buttons list after every 4 lanes\n                if (index + 1) % 2 == 0 or index == len(self.lanes) - 1:\n                    buttons.append(list(group_buttons))\n                    group_buttons = []\n\n        if group_buttons:\n            buttons.append(list(group_buttons))\n\n        total_buttons = sum(len(group) for group in buttons)\n        if total_buttons > 1:\n            all_lanes = [('All lanes', 'CALIBRATE_AFC LANE=all UNIT={}'.format(self.name), 'default')]\n        else:\n            all_lanes = None\n        if total_buttons == 0:\n            text = 'No lanes are loaded, please load before calibration'\n\n        # 'Back' button\n        back = [('Back', 'UNIT_CALIBRATION UNIT={}'.format(self.name), 'info')]\n\n        prompt.create_custom_p(title, text, all_lanes,\n                               True, buttons, back)\n\n    cmd_UNIT_BOW_CALIBRATION_help = 'open prompt to calibrate the afc_bowden_length from a lane in the unit'\n    def cmd_UNIT_BOW_CALIBRATION(self, gcmd):\n        \"\"\"\n        Open a prompt to calibrate the Bowden length for a specific lane in the selected unit. Provides buttons\n        for each lane, with a note to only calibrate one lane per unit.\n\n        Usage\n        -----\n        `UNIT_CALIBRATION UNIT=<unit>`\n\n        Example\n        -----\n        ```\n        UNIT_CALIBRATION UNIT=Turtle_1\n        ```\n        \"\"\"\n        prompt = AFCprompt(gcmd, self.logger)\n        buttons = []\n        group_buttons = []\n        title = 'Bowden Calibration {}'.format(self.name)\n        text = ('Select a loaded lane from {} to measure Bowden length. '\n                'ONLY CALIBRATE BOWDEN USING 1 LANE PER UNIT. '\n                'Config option: afc_bowden_length').format(self.name)\n\n        for index, lane in enumerate(self.lanes):\n            cur_lane = self.lanes[lane]\n            if cur_lane.load_state:\n                # Create a button for each lane\n                button_label = \"{}\".format(lane)\n                button_command = \"CALIBRATE_AFC BOWDEN={}\".format(lane)\n                button_style = \"primary\" if index % 2 == 0 else \"secondary\"\n                group_buttons.append((button_label, button_command, button_style))\n\n                # Add group to buttons list after every 4 lanes\n                if (index + 1) % 2 == 0 or index == len(self.lanes) - 1:\n                    buttons.append(list(group_buttons))\n                    group_buttons = []\n\n        if group_buttons:\n            buttons.append(list(group_buttons))\n\n        total_buttons = sum(len(group) for group in buttons)\n        if total_buttons == 0:\n            text = 'No lanes are loaded, please load before calibration'\n\n        back = [('Back', 'UNIT_CALIBRATION UNIT={}'.format(self.name), 'info')]\n\n        prompt.create_custom_p(title, text, None,\n                               True, buttons, back)\n\n    def set_logo_color(self, color):\n        \"\"\"\n        Common function for setting a units logo led's\n\n        :param color: Color to set logo led's, can be hex value or comma seperated list\n        \"\"\"\n        if color is not None and color:\n            led_color = self.afc.function.HexToLedString(color.replace(\"#\", \"\"))\n            self.afc.function.afc_led( led_color, self.led_logo_index )\n\n    def lane_loaded(self, lane):\n        \"\"\"\n        Common function for setting a lanes led when lane is loaded\n\n        :param lane: Lane object to set led\n        \"\"\"\n        self.afc.function.afc_led(lane.led_ready, lane.led_index)\n\n    def lane_unloaded(self, lane):\n        \"\"\"\n        Common function for setting a lanes led when lane is unloaded\n\n        :param lane: Lane object to set led\n        \"\"\"\n        self.afc.function.afc_led(lane.led_not_ready, lane.led_index)\n\n    def lane_loading(self, lane):\n        \"\"\"\n        Common function for setting a lanes led when lane is loading\n\n        :param lane: Lane object to set led\n        \"\"\"\n        self.afc.function.afc_led(lane.led_loading, lane.led_index)\n\n    def lane_tool_loaded(self, lane):\n        \"\"\"\n        Common function for setting a lanes led when lane is tool loaded\n\n        :param lane: Lane object to set led\n        \"\"\"\n        self.afc.function.afc_led(lane.led_tool_loaded, lane.led_index)\n\n    def lane_tool_unloaded(self, lane):\n        \"\"\"\n        Common function for setting a lanes led when lane is tool unloaded\n\n        :param lane: Lane object to set led\n        \"\"\"\n        self.afc.function.afc_led(lane.led_ready, lane.led_index)\n        return\n\n    def select_lane( self, lane ):\n        \"\"\"\n        Function to select lane\n        \"\"\"\n        return\n\n    def return_to_home(self ):\n        \"\"\"\n        Function to home unit if unit has homing sensor\n        \"\"\"\n        return\n\n    def check_runout(self):\n        \"\"\"\n        Function to check if runout logic should be triggered, override in specific unit\n        \"\"\"\n        return False\n\n    # Functions are below are placeholders so the function exists for all units, override these function in your unit files\n    def _print_function_not_defined(self, name):\n        self.afc.gcode(\"{} function not defined for {}\".format(name, self.name))\n\n    # Function that other units can create so that they are specific to the unit\n    def system_Test(self, cur_lane, delay, assignTcmd, enable_movement):\n        self._print_function_not_defined(self.system_test.__name__)\n\n    def calibrate_bowden(self, cur_lane, dis, tol):\n        self._print_function_not_defined(self.calibrate_bowden.__name__)\n\n    def calibrate_hub(self, cur_lane, tol):\n        self._print_function_not_defined(self.calibrate_hub.__name__)\n\n    def move_until_state(self, cur_lane, state, move_dis, tolerance, short_move, pos=0):\n        self._print_function_not_defined(self.move_until_state.__name__)\n\n    def calc_position(self, cur_lane, state, pos, short_move, tolerance):\n        self._print_function_not_defined(self.calc_position.__name__)\n\n    def calibrate_lane(self, cur_lane, tol):\n        self._print_function_not_defined(self.calibrate_lane.__name__)\n",
    'extras.AFC_lane': "# Armored Turtle Automated Filament Changer\n#\n# Copyright (C) 2024 Armored Turtle\n#\n# This file may be distributed under the terms of the GNU GPLv3 license.\n\nimport math\nimport traceback\n\nfrom contextlib import contextmanager\nfrom configfile import error\nfrom enum import Enum\n\ntry: from extras.AFC_utils import ERROR_STR, add_filament_switch\nexcept: raise error(\"Error when trying to import AFC_utils.ERROR_STR, add_filament_switch\\n{trace}\".format(trace=traceback.format_exc()))\n\ntry: from extras import AFC_assist\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_assist\", trace=traceback.format_exc()))\n\ntry: from extras.AFC_stats import AFCStats_var\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_stats\", trace=traceback.format_exc()))\n\n# Class for holding different states so its clear what all valid states are\n\nclass AssistActive(Enum):\n    YES = 1\n    NO = 2\n    DYNAMIC = 3\nclass SpeedMode(Enum):\n    LONG = 1\n    SHORT = 2\n    HUB = 3\n    NIGHT = 4\n\nclass AFCLaneState:\n    NONE             = \"None\"\n    ERROR            = \"Error\"\n    LOADED           = \"Loaded\"\n    TOOLED           = \"Tooled\"\n    TOOL_LOADED      = \"Tool Loaded\"\n    TOOL_LOADING     = \"Tool Loading\"\n    TOOL_UNLOADING   = \"Tool Unloading\"\n    HUB_LOADING      = \"HUB Loading\"\n    EJECTING         = \"Ejecting\"\n    CALIBRATING      = \"Calibrating\"\n\nclass AFCLane:\n    UPDATE_WEIGHT_DELAY = 10.0\n    def __init__(self, config):\n        self.printer            = config.get_printer()\n        self.afc                = self.printer.lookup_object('AFC')\n        self.gcode              = self.printer.lookup_object('gcode')\n        self.reactor            = self.printer.get_reactor()\n        self.extruder_stepper   = None\n        self.logger             = self.afc.logger\n        self.printer.register_event_handler(\"klippy:ready\", self._handle_ready)\n        self.cb_update_weight   = self.reactor.register_timer( self.update_weight_callback )\n\n        self.unit_obj           = None\n        self.hub_obj            = None\n        self.buffer_obj         = None\n        self.extruder_obj       = None\n\n        #stored status variables\n        self.fullname           = config.get_name()\n        self.name               = self.fullname.split()[-1]\n        self.tool_loaded        = False\n        self.loaded_to_hub      = False\n        self.spool_id           = None\n        self.color              = None\n        self.weight             = 0\n        self._material          = None\n        self.extruder_temp      = None\n        self.runout_lane        = None\n        self.status             = AFCLaneState.NONE\n        self.multi_hubs_found   = False\n        self.drive_stepper      = None\n        unit                    = config.get('unit')                                    # Unit name(AFC_BoxTurtle/NightOwl/etc) that belongs to this stepper.\n        # Overrides buffers set at the unit level\n        self.hub                = config.get('hub',None)                                # Hub name(AFC_hub) that belongs to this stepper, overrides hub that is set in unit(AFC_BoxTurtle/NightOwl/etc) section.\n        # Overrides buffers set at the unit and extruder level\n        self.buffer_name        = config.get(\"buffer\", None)                            # Buffer name(AFC_buffer) that belongs to this stepper, overrides buffer that is set in extruder(AFC_extruder) or unit(AFC_BoxTurtle/NightOwl/etc) sections.\n        self.unit               = unit.split(':')[0]\n        try:\n            self.index              = int(unit.split(':')[1])\n        except:\n            self.index              = 0\n            pass\n\n        self.extruder_name      = config.get('extruder', None)                          # Extruder name(AFC_extruder) that belongs to this stepper, overrides extruder that is set in unit(AFC_BoxTurtle/NightOwl/etc) section.\n        self.map                = config.get('cmd', None)                               # Keeping this in so it does not break others config that may have used this, use map instead\n        # Saving to self._map so that if a user has it defined it will be reset back to this when\n        # the calling RESET_AFC_MAPPING macro.\n        self._map = self.map    = config.get('map', self.map)\n        self.led_index          = config.get('led_index', None)                         # LED index of lane in chain of lane LEDs\n        self.led_fault          = config.get('led_fault',None)                          # LED color to set when faults occur in lane        (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n        self.led_ready          = config.get('led_ready',None)                          # LED color to set when lane is ready               (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n        self.led_not_ready      = config.get('led_not_ready',None)                      # LED color to set when lane not ready              (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n        self.led_loading        = config.get('led_loading',None)                        # LED color to set when lane is loading             (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n        self.led_prep_loaded    = config.get('led_loading',None)                        # LED color to set when lane is loaded              (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n        self.led_unloading      = config.get('led_unloading',None)                      # LED color to set when lane is unloading           (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n        self.led_tool_loaded    = config.get('led_tool_loaded',None)                    # LED color to set when lane is loaded into tool    (R,G,B,W) 0 = off, 1 = full brightness. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n        self.led_spool_index    = config.get('led_spool_index', None)                   # LED index to illuminate under spool\n        self.led_spool_illum    = config.get('led_spool_illuminate', None)              # LED color to illuminate under spool\n\n        self.long_moves_speed   = config.getfloat(\"long_moves_speed\", None)             # Speed in mm/s to move filament when doing long moves. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n        self.long_moves_accel   = config.getfloat(\"long_moves_accel\", None)             # Acceleration in mm/s squared when doing long moves. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n        self.short_moves_speed  = config.getfloat(\"short_moves_speed\", None)            # Speed in mm/s to move filament when doing short moves. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n        self.short_moves_accel  = config.getfloat(\"short_moves_accel\", None)            # Acceleration in mm/s squared when doing short moves. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n        self.short_move_dis     = config.getfloat(\"short_move_dis\", None)               # Move distance in mm for failsafe moves. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n        self.max_move_dis       = config.getfloat(\"max_move_dis\", None)                 # Maximum distance to move filament. AFC breaks filament moves over this number into multiple moves. Useful to lower this number if running into timer too close errors when doing long filament moves. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n        self.n20_break_delay_time= config.getfloat(\"n20_break_delay_time\", None)        # Time to wait between breaking n20 motors(nSleep/FWD/RWD all 1) and then releasing the break to allow coasting. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n\n        self.rev_long_moves_speed_factor = config.getfloat(\"rev_long_moves_speed_factor\", None)     # scalar speed factor when reversing filamentalist\n\n        self.dist_hub           = config.getfloat('dist_hub', 60)                       # Bowden distance between Box Turtle extruder and hub\n        self.park_dist          = config.getfloat('park_dist', 10)                      # Currently unused\n\n        self.load_to_hub        = config.getboolean(\"load_to_hub\", self.afc.load_to_hub) # Fast loads filament to hub when inserted, set to False to disable. Setting here overrides global setting in AFC.cfg\n        self.enable_sensors_in_gui  = config.getboolean(\"enable_sensors_in_gui\",    self.afc.enable_sensors_in_gui) # Set to True to show prep and load sensors switches as filament sensors in mainsail/fluidd gui, overrides value set in AFC.cfg\n        self.debounce_delay         = config.getfloat(\"debounce_delay\",             self.afc.debounce_delay)\n        self.enable_runout          = config.getboolean(\"enable_hub_runout\",        self.afc.enable_hub_runout)\n        self.sensor_to_show         = config.get(\"sensor_to_show\", None)                # Set to prep to only show prep sensor, set to load to only show load sensor. Do not add if you want both prep and load sensors to show in web gui\n\n        self.assisted_unload = config.getboolean(\"assisted_unload\", None) # If True, the unload retract is assisted to prevent loose windings, especially on full spools. This can prevent loops from slipping off the spool. Setting value here overrides values set in unit(AFC_BoxTurtle/NightOwl/etc) section\n\n        self.printer.register_event_handler(\"AFC_unit_{}:connect\".format(self.unit),self.handle_unit_connect)\n\n        self.config_dist_hub = self.dist_hub\n\n        # lane triggers\n        buttons = self.printer.load_object(config, \"buttons\")\n        self.prep = config.get('prep', None)                                    # MCU pin for prep trigger\n        self.prep_state = False\n        if self.prep is not None:\n            buttons.register_buttons([self.prep], self.prep_callback)\n\n        self.load = config.get('load', None)                                    # MCU pin load trigger\n        self.load_state = False\n        if self.load is not None:\n            buttons.register_buttons([self.load], self.load_callback)\n        else: self.load_state = True\n\n        self.espooler = AFC_assist.Espooler(self.name, config)\n        self.lane_load_count = None\n\n        self.filament_diameter  = config.getfloat(\"filament_diameter\", 1.75)    # Diameter of filament being used\n        self.filament_density   = config.getfloat(\"filament_density\", 1.24)     # Density of filament being used\n        self.inner_diameter     = config.getfloat(\"spool_inner_diameter\", 100)  # Inner diameter in mm\n        self.outer_diameter     = config.getfloat(\"spool_outer_diameter\", 200)  # Outer diameter in mm\n        self.empty_spool_weight = config.getfloat(\"empty_spool_weight\", 190)    # Empty spool weight in g\n        self.max_motor_rpm      = config.getfloat(\"assist_max_motor_rpm\", 500)  # Max motor RPM\n        self.rwd_speed_multi    = config.getfloat(\"rwd_speed_multiplier\", 0.5)  # Multiplier to apply to rpm\n        self.fwd_speed_multi    = config.getfloat(\"fwd_speed_multiplier\", 0.5)  # Multiplier to apply to rpm\n        self.diameter_range     = self.outer_diameter - self.inner_diameter     # Range for effective diameter\n        self.past_extruder_position = -1\n        self.save_counter       = -1\n\n        # Defaulting to false so that extruder motors to not move until PREP has been called\n        self._afc_prep_done = False\n\n        if self.prep is not None:\n            show_sensor = True\n            if not self.enable_sensors_in_gui or (self.sensor_to_show is not None and 'prep' not in self.sensor_to_show):\n                show_sensor = False\n            self.fila_prep, self.prep_debounce_button = add_filament_switch(f\"{self.name}_prep\", self.prep, self.printer,\n                                                                            show_sensor, enable_runout=self.enable_runout,\n                                                                            debounce_delay=self.debounce_delay )\n            self.prep_debounce_button.button_action = self.handle_prep_runout\n            self.prep_debounce_button.debounce_delay = 0 # Delay will be set once klipper is ready\n\n        if self.load is not None:\n            show_sensor = True\n            if not self.enable_sensors_in_gui or (self.sensor_to_show is not None and 'load' not in self.sensor_to_show):\n                show_sensor = False\n            self.fila_load, self.load_debounce_button = add_filament_switch(f\"{self.name}_load\", self.load, self.printer,\n                                                                            show_sensor, enable_runout=self.enable_runout,\n                                                                            debounce_delay=self.debounce_delay )\n            self.load_debounce_button.button_action = self.handle_load_runout\n            self.load_debounce_button.debounce_delay = 0 # Delay will be set once klipper is ready\n\n        self.connect_done = False\n        self.prep_active = False\n        self.last_prep_time = 0\n\n        self.show_macros = self.afc.show_macros\n        self.function = self.printer.load_object(config, 'AFC_functions')\n        self.function.register_mux_command(self.show_macros, 'SET_LANE_LOADED', 'LANE', self.name,\n                                           self.cmd_SET_LANE_LOADED, self.cmd_SET_LANE_LOADED_help,\n                                           self.cmd_SET_LANE_LOAD_options )\n\n    def __str__(self):\n        return self.name\n\n    @property\n    def material(self):\n        \"\"\"\n        Returns lanes filament material type\n        \"\"\"\n        return self._material\n\n    @material.setter\n    def material(self, value):\n        \"\"\"\n        Sets filament material type and sets filament density based off material type.\n        To use custom density, set density after setting material\n        \"\"\"\n        self._material = value\n        if not value:\n            self.filament_density = 1.24 # Setting to a default value\n            return\n\n        for density in self.afc.common_density_values:\n            v = density.split(\":\")\n            if v[0] in value:\n                self.filament_density = float(v[1])\n                break\n\n    def _handle_ready(self):\n        \"\"\"\n        Handles klippy:ready callback and verifies that steppers have units defined in their config\n        \"\"\"\n        if self.unit_obj is None:\n            raise error(\"Unit {unit} is not defined in your configuration file. Please defined unit ex. [AFC_BoxTurtle {unit}]\".format(unit=self.unit))\n\n        if self.led_index is not None:\n            # Verify that LED config is found\n            error_string, led = self.afc.function.verify_led_object(self.led_index)\n            if led is None:\n                raise error(error_string)\n        self.espooler.handle_ready()\n\n        # Setting debounce delay after ready so that callback does not get triggered when initially loading\n        if hasattr(self, \"prep_debounce_button\"):\n            self.prep_debounce_button.debounce_delay = self.debounce_delay\n        if hasattr(self, \"load_debounce_button\"):\n            self.load_debounce_button.debounce_delay = self.debounce_delay\n\n    def handle_moonraker_connect(self):\n        \"\"\"\n        Function that should be called at the beginning of PREP so that moonraker has\n        enough time to start before AFC tries to connect. This fixes a race condition that can\n        happen between klipper and moonraker when first starting up.\n        \"\"\"\n        if self.unit_obj.type != \"HTLF\" or (self.unit_obj.type == \"HTLF\" and \"AFC_lane\" in self.fullname):\n            values = None\n            if self.afc.moonraker.afc_stats is not None:\n                values = self.afc.moonraker.afc_stats[\"value\"]\n            self.lane_load_count = AFCStats_var(self.name, \"load_count\", values, self.afc.moonraker)\n            self.espooler.handle_moonraker_connect()\n\n    def handle_unit_connect(self, unit_obj):\n        \"\"\"\n        Callback from <unit_name>:connect to verify units/hub/buffer/extruder object. Errors out if user specified names and they do not exist in their configuration\n        \"\"\"\n        # Saving reference to unit\n        self.unit_obj = unit_obj\n        self.buffer_obj = self.unit_obj.buffer_obj\n        add_to_other_obj = False\n\n        # Register all lanes if their type is not HTLF or only register lanes that are HTLF and have AFC_lane\n        # in the name so that HTLF stepper names do not get added since they are not a lane for this unit type\n        if self.unit_obj.type != \"HTLF\" or (self.unit_obj.type == \"HTLF\" and \"AFC_lane\" in self.fullname):\n            add_to_other_obj = True\n            # Registering lane name in unit\n            self.unit_obj.lanes[self.name] = self\n            self.afc.lanes[self.name] = self\n\n\n        self.hub_obj = self.unit_obj.hub_obj\n\n        if self.hub != 'direct':\n            if self.hub is not None:\n                try:\n                    self.hub_obj = self.printer.lookup_object(\"AFC_hub {}\".format(self.hub))\n                except:\n                    error_string = 'Error: No config found for hub: {hub} in [AFC_stepper {stepper}]. Please make sure [AFC_hub {hub}] section exists in your config'.format(\n                    hub=self.hub, stepper=self.name )\n                    raise error(error_string)\n            elif self.hub_obj is None:\n                # Check to make sure at least 1 hub exists in config, if not error out with message\n                if len(self.afc.hubs) == 0:\n                    error_string = \"Error: AFC_hub not found in configuration please make sure there is a [AFC_hub <hub_name>] defined in your configuration\"\n                    raise error(error_string)\n                # Setting hub to first hub in AFC hubs dictionary\n                if len(self.afc.hubs) > 0:\n                    self.hub_obj = next(iter(self.afc.hubs.values()))\n                # Set flag to warn during prep that multiple hubs were found\n                if len(self.afc.hubs) > 1:\n                    self.multi_hubs_found = True\n\n            # Assigning hub name just in case stepper is using hub defined in units config\n            self.hub = self.hub_obj.name\n            if add_to_other_obj:\n                self.hub_obj.lanes[self.name] = self\n        else:\n            self.hub_obj = lambda: None\n            self.hub_obj.state = False\n\n        self.extruder_obj = self.unit_obj.extruder_obj\n        if self.extruder_name is not None:\n            try:\n                self.extruder_obj = self.printer.lookup_object('AFC_extruder {}'.format(self.extruder_name))\n            except:\n                error_string = 'Error: No config found for extruder: {extruder} in [AFC_stepper {stepper}]. Please make sure [AFC_extruder {extruder}] section exists in your config'.format(\n                    extruder=self.extruder_name, stepper=self.name )\n                raise error(error_string)\n        elif self.extruder_obj is None:\n            error_string = \"Error: Extruder has not been configured for stepper {name}, please add extruder variable to either [AFC_stepper {name}] or [AFC_{unit_type} {unit_name}] in your config file\".format(\n                        name=self.name, unit_type=self.unit_obj.type.replace(\"_\", \"\"), unit_name=self.unit_obj.name)\n            raise error(error_string)\n\n        # Assigning extruder name just in case stepper is using extruder defined in units config\n        self.extruder_name = self.extruder_obj.name\n        if add_to_other_obj:\n            self.extruder_obj.lanes[self.name] = self\n\n        # Use buffer defined in stepper and override buffers that maybe set at the UNIT or extruder levels\n        self.buffer_obj = self.unit_obj.buffer_obj\n        if self.buffer_name is not None:\n            try:\n                self.buffer_obj = self.printer.lookup_object(\"AFC_buffer {}\".format(self.buffer_name))\n            except:\n                error_string = 'Error: No config found for buffer: {buffer} in [AFC_stepper {stepper}]. Please make sure [AFC_buffer {buffer}] section exists in your config'.format(\n                    buffer=self.buffer_name, stepper=self.name )\n                raise error(error_string)\n\n        # Checking if buffer was defined in extruder if not defined in unit/stepper\n        elif self.buffer_obj is None and self.extruder_obj.tool_start == \"buffer\":\n            if self.extruder_obj.buffer_name is not None:\n                self.buffer_obj = self.printer.lookup_object(\"AFC_buffer {}\".format(self.extruder_obj.buffer_name))\n            else:\n                error_string = 'Error: Buffer was defined as tool_start in [AFC_extruder {extruder}] config, but buffer variable has not been configured. Please add buffer variable to either [AFC_extruder {extruder}], [AFC_stepper {name}] or [AFC_{unit_type} {unit_name}] section in your config file'.format(\n                    extruder=self.extruder_obj.name, name=self.name, unit_type=self.unit_obj.type.replace(\"_\", \"\"), unit_name=self.unit_obj.name )\n                raise error(error_string)\n\n        # Valid to not have a buffer defined, check to make sure object exists before adding lane to buffer\n        if self.buffer_obj is not None and add_to_other_obj:\n            self.buffer_obj.lanes[self.name] = self\n            # Assigning buffer name just in case stepper is using buffer defined in units/extruder config\n            self.buffer_name = self.buffer_obj.name\n\n        self.get_steppers()\n\n        if self.led_fault           is None: self.led_fault         = self.unit_obj.led_fault\n        if self.led_ready           is None: self.led_ready         = self.unit_obj.led_ready\n        if self.led_not_ready       is None: self.led_not_ready     = self.unit_obj.led_not_ready\n        if self.led_loading         is None: self.led_loading       = self.unit_obj.led_loading\n        if self.led_prep_loaded     is None: self.led_prep_loaded   = self.unit_obj.led_prep_loaded\n        if self.led_unloading       is None: self.led_unloading     = self.unit_obj.led_unloading\n        if self.led_tool_loaded     is None: self.led_tool_loaded   = self.unit_obj.led_tool_loaded\n        if self.led_spool_illum     is None: self.led_spool_illum   = self.unit_obj.led_spool_illum\n\n        if self.rev_long_moves_speed_factor is None: self.rev_long_moves_speed_factor  = self.unit_obj.rev_long_moves_speed_factor\n        if self.long_moves_speed            is None: self.long_moves_speed  = self.unit_obj.long_moves_speed\n        if self.long_moves_accel            is None: self.long_moves_accel  = self.unit_obj.long_moves_accel\n        if self.short_moves_speed           is None: self.short_moves_speed = self.unit_obj.short_moves_speed\n        if self.short_moves_accel           is None: self.short_moves_accel = self.unit_obj.short_moves_accel\n        if self.short_move_dis              is None: self.short_move_dis    = self.unit_obj.short_move_dis\n        if self.max_move_dis                is None: self.max_move_dis      = self.unit_obj.max_move_dis\n\n        if self.rev_long_moves_speed_factor < 0.5: self.rev_long_moves_speed_factor = 0.5\n        if self.rev_long_moves_speed_factor > 1.2: self.rev_long_moves_speed_factor = 1.2\n\n        self.espooler.handle_connect(self)\n\n        # Set hub loading speed depending on distance between extruder and hub\n        self.dist_hub_move_speed = self.long_moves_speed if self.dist_hub >= 200 else self.short_moves_speed\n        self.dist_hub_move_accel = self.long_moves_accel if self.dist_hub >= 200 else self.short_moves_accel\n\n        # Register macros\n        # TODO: add check so that HTLF stepper lanes do not get registered here\n        self.afc.gcode.register_mux_command('SET_LONG_MOVE_SPEED',   \"LANE\", self.name, self.cmd_SET_LONG_MOVE_SPEED, desc=self.cmd_SET_LONG_MOVE_SPEED_help)\n        self.afc.gcode.register_mux_command('SET_SPEED_MULTIPLIER',  \"LANE\", self.name, self.cmd_SET_SPEED_MULTIPLIER, desc=self.cmd_SET_SPEED_MULTIPLIER_help)\n        self.afc.gcode.register_mux_command('SAVE_SPEED_MULTIPLIER', \"LANE\", self.name, self.cmd_SAVE_SPEED_MULTIPLIER, desc=self.cmd_SAVE_SPEED_MULTIPLIER_help)\n        self.afc.gcode.register_mux_command('SET_HUB_DIST',          \"LANE\", self.name, self.cmd_SET_HUB_DIST, desc=self.cmd_SET_HUB_DIST_help)\n        self.afc.gcode.register_mux_command('SAVE_HUB_DIST',         \"LANE\", self.name, self.cmd_SAVE_HUB_DIST, desc=self.cmd_SAVE_HUB_DIST_help)\n\n        if self.assisted_unload is None: self.assisted_unload = self.unit_obj.assisted_unload\n\n        # Send out event so that macros and be registered properly with valid lane names\n        self.printer.send_event(\"afc_stepper:register_macros\", self)\n\n        self.connect_done = True\n\n    def get_steppers(self):\n        \"\"\"\n        Helper function to get steppers for lane\n        \"\"\"\n        if self.unit_obj.type == \"HTLF\" and \"AFC_lane\" in self.fullname:\n            self.drive_stepper      = self.unit_obj.drive_stepper_obj\n            self.extruder_stepper   = self.drive_stepper.extruder_stepper\n\n    @contextmanager\n    def assist_move(self, speed, rewind, assist_active=True):\n        \"\"\"\n        Starts an assist move and returns a context manager that turns off the assist move when it exist.\n        :param speed:         The speed of the move\n        :param rewind:        True for a rewind, False for a forward assist\n        :param assist_active: Whether to assist\n        :return:              the Context manager\n        \"\"\"\n        if assist_active:\n            if rewind:\n                # Calculate Rewind Speed\n                value = self.calculate_pwm_value(speed, True) * -1\n            else:\n                # Calculate Forward Assist Speed\n                value = self.calculate_pwm_value(speed)\n\n            # Clamp value to a maximum of 1\n            if value > 1:\n                value = 1\n\n            self.espooler.assist(value)\n        try:\n            yield\n        finally:\n            if assist_active:\n                self.espooler.assist(0)\n\n    def get_speed_accel(self, mode: SpeedMode) -> float:\n        \"\"\"\n        Helper function to allow selecting the right speed and acceleration of movements\n        mode (Enum SpeedMode): Identifies which speed to use.\n        \"\"\"\n        if self.afc._get_quiet_mode() == True:\n            return self.afc.quiet_moves_speed, self.short_moves_accel\n        elif mode == SpeedMode.LONG:\n            return self.long_moves_speed, self.long_moves_accel\n        elif mode == SpeedMode.SHORT:\n            return self.short_moves_speed, self.short_moves_accel\n        else:\n            return self.dist_hub_move_speed, self.dist_hub_move_accel\n\n    def move(self, distance, speed, accel, assist_active=False):\n        \"\"\"\n        Move the specified lane a given distance with specified speed and acceleration.\n        This function calculates the movement parameters and commands the stepper motor\n        to move the lane accordingly.\n        Parameters:\n        distance (float): The distance to move.\n        speed (float): The speed of the movement.\n        accel (float): The acceleration of the movement.\n        \"\"\"\n        self.unit_obj.select_lane( self )\n        with self.assist_move( speed, distance < 0, assist_active):\n            if self.drive_stepper is not None:\n                self.drive_stepper.move(distance, speed, accel, assist_active)\n\n    def move_advanced(self, distance, speed_mode: SpeedMode, assist_active: AssistActive = AssistActive.NO):\n        \"\"\"\n        Wrapper for move function and is used to compute several arguments\n        to move the lane accordingly.\n        Parameters:\n        distance (float): The distance to move.\n        speed_mode (Enum SpeedMode): Identifies which speed to use.\n        assist_active (Enum AssistActive): Determines to force assist or to dynamically determine.\n        \"\"\"\n        speed, accel = self.get_speed_accel(speed_mode)\n\n        assist = False\n        if assist_active == AssistActive.YES:\n            assist = True\n        elif assist_active == AssistActive.DYNAMIC:\n            assist = abs(distance) > 200\n\n        self.move(distance, speed, accel, assist)\n\n    def set_afc_prep_done(self):\n        \"\"\"\n        set_afc_prep_done function should only be called once AFC PREP function is done. Once this\n            function is called it sets afc_prep_done to True. Once this is done the prep_callback function will\n            now load once filament is inserted.\n        \"\"\"\n        self._afc_prep_done = True\n\n    def _perform_infinite_runout(self):\n        \"\"\"\n        Common function for infinite spool runout\n            - Unloads current lane and loads the next lane as specified by runout variable.\n            - Swaps mapping between current lane and runout lane so correct lane is loaded with T(n) macro\n            - Once changeover is successful print is automatically resumed\n        \"\"\"\n        self.status = AFCLaneState.NONE\n        self.afc.function.afc_led(self.afc.led_not_ready, self.led_index)\n        self.logger.info(\"Infinite Spool triggered for {}\".format(self.name))\n        empty_lane = self.afc.lanes[self.afc.current]\n        change_lane = self.afc.lanes[self.runout_lane]\n        # Pause printer with manual command\n        self.afc.error.pause_resume.send_pause_command()\n        # Saving position after printer is paused\n        self.afc.save_pos()\n        # Change Tool and don't restore position. Position will be restored after lane is unloaded\n        #  so that nozzle does not sit on print while lane is unloading\n        self.afc.CHANGE_TOOL(change_lane, restore_pos=False)\n        # Change Mapping\n        self.gcode.run_script_from_command('SET_MAP LANE={} MAP={}'.format(change_lane.name, empty_lane.map))\n        # Only continue if a error did not happen\n        if not self.afc.error_state:\n            # Eject lane from BT\n            self.gcode.run_script_from_command('LANE_UNLOAD LANE={}'.format(empty_lane.name))\n            # Resume pos\n            self.afc.restore_pos()\n            # Resume with manual issued command\n            self.afc.error.pause_resume.send_resume_command()\n            # Set LED to not ready\n            self.afc.function.afc_led(self.led_not_ready, self.led_index)\n\n    def _perform_pause_runout(self):\n        \"\"\"\n        Common function to pause print when runout occurs, fully unloads and ejects spool if specified by user\n        \"\"\"\n        # Unload if user has set AFC to unload on runout\n        if self.unit_obj.unload_on_runout:\n            # Pause printer\n            self.afc.error.pause_resume.send_pause_command()\n            self.afc.save_pos()\n            # self.gcode.run_script_from_command('PAUSE')\n            self.afc.TOOL_UNLOAD(self)\n            if not self.afc.error_state:\n                self.afc.LANE_UNLOAD(self)\n        # Pause print\n        self.status = AFCLaneState.NONE\n        msg = \"Runout triggered for lane {} and runout lane is not setup to switch to another lane\".format(self.name)\n        msg += \"\\nPlease manually load next spool into toolhead and then hit resume to continue\"\n        self.afc.function.afc_led(self.afc.led_not_ready, self.led_index)\n        self.afc.error.AFC_error(msg)\n\n    def load_callback(self, eventtime, state):\n        self.load_state = state\n        if self.printer.state_message == 'Printer is ready' and self.unit_obj.type == \"HTLF\":\n            self.prep_state = state\n\n    def handle_load_runout(self, eventtime, load_state):\n        \"\"\"\n        Callback function for load switch runout/loading for HTLF, this is different than `load_callback`\n        function as this function can be delayed and is called from filament_switch_sensor class when it detects a runout event.\n\n        Before exiting `min_event_systime` is updated as this mimics how its done in `_exec_gcode` function in RunoutHelper class\n        as AFC overrides `_runout_event_handler` function with this function callback. If `min_event_systime` does not get\n        updated then future switch changes will not be detected.\n\n        :param eventtime: Event time from the button press\n        \"\"\"\n        # Call filament sensor callback so that state is registered\n        try:\n            self.load_debounce_button._old_note_filament_present(load_state)\n        except:\n            self.load_debounce_button._old_note_filament_present(eventtime, load_state)\n\n        if self.printer.state_message == 'Printer is ready' and self.unit_obj.type == \"HTLF\":\n            if load_state:\n                self.status = AFCLaneState.LOADED\n                self.unit_obj.lane_loaded(self)\n                self.afc.spool._set_values(self)\n            else:\n                # Don't run if user disabled sensor in gui\n                if not self.fila_load.runout_helper.sensor_enabled and self.afc.function.is_printing():\n                    self.logger.warning(\"Load runout has been detected, but pause and runout detection has been disabled\")\n                elif self.unit_obj.check_runout(self):\n                    # Checking to make sure runout_lane is set\n                    if self.runout_lane is not None:\n                        self._perform_infinite_runout()\n                    else:\n                        self._perform_pause_runout()\n                elif self.status != \"calibrating\":\n                    self.afc.function.afc_led(self.led_not_ready, self.led_index)\n                    self.status = AFCLaneState.NONE\n                    self.loaded_to_hub = False\n                    self.afc.spool._clear_values(self)\n                    self.afc.function.afc_led(self.afc.led_not_ready, self.led_index)\n        self.afc.save_vars()\n\n    def prep_callback(self, eventtime, state):\n        self.prep_state = state\n\n        delta_time = eventtime - self.last_prep_time\n        self.last_prep_time = eventtime\n\n        if self.prep_active:\n            return\n\n        if self.hub =='direct' and not self.afc.function.is_homed():\n            self.afc.error.AFC_error(\"Please home printer before directly loading to toolhead\", False)\n            return False\n\n        self.prep_active = True\n\n        # Checking to make sure printer is ready and making sure PREP has been called before trying to load anything\n        for i in range(1):\n            # Hacky way for do{}while(0) loop, DO NOT return from this for loop, use break instead so that self.prep_state variable gets sets correctly\n            #  before exiting function\n            if self.printer.state_message == 'Printer is ready' and True == self._afc_prep_done and self.status != AFCLaneState.TOOL_UNLOADING:\n                # Only try to load when load state trigger is false\n                if self.prep_state == True and self.load_state == False:\n                    x = 0\n                    # Checking to make sure last time prep switch was activated was less than 1 second, returning to keep is printing message from spamming\n                    # the console since it takes klipper some time to transition to idle when idle_resume=printing\n                    if delta_time < 1.0:\n                        break\n\n                    # Check to see if the printer is printing or moving, as trying to load while printer is doing something will crash klipper\n                    if self.afc.function.is_printing(check_movement=True):\n                        self.afc.error.AFC_error(\"Cannot load spools while printer is actively moving or homing\", False)\n                        break\n\n                    while self.load_state == False and self.prep_state == True and self.load is not None:\n                        x += 1\n                        self.do_enable(True)\n                        self.move(10,500,400)\n                        self.reactor.pause(self.reactor.monotonic() + 0.1)\n                        if x> 40:\n                            msg = ' FAILED TO LOAD, CHECK FILAMENT AT TRIGGER\\n||==>--||----||------||\\nTRG   LOAD   HUB    TOOL'\n                            self.afc.error.AFC_error(msg, False)\n                            self.afc.function.afc_led(self.afc.led_fault, self.led_index)\n                            self.status = AFCLaneState.NONE\n                            break\n                    self.status = AFCLaneState.NONE\n\n                    # Verify that load state is still true as this would still trigger if prep sensor was triggered and then filament was removed\n                    #   This is only really a issue when using direct and still using load sensor\n                    if self.hub == 'direct' and self.prep_state:\n                        self.afc.afcDeltaTime.set_start_time()\n                        self.afc.TOOL_LOAD(self)\n                        self.material = self.afc.default_material_type\n                        break\n\n                    # Checking if loaded to hub(it should not be since filament was just inserted), if false load to hub. Does a fast load if hub distance is over 200mm\n                    if self.load_to_hub and not self.loaded_to_hub and self.load_state and self.prep_state:\n                        self.move(self.dist_hub, self.dist_hub_move_speed, self.dist_hub_move_accel, self.dist_hub > 200)\n                        self.loaded_to_hub = True\n\n                    self.do_enable(False)\n                    if self.load_state == True and self.prep_state == True:\n                        self.status = AFCLaneState.LOADED\n                        self.unit_obj.lane_loaded(self)\n                        self.afc.spool._set_values(self)\n                elif self.prep_state == True and self.load_state == True and not self.afc.function.is_printing():\n                    message = 'Cannot load {} load sensor is triggered.'.format(self.name)\n                    message += '\\n    Make sure filament is not stuck in load sensor or check to make sure load sensor is not stuck triggered.'\n                    message += '\\n    Once cleared try loading again'\n                    self.afc.error.AFC_error(message, pause=False)\n        self.prep_active = False\n        self.afc.save_vars()\n\n    def handle_prep_runout(self, eventtime, prep_state):\n        \"\"\"\n        Callback function for prep switch runout, this is different than `prep_callback`\n        function as this function can be delayed and is called from filament_switch_sensor class when it detects a runout event.\n\n        Before exiting `min_event_systime` is updated as this mimics how its done in `_exec_gcode` function in RunoutHelper class\n        as AFC overrides `_runout_event_handler` function with this function callback. If `min_event_systime` does not get\n        updated then future switch changes will not be detected.\n\n        :param eventtime: Event time from the button press\n        \"\"\"\n        # Call filament sensor callback so that state is registered\n        try:\n            self.prep_debounce_button._old_note_filament_present(prep_state)\n        except:\n            self.prep_debounce_button._old_note_filament_present(eventtime, prep_state)\n\n        if self.printer.state_message == 'Printer is ready' and True == self._afc_prep_done and self.status != AFCLaneState.TOOL_UNLOADING:\n            if prep_state == False and self.name == self.afc.current and self.afc.function.is_printing() and self.load_state and self.status != AFCLaneState.EJECTING:\n                # Don't run if user disabled sensor in gui\n                if not self.fila_prep.runout_helper.sensor_enabled:\n                    self.logger.warning(\"Prep runout has been detected, but pause and runout detection has been disabled\")\n                # Checking to make sure runout_lane is set\n                elif self.runout_lane is not None:\n                    self._perform_infinite_runout()\n                else:\n                    self._perform_pause_runout()\n            elif not prep_state:\n                # Filament is unloaded\n                self.status = AFCLaneState.NONE\n                self.loaded_to_hub = False\n                self.afc.spool._clear_values(self)\n                self.unit_obj.lane_unloaded(self)\n\n        self.afc.save_vars()\n\n    def do_enable(self, enable):\n        if self.drive_stepper is not None:\n            self.drive_stepper.do_enable(enable)\n\n    def sync_print_time(self):\n        return\n\n    def sync_to_extruder(self, update_current=True):\n        \"\"\"\n        Helper function to sync lane to extruder and set print current if specified.\n\n        :param update_current: Sets current to specified print current when True\n        \"\"\"\n        if self.drive_stepper is not None:\n            self.drive_stepper.sync_to_extruder(update_current, extruder_name=self.extruder_name)\n\n    def unsync_to_extruder(self, update_current=True):\n        \"\"\"\n        Helper function to un-sync lane to extruder and set load current if specified.\n\n        :param update_current: Sets current to specified load current when True\n        \"\"\"\n        if self.drive_stepper is not None:\n            self.drive_stepper.unsync_to_extruder(update_current)\n\n    def _set_current(self, current):\n        return\n\n    def set_load_current(self):\n        \"\"\"\n        Helper function to update TMC current to use run current value\n        \"\"\"\n        if self.drive_stepper is not None:\n            self.drive_stepper.set_load_current()\n\n    def set_print_current(self):\n        \"\"\"\n        Helper function to update TMC current to use print current value\n        \"\"\"\n        if self.drive_stepper is not None:\n            self.drive_stepper.set_print_current()\n\n    def update_rotation_distance(self, multiplier):\n        if self.drive_stepper is not None:\n            self.drive_stepper.update_rotation_distance( multiplier )\n\n    def calculate_effective_diameter(self, weight_g, spool_width_mm=60):\n\n        # Calculate the cross-sectional area of the filament\n        density_g_mm3 = self.filament_density / 1000.0\n        filament_volume_mm3 = weight_g / density_g_mm3\n        package_corrected_volume_mm3 = filament_volume_mm3 / 0.785\n        filament_area_mm2 = package_corrected_volume_mm3 / spool_width_mm\n        spool_outer_diameter_mm2 = (4 * filament_area_mm2 / 3.14159) + self.inner_diameter ** 2\n        spool_outer_diameter_mm = spool_outer_diameter_mm2 ** 0.5\n\n        return spool_outer_diameter_mm\n\n    def calculate_rpm(self, feed_rate):\n        \"\"\"\n        Calculate the RPM for the assist motor based on the filament feed rate.\n\n        :param feed_rate: Filament feed rate in mm/s\n        :return: Calculated RPM for the assist motor\n        \"\"\"\n        # Figure in weight of empty spool\n        weight = self.weight + self.empty_spool_weight\n\n        # Calculate the effective diameter\n        effective_diameter = self.calculate_effective_diameter(weight)\n\n        # Calculate RPM\n        rpm = (feed_rate * 60) / (math.pi * effective_diameter)\n        return min(rpm, self.max_motor_rpm)  # Clamp to max motor RPM\n\n    def calculate_pwm_value(self, feed_rate, rewind=False):\n        \"\"\"\n        Calculate the PWM value for the assist motor based on the feed rate.\n\n        :param feed_rate: Filament feed rate in mm/s\n        :return: PWM value between 0 and 1\n        \"\"\"\n        rpm = self.calculate_rpm(feed_rate)\n        if not rewind:\n            pwm_value = rpm / (self.max_motor_rpm / (1 + 9 * self.fwd_speed_multi))\n        else:\n            pwm_value = rpm / (self.max_motor_rpm / (15 + 15 * self.rwd_speed_multi))\n        return max(0.0, min(pwm_value, 1.0))  # Clamp the value between 0 and 1\n\n    def enable_weight_timer(self):\n        \"\"\"\n        Helper function to enable weight callback timer, should be called once a lane is loaded\n        to extruder or extruder is switched for multi-toolhead setups.\n        \"\"\"\n        self.past_extruder_position = self.afc.function.get_extruder_pos( None, self.past_extruder_position )\n        self.reactor.update_timer( self.cb_update_weight, self.reactor.monotonic() + self.UPDATE_WEIGHT_DELAY)\n\n    def disable_weight_timer(self):\n        \"\"\"\n        Helper function to disable weight callback timer for lane and save variables\n        to file. Should only be called when lane is unloaded from extruder or when\n        swapping extruders for multi-toolhead setups.\n        \"\"\"\n        self.update_weight_callback( None ) # get final movement before disabling timer\n        self.reactor.update_timer( self.cb_update_weight, self.reactor.NEVER)\n        self.past_extruder_position = -1\n        self.save_counter = -1\n        self.afc.save_vars()\n\n    def update_weight_callback(self, eventtime):\n        \"\"\"\n        Callback function for updating weight based on how much filament has been extruded\n\n        :param eventtime: Current eventtime for timer callback\n        :return int: Next time to call timer callback. Current time + UPDATE_WEIGHT_DELAY\n        \"\"\"\n        extruder_pos = self.afc.function.get_extruder_pos( eventtime, self.past_extruder_position )\n        delta_length = extruder_pos - self.past_extruder_position\n\n        if -1 == self.past_extruder_position:\n            self.past_extruder_position = extruder_pos\n\n        self.save_counter += 1\n        if extruder_pos > self.past_extruder_position:\n            self.update_remaining_weight(delta_length)\n            self.past_extruder_position = extruder_pos\n\n            # self.logger.debug(f\"{self.name} Weight Timer Callback: New weight {self.weight}\")\n\n            # Save vars every 2 minutes\n            if self.save_counter > 120/self.UPDATE_WEIGHT_DELAY:\n                self.afc.save_vars()\n                self.save_counter = 0\n\n        return self.reactor.monotonic() + self.UPDATE_WEIGHT_DELAY\n\n    def update_remaining_weight(self, distance_moved):\n        \"\"\"\n        Update the remaining filament weight based on the filament distance moved.\n\n        :param distance_moved: Distance of filament moved in mm.\n        \"\"\"\n        filament_volume_mm3 = math.pi * (self.filament_diameter / 2) ** 2 * distance_moved\n        filament_weight_change = filament_volume_mm3 * self.filament_density / 1000  # Convert mm cubed to g\n        self.weight -= filament_weight_change\n\n        # Weight cannot be negative, force back to zero if it's below zero\n        if self.weight < 0:\n            self.weight = 0\n\n    def set_loaded(self):\n        \"\"\"\n        Helper function for setting multiple variables when lane is loaded\n        \"\"\"\n        self.tool_loaded = True\n        self.afc.current = self.extruder_obj.lane_loaded = self.name\n        self.afc.current_loading = None\n        self.status = AFCLaneState.TOOLED\n        self.afc.spool.set_active_spool(self.spool_id)\n\n        self.unit_obj.lane_tool_loaded(self)\n\n    def set_unloaded(self):\n        \"\"\"\n        Helper function for setting multiple variables when lane is unloaded\n        \"\"\"\n        self.tool_loaded = False\n        self.extruder_obj.lane_loaded = \"\"\n        self.status = AFCLaneState.NONE\n        self.afc.current = None\n        self.afc.current_loading = None\n        self.afc.spool.set_active_spool(None)\n        self.unit_obj.lane_tool_unloaded(self)\n\n    def enable_buffer(self):\n        \"\"\"\n        Enable the buffer if `buffer_name` is set.\n        Retrieves the buffer object and calls its `enable_buffer()` method to activate it.\n        \"\"\"\n        if self.buffer_obj is not None:\n            self.buffer_obj.enable_buffer()\n        self.espooler.enable_timer()\n        self.enable_weight_timer()\n\n    def disable_buffer(self):\n        \"\"\"\n        Disable the buffer if `buffer_name` is set.\n        Calls the buffer's `disable_buffer()` method to deactivate it.\n        \"\"\"\n        if self.buffer_obj is not None:\n            self.buffer_obj.disable_buffer()\n        self.espooler.disable_timer()\n        self.disable_weight_timer()\n\n    def buffer_status(self):\n        \"\"\"\n        Retrieve the current status of the buffer.\n        If `buffer_name` is set, returns the buffer's status using `buffer_status()`.\n        Otherwise, returns None.\n        \"\"\"\n        if self.buffer_obj is not None:\n            return self.buffer_obj.buffer_status()\n\n        else: return None\n\n    def get_toolhead_pre_sensor_state(self):\n        \"\"\"\n        Helper function that returns current state of toolhead pre sensor or buffer if user has extruder setup for ramming\n\n        returns Status of toolhead pre sensor or the current buffer advance state\n        \"\"\"\n        if self.extruder_obj.tool_start == \"buffer\":\n            return self.buffer_obj.advance_state\n        else:\n            return self.extruder_obj.tool_start_state\n\n    def get_trailing(self):\n        \"\"\"\n        Helper function to get trailing status, returns none if buffer is not defined\n        \"\"\"\n        if self.buffer_obj is not None:\n            return self.buffer_obj.trailing_state\n        else: return None\n\n\n    def _is_normal_printing_state(self):\n        \"\"\"\n        Returns True if the lane is in a normal printing state (TOOLED or LOADED).\n        Prevents runout logic from triggering during transitions or maintenance.\n        \"\"\"\n        return self.status in (AFCLaneState.TOOLED, AFCLaneState.LOADED)\n\n    def handle_toolhead_runout(self, sensor=None):\n        \"\"\"\n        Handles runout detection at the toolhead sensor.\n        If all upstream sensors (prep, load, hub) still detect filament, this indicates a break or jam at the toolhead.\n        Otherwise, triggers normal runout handling logic. Only triggers during normal printing states and when printing.\n        :param sensor: Optional name of the triggering sensor for user notification.\n        \"\"\"\n        # Only trigger runout logic if in a normal printing state AND printer is actively printing\n        if not (self._is_normal_printing_state() and self.afc.function.is_printing()):\n            return\n\n        # Check upstream sensors: prep, load, hub\n        prep_ok = self.prep_state\n        load_ok = self.load_state\n        hub_ok = self.hub_obj.state if self.hub_obj is not None else True\n\n        # If all upstream sensors are still True, this is a break/jam at the toolhead\n        if prep_ok and load_ok and hub_ok:\n            msg = (\n                f\"Toolhead runout detected by {sensor} sensor, but upstream sensors still detect filament.\\n\"\n                \"Possible filament break or jam at the toolhead. Please clear the jam and reload filament manually, then resume the print.\"\n            )\n            self.afc.error.pause_resume.send_pause_command()\n            self.afc.save_pos()\n            self.afc.error.AFC_error(msg)\n        # No else: do not trigger infinite runout or pause runout here\n\n    def handle_hub_runout(self, sensor=None):\n        \"\"\"\n        Handles runout detection at the hub sensor.\n        If both upstream sensors (prep, load) still detect filament but hub does not, this indicates a break or jam at the hub.\n        Otherwise, triggers normal runout handling logic. Only triggers during normal printing states and when printing.\n        :param sensor: Optional name of the triggering sensor for user notification.\n        \"\"\"\n        # Only trigger runout logic if in a normal printing state AND printer is actively printing\n        if not (self._is_normal_printing_state() and self.afc.function.is_printing()):\n            return\n\n        # Check upstream sensors: prep, load\n        prep_ok = self.prep_state\n        load_ok = self.load_state\n        hub_ok = self.hub_obj.state if self.hub_obj is not None else False\n\n        # If both upstream sensors are still True, but hub is not, this is a break/jam at the hub\n        if prep_ok and load_ok and not hub_ok:\n            msg = (\n                f\"Hub runout detected by {sensor or 'hub'} sensor, but upstream sensors still detect filament.\\n\"\n                \"Possible filament break or jam at the hub. Please clear the jam and reload filament manually, then resume the print.\"\n            )\n            self.afc.error.pause_resume.send_pause_command()\n            self.afc.save_pos()\n            self.afc.error.AFC_error(msg)\n        # No else: do not trigger infinite runout or pause runout here\n\n\n    cmd_SET_LANE_LOADED_help = \"Sets current lane as loaded to toolhead, useful when manually loading lanes during prints if AFC detects an error when trying to unload/load a lane\"\n    cmd_SET_LANE_LOAD_options = {\"LANE\": {\"type\": \"string\", \"default\": \"lane1\"}}\n    def cmd_SET_LANE_LOADED(self, gcmd):\n        \"\"\"\n        This macro handles manually setting a lane loaded into the toolhead. This is useful when manually loading lanes\n        during prints after AFC detects an error when loading/unloading and pauses.\n\n        If there is a lane already loaded this macro will also desync that lane extruder from the toolhead extruder\n        and set its values and led appropriately.\n\n        Retrieves the lane specified by the 'LANE' parameter and sets the appropriate values in AFC to continue using the lane.\n\n        Usage\n        -----\n        `SET_LANE_LOADED LANE=<lane>`\n\n        Example\n        -------\n        ```\n        SET_LANE_LOADED LANE=lane1\n        ```\n        \"\"\"\n        if not self.load_state:\n            self.afc.error.AFC_error(\"Lane:{} is not loaded, cannot set loaded to toolhead for this lane.\".format(self.name), pause=False)\n            return\n\n        # Do not set lane as loaded if virtual bypass or normal bypass is enabled/triggered\n        if self.afc.bypass.sensor_enabled:\n            disable_msg = \"\"\n            msg = f\"Cannot set {self.name} as loaded, \"\n\n            if 'virtual' in self.afc.bypass.name:\n                msg += \"virtual \"\n                disable_msg = \" and disable\"\n            msg += f\"bypass is enabled.\\nPlease unload{disable_msg} before trying to set lanes as loaded.\"\n            self.logger.error(msg)\n            return\n\n        self.afc.function.unset_lane_loaded()\n\n        self.set_loaded()\n        self.sync_to_extruder()\n        self.afc.function.handle_activate_extruder()\n        self.afc.save_vars()\n        self.unit_obj.select_lane(self)\n        self.logger.info(\"Manually set {} loaded to toolhead\".format(self.name))\n\n    cmd_SET_LONG_MOVE_SPEED_help = \"Gives ability to set long_moves_speed or rev_long_moves_speed_factor values without having to update config and restart\"\n    def cmd_SET_LONG_MOVE_SPEED(self, gcmd):\n        \"\"\"\n        Macro call to update long_moves_speed or rev_long_moves_speed_factor values without having to set in config and restart klipper. This macro allows adjusting\n        these values while printing. Multiplier values must be between 0.5 - 1.2\n\n        Use `FWD_SPEED` variable to set forward speed in mm/sec, use `RWD_FACTOR` to set reverse multiplier\n\n        Usage\n        -----\n        `SET_LONG_MOVE_SPEED LANE=<lane_name> FWD_SPEED=<fwd_speed> RWD_FACTOR=<rwd_multiplier> SAVE=<0 or 1>`\n\n        Example\n        -----\n        ```\n        SET_LONG_MOVE_SPEED LANE=lane1 RWD_FACTOR=0.9 SAVE=1\n        ```\n        \"\"\"\n        update = gcmd.get_int(\"SAVE\", 0, minval=0, maxval=2)\n        old_long_moves_speed = self.long_moves_speed\n        old_rev_long_moves_speed_factor= self.rev_long_moves_speed_factor\n\n        self.long_moves_speed = gcmd.get_float(\"FWD_SPEED\", self.long_moves_speed, minval=50, maxval=500)\n        self.rev_long_moves_speed_factor = gcmd.get_float(\"RWD_FACTOR\", self.rev_long_moves_speed_factor, minval=0.0, maxval=1.2)\n\n        if self.rev_long_moves_speed_factor < 0.5: self.rev_long_moves_speed_factor = 0.5\n        if self.rev_long_moves_speed_factor > 1.2: self.rev_long_moves_speed_factor = 1.2\n\n        if self.long_moves_speed != old_long_moves_speed:\n            self.logger.info(\"{name} forward speed set, New: {new}, Old: {old}\".format(name=self.name, new=self.long_moves_speed, old=old_long_moves_speed))\n        else:\n            self.logger.info(\"{name} forward speed currently set to {new}\".format(name=self.name, new=self.long_moves_speed))\n\n\n        if self.rev_long_moves_speed_factor != old_rev_long_moves_speed_factor:\n            self.logger.info(\"{name} reverse speed multiplier set, New: {new}, Old: {old}\".format(name=self.name, new=self.rev_long_moves_speed_factor, old=old_rev_long_moves_speed_factor))\n        else:\n            self.logger.info(\"{name} reverse speed multiplier currently set to {new}\".format(name=self.name, new=self.rev_long_moves_speed_factor))\n\n        if update == 1:\n            self.afc.function.ConfigRewrite(self.fullname, 'long_moves_speed',  self.long_moves_speed, '')\n            self.afc.function.ConfigRewrite(self.fullname, 'rev_long_moves_speed_factor',  self.rev_long_moves_speed_factor, '')\n\n\n    cmd_SET_SPEED_MULTIPLIER_help = \"Gives ability to set fwd_speed_multiplier or rwd_speed_multiplier values without having to update config and restart\"\n    def cmd_SET_SPEED_MULTIPLIER(self, gcmd):\n        \"\"\"\n        Macro call to update fwd_speed_multiplier or rwd_speed_multiplier values without having to set in config and restart klipper. This macro allows adjusting\n        these values while printing.\n\n        Use `FWD` variable to set forward multiplier, use `RWD` to set reverse multiplier\n\n        After running this command run `SAVE_SPEED_MULTIPLIER LANE=<lane_name>` to save value to config file\n\n        Usage\n        -----\n        `SET_SPEED_MULTIPLIER LANE=<lane_name> FWD=<fwd_multiplier> RWD=<rwd_multiplier>`\n\n        Example\n        -----\n        ```\n        SET_SPEED_MULTIPLIER LANE=lane1 RWD=0.9\n        ```\n        \"\"\"\n        updated = False\n        old_fwd_value = self.fwd_speed_multi\n        old_rwd_value = self.rwd_speed_multi\n\n        self.fwd_speed_multi = gcmd.get_float(\"FWD\", self.fwd_speed_multi, minval=0.0)\n        self.rwd_speed_multi = gcmd.get_float(\"RWD\", self.rwd_speed_multi, minval=0.0)\n\n        if self.fwd_speed_multi != old_fwd_value:\n            self.logger.info(\"{name} forward speed multiplier set, New: {new}, Old: {old}\".format(name=self.name, new=self.fwd_speed_multi, old=old_fwd_value))\n            updated = True\n\n        if self.rwd_speed_multi != old_rwd_value:\n            self.logger.info(\"{name} reverse speed multiplier set, New: {new}, Old: {old}\".format(name=self.name, new=self.rwd_speed_multi, old=old_rwd_value))\n            updated = True\n\n        if updated:\n            self.logger.info(\"Run SAVE_SPEED_MULTIPLIER LANE={} to save values to config file\".format(self.name))\n\n    cmd_SAVE_SPEED_MULTIPLIER_help = \"Saves fwd_speed_multiplier and rwd_speed_multiplier values to config file \"\n    def cmd_SAVE_SPEED_MULTIPLIER(self, gcmd):\n        \"\"\"\n        Macro call to write fwd_speed_multiplier and rwd_speed_multiplier variables to config file for specified lane.\n\n        Usage\n        -----\n        `SAVE_SPEED_MULTIPLIER LANE=<lane_name>`\n\n        Example\n        -----\n        ```\n        SAVE_SPEED_MULTIPLIER LANE=lane1\n        ```\n        \"\"\"\n        self.afc.function.ConfigRewrite(self.fullname, 'fwd_speed_multiplier', self.fwd_speed_multi, '')\n        self.afc.function.ConfigRewrite(self.fullname, 'rwd_speed_multiplier', self.rwd_speed_multi, '')\n\n    cmd_SET_HUB_DIST_help = \"Helper to dynamically set distance between a lanes extruder and hub\"\n    def cmd_SET_HUB_DIST(self, gcmd):\n        \"\"\"\n        This function adjusts the distance between a lanes extruder and hub. Adding +/- in front of the length will\n        increase/decrease length by that amount. To reset length back to config value, pass in `reset` for length to\n        reset to value in config file.\n\n        Usage\n        -----\n        `SET_HUB_DIST LANE=<lane_name> LENGTH=+/-<fwd_multiplier>`\n\n        Example\n        -----\n        ```\n        SET_HUB_DIST LANE=lane1 LENGTH=+100\n        ```\n        \"\"\"\n        old_dist_hub = self.dist_hub\n\n        length = gcmd.get(\"LENGTH\", self.dist_hub)\n\n        if length != old_dist_hub:\n            self.dist_hub = self.afc.function._calc_length(self.config_dist_hub, self.dist_hub, length)\n        msg =  \"//{} dist_hub:\\n\".format(self.name)\n        msg += '//   Config Length:   {}\\n'.format(self.config_dist_hub)\n        msg += '//   Previous Length: {}\\n'.format(old_dist_hub)\n        msg += '//   New Length:      {}\\n'.format(self.dist_hub)\n        self.logger.raw(msg)\n        self.logger.info(\"Run SAVE_HUB_DIST LANE={} to save value to config file\".format(self.name))\n\n    cmd_SAVE_HUB_DIST_help = \"Saves dist_hub value to config file \"\n    def cmd_SAVE_HUB_DIST(self, gcmd):\n        \"\"\"\n        Macro call to write dist_hub variable to config file for specified lane.\n\n        Usage\n        -----\n        `SAVE_HUB_DIST LANE=<lane_name>`\n\n        Example\n        -----\n        ```\n        SAVE_HUB_DIST LANE=lane1\n        ```\n        \"\"\"\n        self.afc.function.ConfigRewrite(self.fullname, 'dist_hub', self.dist_hub, '')\n\n    def get_status(self, eventtime=None, save_to_file=False):\n        response = {}\n        if not self.connect_done: return response\n        response['name'] = self.name\n        response['unit'] = self.unit\n        response['hub'] = self.hub\n        response['extruder'] = self.extruder_name\n        response['buffer'] = self.buffer_name\n        response['buffer_status'] = self.buffer_status()\n        response['lane'] = self.index\n        response['map'] = self.map\n        response['load'] = bool(self.load_state)\n        response[\"prep\"] =bool(self.prep_state)\n        response[\"tool_loaded\"] = self.tool_loaded\n        response[\"loaded_to_hub\"] = self.loaded_to_hub\n        response[\"material\"]=self.material\n        if save_to_file:\n            response[\"density\"]=self.filament_density\n            response[\"diameter\"]=self.filament_diameter\n            response[\"empty_spool_weight\"]=self.empty_spool_weight\n\n        response[\"spool_id\"]= int(self.spool_id) if self.spool_id else None\n        response[\"color\"]=self.color\n        response[\"weight\"]=self.weight\n        response[\"extruder_temp\"] = self.extruder_temp\n        response[\"runout_lane\"]=self.runout_lane\n        filament_stat=self.afc.function.get_filament_status(self).split(':')\n        response['filament_status'] = filament_stat[0]\n        response['filament_status_led'] = filament_stat[1]\n        response['status'] = self.status\n        response['dist_hub'] = self.dist_hub\n        return response\n\n\n\ndef load_config_prefix(config):\n    return AFCLane(config)\n",
    'extras.AFC_hub': "# Armored Turtle Automated Filament Changer\n#\n# Copyright (C) 2024 Armored Turtle\n#\n# This file may be distributed under the terms of the GNU GPLv3 license.\nimport traceback\n\nfrom configparser import Error as error\n\ntry: from extras.AFC_utils import ERROR_STR\nexcept: raise error(\"Error when trying to import AFC_utils.ERROR_STR\\n{trace}\".format(trace=traceback.format_exc()))\n\ntry: from extras.AFC_utils import add_filament_switch\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_utils\", trace=traceback.format_exc()))\n\nclass afc_hub:\n    def __init__(self, config):\n        self.printer    = config.get_printer()\n        self.printer.register_event_handler(\"klippy:connect\", self.handle_connect)\n        self.afc        = self.printer.lookup_object('AFC')\n        self.reactor    = self.printer.get_reactor()\n\n        self.fullname   = config.get_name()\n        self.name       = self.fullname.split()[-1]\n\n        self.unit = None\n        self.lanes = {}\n        self.state = False\n\n        # HUB Cut variables\n        # Next two variables are used in AFC\n        self.switch_pin             = config.get('switch_pin')                      # Pin hub sensor it connected to\n        self.hub_clear_move_dis     = config.getfloat(\"hub_clear_move_dis\", 25)     # How far to move filament so that it's not block the hub exit\n        self.afc_bowden_length      = config.getfloat(\"afc_bowden_length\", 900)     # Length of the Bowden tube from the hub to the toolhead sensor in mm.\n        self.afc_unload_bowden_length= config.getfloat(\"afc_unload_bowden_length\", self.afc_bowden_length) # Length to unload when retracting back from toolhead to hub in mm. Defaults to afc_bowden_length\n        self.assisted_retract       = config.getboolean(\"assisted_retract\", False)  # if True, retracts are assisted to prevent loose windings on the spool\n        self.move_dis               = config.getfloat(\"move_dis\", 50)               # Distance to move the filament within the hub in mm.\n        # Servo settings\n        self.cut                    = config.getboolean(\"cut\", False)               # Set True if Hub cutter installed (e.g. Snappy)\n        self.cut_cmd                = config.get('cut_cmd', None)                   # Macro to use for cut.\n        self.cut_servo_name         = config.get('cut_servo_name', 'cut')           # Name of servo to use for cutting\n        self.cut_dist               = config.getfloat(\"cut_dist\", 50)               # How much filament to cut off (in mm).\n        self.cut_clear              = config.getfloat(\"cut_clear\", 120)             # How far the filament should retract back from the hub (in mm).\n        self.cut_min_length         = config.getfloat(\"cut_min_length\", 200)        # Minimum length of filament to cut off\n        self.cut_servo_pass_angle   = config.getfloat(\"cut_servo_pass_angle\", 0)    # Servo angle to align the Bowden tube with the hole for loading the toolhead.\n        self.cut_servo_clip_angle   = config.getfloat(\"cut_servo_clip_angle\", 160)  # Servo angle for cutting the filament.\n        self.cut_servo_prep_angle   = config.getfloat(\"cut_servo_prep_angle\", 75)   # Servo angle to prepare the filament for cutting (aligning the exit hole).\n        self.cut_confirm            = config.getboolean(\"cut_confirm\", 0)           # Set True to cut filament twice\n\n        self.config_bowden_length   = self.afc_bowden_length                        # Used by SET_BOWDEN_LENGTH macro\n        self.config_unload_bowden_length = self.afc_unload_bowden_length\n        self.enable_sensors_in_gui  = config.getboolean(\"enable_sensors_in_gui\",    self.afc.enable_sensors_in_gui) # Set to True to show hub sensor switches as filament sensor in mainsail/fluidd gui, overrides value set in AFC.cfg\n        self.debounce_delay         = config.getfloat(\"debounce_delay\",             self.afc.debounce_delay)\n        self.enable_runout          = config.getboolean(\"enable_hub_runout\",        self.afc.enable_hub_runout)\n\n        buttons = self.printer.load_object(config, \"buttons\")\n        if self.switch_pin is not None:\n            self.state = False\n            buttons.register_buttons([self.switch_pin], self.switch_pin_callback)\n\n        self.fila, self.debounce_button = add_filament_switch( f\"{self.name}_Hub\", self.switch_pin, self.printer,\n                                                                self.enable_sensors_in_gui, self.handle_runout, self.enable_runout,\n                                                                self.debounce_delay)\n\n        # Adding self to AFC hubs\n        self.afc.hubs[self.name]=self\n\n    def __str__(self):\n        return self.name\n\n    def handle_runout(self, eventtime):\n        \"\"\"\n        Callback function for hub runout, this is different than `switch_pin_callback` function as this function\n        can be delayed and is called from filament_switch_sensor class when it detects a runout event.\n\n        Before exiting `min_event_systime` is updated as this mimics how its done in `_exec_gcode` function in RunoutHelper class\n        as AFC overrides `_runout_event_handler` function with this function callback. If `min_event_systime` does not get\n        updated then future switch changes will not be detected.\n\n        :param eventtime: Event time from the button press\n        \"\"\"\n        # Only trigger runout for the currently loaded lane (in the toolhead) if it belongs to this hub\n        current_lane_name = getattr(self.afc, 'current', None)\n        if current_lane_name and current_lane_name in self.lanes:\n            lane = self.lanes[current_lane_name]\n            lane.handle_hub_runout(sensor=self.name)\n        self.fila.runout_helper.min_event_systime = self.reactor.monotonic() + self.fila.runout_helper.event_delay\n\n    def handle_connect(self):\n        \"\"\"\n        Handle the connection event.\n        This function is called when the printer connects. It looks up AFC info\n        and assigns it to the instance variable `self.AFC`.\n        \"\"\"\n        self.gcode = self.afc.gcode\n        self.reactor = self.afc.reactor\n\n        self.printer.send_event(\"afc_hub:register_macros\", self)\n\n    def switch_pin_callback(self, eventtime, state):\n        self.state = state\n\n    def hub_cut(self, cur_lane):\n        servo_string = 'SET_SERVO SERVO={servo} ANGLE={{angle}}'.format(servo=self.cut_servo_name)\n\n        # Prep the servo for cutting.\n        self.gcode.run_script_from_command(servo_string.format(angle=self.cut_servo_prep_angle))\n        # Load the lane until the hub is triggered.\n        while not self.state:\n            cur_lane.move(self.move_dis, cur_lane.short_moves_speed, cur_lane.short_moves_accel)\n\n        # To have an accurate reference position for `hub_cut_dist`, move back and forth in smaller steps\n        # to find the point where the hub just triggers.\n        while self.state:\n            cur_lane.move(-10, cur_lane.short_moves_speed, cur_lane.short_moves_accel, self.assisted_retract)\n        while not self.state:\n            cur_lane.move(2, cur_lane.short_moves_speed, cur_lane.short_moves_accel)\n\n        # Feed the `hub_cut_dist` amount.\n        cur_lane.move(self.cut_dist, cur_lane.short_moves_speed, cur_lane.short_moves_accel)\n        # Have a snooze\n        self.reactor.pause(self.reactor.monotonic() + 0.5)\n\n\n        # Choppy Chop\n        self.gcode.run_script_from_command(servo_string.format(angle=self.cut_servo_clip_angle))\n        if self.cut_confirm:\n            self.reactor.pause(self.reactor.monotonic() + 0.5)\n            # ReChop, To be doubly choppy sure.\n            self.gcode.run_script_from_command(servo_string.format(angle=self.cut_servo_prep_angle))\n\n            self.reactor.pause(self.reactor.monotonic() + 1)\n            self.gcode.run_script_from_command(servo_string.format(angle=self.cut_servo_clip_angle))\n        # Longer Snooze\n        self.reactor.pause(self.reactor.monotonic() + 1)\n        # Align bowden tube (reset)\n        self.gcode.run_script_from_command(servo_string.format(angle=self.cut_servo_pass_angle))\n\n        # Retract lane by `hub_cut_clear`.\n        cur_lane.move(-self.cut_clear, cur_lane.short_moves_speed, cur_lane.short_moves_accel, self.assisted_retract)\n\n    def get_status(self, eventtime=None):\n        self.response = {}\n        self.response['state'] = bool(self.state)\n        self.response['cut'] = self.cut\n        self.response['cut_cmd'] = self.cut_cmd\n        self.response['cut_dist'] = self.cut_dist\n        self.response['cut_clear'] = self.cut_clear\n        self.response['cut_min_length'] = self.cut_min_length\n        self.response['cut_servo_pass_angle'] = self.cut_servo_pass_angle\n        self.response['cut_servo_clip_angle'] = self.cut_servo_clip_angle\n        self.response['cut_servo_prep_angle'] = self.cut_servo_prep_angle\n        self.response['lanes'] = [lane.name for lane in self.lanes.values()]\n        self.response['afc_bowden_length'] = self.afc_bowden_length\n\n        return self.response\n\ndef load_config_prefix(config):\n    return afc_hub(config)",
    'extras.AFC_BoxTurtle': "# Armored Turtle Automated Filament Control\n#\n# Copyright (C) 2024 Armored Turtle\n#\n# This file may be distributed under the terms of the GNU GPLv3 license.\nimport traceback\n\nfrom configparser import Error as error\n\n\ntry: from extras.AFC_utils import ERROR_STR\nexcept: raise error(\"Error when trying to import AFC_utils.ERROR_STR\\n{trace}\".format(trace=traceback.format_exc()))\n\ntry: from extras.AFC_lane import AFCLaneState\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_lane\", trace=traceback.format_exc()))\n\ntry: from extras.AFC_unit import afcUnit\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_unit\", trace=traceback.format_exc()))\n\nclass afcBoxTurtle(afcUnit):\n    def __init__(self, config):\n        super().__init__(config)\n        self.type = config.get('type', 'Box_Turtle')\n\n    def handle_connect(self):\n        \"\"\"\n        Handle the connection event.\n        This function is called when the printer connects. It looks up AFC info\n        and assigns it to the instance variable `self.afc`.\n        \"\"\"\n        super().handle_connect()\n\n        firstLeg = '<span class=warning--text>|</span><span class=error--text>_</span>'\n        secondLeg = firstLeg + '<span class=warning--text>|</span>'\n        self.logo ='<span class=success--text>R  _____     ____\\n'\n        self.logo+='E /      \\  |  </span><span class=info--text>o</span><span class=success--text> | \\n'\n        self.logo+='A |       |/ ___/ \\n'\n        self.logo+='D |_________/     \\n'\n        self.logo+='Y {first}{second} {first}{second}\\n'.format(first=firstLeg, second=secondLeg)\n        self.logo+= '  ' + self.name + '\\n'\n\n        self.logo_error ='<span class=error--text>E  _ _   _ _\\n'\n        self.logo_error+='R |_|_|_|_|_|\\n'\n        self.logo_error+='R |         \\____\\n'\n        self.logo_error+='O |              \\ \\n'\n        self.logo_error+='R |          |\\ <span class=secondary--text>X</span> |\\n'\n        self.logo_error+='! \\_________/ |___|</span>\\n'\n        self.logo_error+= '  ' + self.name + '\\n'\n\n    def system_Test(self, cur_lane, delay, assignTcmd, enable_movement):\n        msg = ''\n        succeeded = True\n\n        # Run test reverse/forward on each lane\n        cur_lane.unsync_to_extruder(False)\n        if enable_movement:\n            cur_lane.move(5, self.afc.short_moves_speed, self.afc.short_moves_accel, True)\n            self.afc.reactor.pause(self.afc.reactor.monotonic() + delay)\n            cur_lane.move(-5, self.afc.short_moves_speed, self.afc.short_moves_accel, True)\n        else:\n            self.afc.reactor.pause(self.afc.reactor.monotonic() + 0.7)\n\n        if not cur_lane.prep_state:\n            if not cur_lane.load_state:\n                self.afc.function.afc_led(cur_lane.led_not_ready, cur_lane.led_index)\n                msg += 'EMPTY READY FOR SPOOL'\n            else:\n                self.afc.function.afc_led(cur_lane.led_fault, cur_lane.led_index)\n                msg +=\"<span class=error--text> NOT READY</span>\"\n                cur_lane.do_enable(False)\n                msg = '<span class=error--text>CHECK FILAMENT Prep: False - Load: True</span>'\n                succeeded = False\n\n        else:\n            self.afc.function.afc_led(cur_lane.led_ready, cur_lane.led_index)\n            msg +=\"<span class=success--text>LOCKED</span>\"\n            if not cur_lane.load_state:\n                msg +=\"<span class=error--text> NOT LOADED</span>\"\n                self.afc.function.afc_led(cur_lane.led_not_ready, cur_lane.led_index)\n                succeeded = False\n            else:\n                cur_lane.status = AFCLaneState.LOADED\n                msg +=\"<span class=success--text> AND LOADED</span>\"\n                self.afc.function.afc_led(cur_lane.led_spool_illum, cur_lane.led_spool_index)\n\n                if cur_lane.tool_loaded:\n                    if cur_lane.get_toolhead_pre_sensor_state() == True or cur_lane.extruder_obj.tool_start == \"buffer\" or cur_lane.extruder_obj.tool_end_state:\n                        if cur_lane.extruder_obj.lane_loaded == cur_lane.name:\n                            self.afc.current = cur_lane.name\n                            cur_lane.sync_to_extruder()\n                            msg +=\"<span class=primary--text> in ToolHead</span>\"\n                            if cur_lane.extruder_obj.tool_start == \"buffer\":\n                                msg += \"<span class=warning--text>\\n Ram sensor enabled, confirm tool is loaded</span>\"\n\n                            if self.afc.function.get_current_lane() == cur_lane.name:\n                                self.afc.spool.set_active_spool(cur_lane.spool_id)\n                                cur_lane.unit_obj.lane_tool_loaded( cur_lane )\n                                cur_lane.status = AFCLaneState.TOOLED\n\n                            cur_lane.enable_buffer()\n                        else:\n                            if cur_lane.get_toolhead_pre_sensor_state() == True or cur_lane.extruder_obj.tool_end_state:\n                                msg +=\"<span class=error--text> error in ToolHead. \\nLane identified as loaded \\n but not identified as loaded in extruder</span>\"\n                                succeeded = False\n                    else:\n                        lane_check=self.afc.error.fix('toolhead', cur_lane)  #send to error handling\n                        if not lane_check:\n                            return False\n\n        if assignTcmd: self.afc.function.TcmdAssign(cur_lane)\n        cur_lane.do_enable(False)\n        self.logger.info( '{lane_name} tool cmd: {tcmd:3} {msg}'.format(lane_name=cur_lane.name, tcmd=cur_lane.map, msg=msg))\n        cur_lane.set_afc_prep_done()\n\n        return succeeded\n\n    def calibrate_bowden(self, cur_lane, dis, tol):\n        cur_extruder = cur_lane.extruder_obj\n        cur_hub = cur_lane.hub_obj\n        self.logger.raw('Calibrating Bowden Length with {}'.format(cur_lane.name))\n        # move to hub and retrieve that distance, the checkpoint returned and if successful\n        hub_pos, checkpoint, success = self.move_until_state(cur_lane, lambda: cur_hub.state, cur_hub.move_dis, tol,\n                                                             cur_lane.short_move_dis, 0, cur_lane.dist_hub + 200, \"Moving to hub\")\n\n        if not success:\n            # if movement does not succeed fault and return values to calibration macro\n            msg = 'Failed {} after {}mm'.format(checkpoint, hub_pos)\n            return False, msg, hub_pos\n\n        bow_pos = 0\n        if cur_extruder.tool_start:\n            # if tool_start is defined move and confirm distance\n            while not cur_lane.get_toolhead_pre_sensor_state():\n                fault_dis = cur_hub.afc_bowden_length + 500\n                cur_lane.move(dis, self.short_moves_speed, self.short_moves_accel)\n                bow_pos += dis\n                self.afc.reactor.pause(self.afc.reactor.monotonic() + 0.1)\n                if bow_pos >= fault_dis:\n                    # fault if move to bowden length does not reach toolhead sensor return to calibration macro\n                    msg = 'while moving to toolhead. Failed after {}mm'.format(bow_pos)\n                    msg += '\\n if filament stopped short of the toolhead sensor/ramming during calibration'\n                    msg += '\\n use the following command to increase bowden length'\n                    msg += '\\n SET_BOWDEN_LENGTH HUB={} LENGTH=+(distance the filament was short from the toolhead)'.format(cur_hub.name)\n                    return False, msg, bow_pos\n\n            if cur_extruder.tool_start != 'buffer':\n                # is using ramming, only use first trigger of sensor\n                bow_pos, checkpoint, success = self.calc_position(cur_lane, lambda: cur_lane.get_toolhead_pre_sensor_state(), bow_pos,\n                                                                  cur_lane.short_move_dis, tol, 100, \"retract from toolhead sensor\")\n\n            if not success:\n                # fault if check is not successful\n                msg = 'Failed {} after {}mm'.format(checkpoint, bow_pos)\n                return False, msg, bow_pos\n\n            cur_lane.move(bow_pos * -1, cur_lane.long_moves_speed, cur_lane.long_moves_accel, True)\n\n            success, message, hub_dis = self.calibrate_hub(cur_lane, tol)\n\n            if not success:\n                return False, message, hub_dis\n\n            if cur_hub.state:\n                # reset at hub\n                cur_lane.move(cur_hub.move_dis * -1, cur_lane.short_moves_speed, cur_lane.short_moves_accel, True)\n\n            bowden_dist = 0\n            if cur_extruder.tool_start == 'buffer':\n                bowden_dist = bow_pos - (cur_lane.short_move_dis * 2)\n            else:\n                bowden_dist = bow_pos - cur_lane.short_move_dis\n\n            unload_dist = bowden_dist\n\n            cal_msg = '\\n afc_bowden_length: New: {} Old: {}'.format(bowden_dist, cur_lane.hub_obj.afc_bowden_length)\n            unload_cal_msg = '\\n afc_unload_bowden_length: New: {} Old: {}'.format(unload_dist, cur_lane.hub_obj.afc_unload_bowden_length)\n            cur_lane.hub_obj.afc_bowden_length = bowden_dist\n            cur_lane.hub_obj.afc_unload_bowden_length = unload_dist\n\n            if bowden_dist < 0:\n                self.afc.error.AFC_error(\n                    \"'{}' is not a valid length. Please check your setup and re-run calibration.\".format(bowden_dist),\n                    pause=False)\n                return False, \"Invalid bowden length\", bowden_dist\n\n            if unload_dist < 0:\n                self.afc.error.AFC_error(\n                    \"'{}' is not a valid unload length. Please check your setup and re-run calibration.\".format(unload_dist),\n                    pause=False)\n                return False, \"Invalid unload bowden length\", unload_dist\n\n            self.afc.function.ConfigRewrite(cur_hub.fullname, \"afc_bowden_length\", bowden_dist, cal_msg)\n            self.afc.function.ConfigRewrite(cur_hub.fullname, \"afc_unload_bowden_length\", unload_dist, unload_cal_msg)\n            cur_lane.loaded_to_hub  = True\n            cur_lane.do_enable(False)\n            self.afc.save_vars()\n            return True, \"afc_bowden_length successful\", bowden_dist\n        else:\n            self.logger.info('CALIBRATE_AFC is not currently supported without tool start sensor')\n\n    # Helper functions for movement and calibration\n    def calibrate_hub(self, cur_lane, tol):\n        hub_pos = 0\n        msg = ''\n        hub_fault_dis = cur_lane.dist_hub + 150\n        checkpoint = 'hub calibration {}'.format(cur_lane.name)\n        # move until hub sensor is triggered and get information\n        hub_pos, checkpoint, success = self.move_until_state(cur_lane, lambda: cur_lane.hub_obj.state, cur_lane.hub_obj.move_dis,\n                                                             tol, cur_lane.short_move_dis, hub_pos, hub_fault_dis, checkpoint)\n\n        if not success:\n            # fault if check is not successful\n            msg = 'Failed to calibrate dist_hub for {}. Failed after {}mm'.format(cur_lane.name, hub_fault_dis)\n            msg += '\\n if filament stopped short of the hub during calibration use the following command to increase dist_hub value'\n            msg += '\\n SET_HUB_DIST LANE={} LENGTH=+(distance the filament was short from the hub)'.format(cur_lane.name)\n            return False, msg, hub_pos\n\n        hub_dist = cur_lane.dist_hub + 500\n        # verify hub distance\n        tuned_hub_pos, checkpoint, success = self.calc_position(cur_lane, lambda: cur_lane.hub_obj.state, hub_pos,\n                                                                cur_lane.short_move_dis, tol, hub_dist, checkpoint)\n\n        if not success:\n            # fault if check is not successful\n            msg = 'failed {} after {}mm'.format(checkpoint, tuned_hub_pos)\n            return False, msg, tuned_hub_pos\n\n        # when successful return values to calibration macro\n        return True, msg, tuned_hub_pos\n\n    def move_until_state(self, cur_lane, state, move_dis, tolerance, short_move, pos=0, fault_dis=250, checkpoint=None):\n        # moves filament until specified sensor, returns values for further calibration\n        while not state():\n            cur_lane.move(move_dis, cur_lane.short_moves_speed, cur_lane.short_moves_accel)\n            pos += move_dis\n            if pos >= fault_dis:\n                # return if pos exceeds fault_dis\n                return fault_dis, checkpoint, False\n        self.afc.reactor.pause(self.afc.reactor.monotonic() + 0.1)\n\n        state_retracts = 0\n        while state():\n            # retract off of sensor\n            state_retracts =+ 1\n            cur_lane.move(short_move * -1, cur_lane.short_moves_speed, cur_lane.short_moves_accel, True)\n            pos -= short_move\n            check_p = '{} switch did not go false, reset lane and check switch'.format(checkpoint)\n            if state_retracts >= 4:\n                # fault if it takes more than 4 attempts\n                f_dis = short_move * 4\n                return f_dis, check_p, False\n        self.afc.reactor.pause(self.afc.reactor.monotonic() + 0.1)\n\n        tol_checks = 0\n        while not state():\n            # move back to sensor in short steps\n            tol_checks += 1\n            cur_lane.move(tolerance, cur_lane.short_moves_speed, cur_lane.short_moves_accel)\n            pos += tolerance\n            check_p = '{} switch failed to become true during tolerance check, reset lane and check switch'.format(checkpoint)\n            if tol_checks >= 15:\n                # fault if tol_checks exceed 15\n                return fault_dis, check_p, False\n\n        return pos, checkpoint, True\n\n    def calc_position(self, cur_lane, state, pos, short_move, tolerance, fault_dis=250, checkpoint=None):\n        # move off and back on to sensor to calculate end position of calibration\n        check_pos = 0\n        while state():\n            # retract from sensor\n            cur_lane.move(short_move * -1, cur_lane.short_moves_speed, cur_lane.short_moves_accel, True)\n            pos -= short_move\n            check_pos -= short_move\n            if abs(check_pos) >= fault_dis:\n                # fault if absolute value you check_pos exceeds fault_dis\n                return fault_dis, checkpoint, False\n        self.afc.reactor.pause(self.afc.reactor.monotonic() + 0.1)\n\n        checkpoint += ', tolerance check,'\n        tol_checks = 0\n        while not state():\n            #move back to sensor to confirm distance\n            tol_checks += 1\n            cur_lane.move(tolerance, cur_lane.short_moves_speed, cur_lane.short_moves_accel)\n            pos += tolerance\n\n            if tol_checks >= 15:\n                # fault if tol_checks exceeds 15\n                return pos, checkpoint, False\n\n        return pos, checkpoint, True\n\n    def calibrate_lane(self, cur_lane, tol):\n        # function to calibrate distance from secondary extruder to hub\n        cur_hub = cur_lane.hub_obj\n        if cur_hub.state:\n            msg = 'Hub is not clear, check before calibration'\n            return False, msg, 0\n        if not cur_lane.load_state:\n            msg = '{} not loaded, load before calibration'.format(cur_lane.name)\n            return False, msg, 0\n        if not cur_lane.prep_state:\n            msg = '{} is loaded but not prepped, check prep before calibration'.format(cur_lane.name)\n            return False, msg, 0\n\n        self.logger.info('Calibrating {}'.format(cur_lane.name))\n        cur_lane.status = AFCLaneState.CALIBRATING\n        # reset to extruder\n        pos, checkpoint, success = self.calc_position(cur_lane, lambda: cur_lane.load_state, 0, cur_lane.short_move_dis,\n                                                      tol, cur_lane.dist_hub + 100, \"retract to extruder\")\n\n        if not success:\n            msg = 'Lane failed to calibrate {} after {}mm'.format(checkpoint, pos)\n            cur_lane.status = AFCLaneState.NONE\n            cur_lane.unit_obj.return_to_home()\n            return False, msg, 0\n\n        else:\n            success, message, hub_pos = self.calibrate_hub(cur_lane, tol)\n\n            if not success:\n                cur_lane.status = AFCLaneState.NONE\n                cur_lane.unit_obj.return_to_home()\n                return False, message, hub_pos\n\n            if cur_hub.state:\n                cur_lane.move(cur_hub.move_dis * -1, cur_lane.short_moves_speed, cur_lane.short_moves_accel, True)\n\n            cal_dist = hub_pos - cur_hub.hub_clear_move_dis\n            cal_msg = \"\\n{} dist_hub: New: {} Old: {}\".format(cur_lane.name, cal_dist, cur_lane.dist_hub)\n            cur_lane.loaded_to_hub  = True\n            cur_lane.do_enable(False)\n            cur_lane.dist_hub = cal_dist\n            self.afc.function.ConfigRewrite(cur_lane.fullname, \"dist_hub\", cal_dist, cal_msg)\n            cur_lane.status = AFCLaneState.NONE\n            cur_lane.unit_obj.return_to_home()\n            return True, cal_msg, cal_dist\n\ndef load_config_prefix(config):\n    return afcBoxTurtle(config)",
    'extras.AFC': "# Armored Turtle Automated Filament Control\n#\n# Copyright (C) 2024 Armored Turtle\n#\n\nimport json\nimport re\nimport traceback\nfrom configfile import error\nfrom typing import Any\n\n\nERROR_STR = \"Error trying to import {import_lib}, please rerun install-afc.sh script in your AFC-Klipper-Add-On directory then restart klipper\\n\\n{trace}\"\n\ntry: from extras.AFC_lane import AFCLaneState, SpeedMode, AssistActive\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_logger\", trace=traceback.format_exc()))\n\ntry: from extras.AFC_logger import AFC_logger\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_logger\", trace=traceback.format_exc()))\n\ntry: from extras.AFC_functions import afcDeltaTime\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_functions\", trace=traceback.format_exc()))\n\ntry: from extras.AFC_utils import add_filament_switch, AFC_moonraker\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_utils\", trace=traceback.format_exc()))\n\ntry: from extras.AFC_stats import AFCStats\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_stats\", trace=traceback.format_exc()))\n\nAFC_VERSION=\"1.0.31\"\n\n# Class for holding different states so its clear what all valid states are\nclass State:\n    INIT            = \"Initialized\"\n    IDLE            = \"Idle\"\n    ERROR           = \"Error\"\n    LOADING         = \"Loading\"\n    UNLOADING       = \"Unloading\"\n    EJECTING_LANE   = \"Ejecting\"\n    MOVING_LANE     = \"Moving\"\n    RESTORING_POS   = \"Restoring\"\n\ndef load_config(config):\n    return afc(config)\n\nclass afc:\n    def __init__(self, config):\n        self.config  = config\n        self.printer = config.get_printer()\n        self.reactor = self.printer.get_reactor()\n        self.webhooks = self.printer.lookup_object('webhooks')\n        self.printer.register_event_handler(\"klippy:connect\",self.handle_connect)\n        self.logger  = AFC_logger(self.printer, self)\n\n        self.spool      = self.printer.load_object(config, 'AFC_spool')\n        self.error      = self.printer.load_object(config, 'AFC_error')\n        self.function   = self.printer.load_object(config, 'AFC_functions')\n        self.function.afc = self\n        self.gcode      = self.printer.lookup_object('gcode')\n\n        # Registering stepper callback so that mux macro can be set properly with valid lane names\n        self.printer.register_event_handler(\"afc_stepper:register_macros\",self.register_lane_macros)\n        # Registering for sdcard reset file so that error_state can be reset when starting a print\n        self.printer.register_event_handler(\"virtual_sdcard:reset_file\", self._reset_file_callback)\n        # Registering webhooks endpoint for <ip_address>/printer/afc/status\n        self.webhooks.register_endpoint(\"afc/status\", self._webhooks_status)\n\n        self.current        = None\n        self.current_loading= None\n        self.next_lane_load = None\n        self.error_state    = False\n        self.current_state  = State.INIT\n        self.position_saved = False\n        self.spoolman       = None\n        self.prep_done      = False         # Variable used to hold of save_vars function from saving too early and overriding save before prep can be ran\n        self.in_print_timer = None\n\n        # Objects for everything configured for AFC\n        self.units      = {}\n        self.tools      = {}\n        self.lanes      = {}\n        self.hubs       = {}\n        self.buffers    = {}\n        self.tool_cmds  = {}\n        self.led_obj    = {}\n        self.led_state  = True\n        self.bypass     = None\n        self.bypass_last_state = False\n        self.message_queue = []\n        self.monitoring = False\n        self.number_of_toolchanges  = 0\n        self.current_toolchange     = 0\n\n        # tool position when tool change was requested\n        self.change_tool_pos = None\n        self.in_toolchange = False\n        self.tool_start = None\n\n        # Save/resume pos variables\n        self.base_position = [0.0, 0.0, 0.0, 0.0]\n        self.last_gcode_position = [0.0, 0.0, 0.0, 0.0]\n        self.last_toolhead_position = [0.0, 0.0, 0.0, 0.0]\n        self.homing_position = [0.0, 0.0, 0.0, 0.0]\n        self.speed              = 25.\n        self.speed_factor       = 1./60.\n        self.absolute_coord     = True\n        self.absolute_extrude   = True\n        self.extrude_factor     = 1.\n\n        # Config get section\n        self.moonraker_port         = config.get(\"moonraker_port\", 7125)             # Port to connect to when interacting with moonraker. Used when there are multiple moonraker/klipper instances on a single host\n        self.moonraker_host         = config.get(\"moonraker_host\", \"http://localhost\")\n        self.moonraker_connect_to   = config.get(\"moonraker_timeout\", 30)\n        self.unit_order_list        = config.get('unit_order_list','')\n        self.VarFile                = config.get('VarFile','../printer_data/config/AFC/AFC.var')# Path to the variables file for AFC configuration.\n        self.cfgloc                 = self._remove_after_last(self.VarFile,\"/\")\n        self.default_material_temps = config.getlists(\"default_material_temps\",\n                                                      (\"default: 235\", \"PLA:210\", \"PETG:235\", \"ABS:235\", \"ASA:235\"))# Default temperature to set extruder when loading/unloading lanes. Material needs to be either manually set or uses material from spoolman if extruder temp is not set in spoolman.\n        self.default_material_temps = list(self.default_material_temps) if self.default_material_temps is not None else None\n        self.default_material_type  = config.get(\"default_material_type\", None)     # Default material type to assign to a spool once loaded into a lane\n        self.common_density_values  = config.getlists(\"common_density_values\",\n                                                      (\"PLA:1.24\", \"PETG:1.23\", \"ABS:1.04\", \"ASA:1.07\"))\n        self.common_density_values  = list(self.common_density_values)\n        self.test_extrude_amt       = config.get('test_extrude_amt', 10)\n\n        #LED SETTINGS\n        self.ind_lights = None\n        # led_name is not used, either use or needs to be removed, removing this would break everyone's config as well\n        self.led_name               = config.get('led_name',None)\n        self.led_off                = \"0,0,0,0\"\n        self.led_fault              = config.get('led_fault','1,0,0,0')             # LED color to set when faults occur in lane        (R,G,B,W) 0 = off, 1 = full brightness.\n        self.led_ready              = config.get('led_ready','1,1,1,1')             # LED color to set when lane is ready               (R,G,B,W) 0 = off, 1 = full brightness.\n        self.led_not_ready          = config.get('led_not_ready','1,1,0,0')         # LED color to set when lane not ready              (R,G,B,W) 0 = off, 1 = full brightness.\n        self.led_loading            = config.get('led_loading','1,0,0,0')           # LED color to set when lane is loading             (R,G,B,W) 0 = off, 1 = full brightness.\n        self.led_prep_loaded        = config.get('led_loading','1,1,0,0')           # LED color to set when lane is loaded              (R,G,B,W) 0 = off, 1 = full brightness.\n        self.led_unloading          = config.get('led_unloading','1,1,.5,0')        # LED color to set when lane is unloading           (R,G,B,W) 0 = off, 1 = full brightness.\n        self.led_tool_loaded        = config.get('led_tool_loaded','1,1,0,0')       # LED color to set when lane is loaded into tool    (R,G,B,W) 0 = off, 1 = full brightness.\n        self.led_advancing          = config.get('led_buffer_advancing','0,0,1,0')  # LED color to set when buffer is advancing         (R,G,B,W) 0 = off, 1 = full brightness.\n        self.led_trailing           = config.get('led_buffer_trailing','0,1,0,0')   # LED color to set when buffer is trailing          (R,G,B,W) 0 = off, 1 = full brightness.\n        self.led_buffer_disabled    = config.get('led_buffer_disable', '0,0,0,0.25')# LED color to set when buffer is disabled          (R,G,B,W) 0 = off, 1 = full brightness.\n        self.led_spool_illum        = config.get('led_spool_illuminate', \"1,1,1,1\") # LED color to illuminate under spool\n\n        # TOOL Cutting Settings\n        self.tool                   = ''\n        self.tool_cut               = config.getboolean(\"tool_cut\", False)          # Set to True to enable toolhead cutting\n        self.tool_cut_threshold     = config.getint(\"tool_cut_threshold\", 10000)\n        self.tool_cut_cmd           = config.get('tool_cut_cmd', None)              # Macro to use when doing toolhead cutting. Change macro name if you would like to use your own cutting macro\n\n        # CHOICES\n        self.park                   = config.getboolean(\"park\", False)              # Set to True to enable parking during unload\n        self.park_cmd               = config.get('park_cmd', None)                  # Macro to use when parking. Change macro name if you would like to use your own park macro\n        self.kick                   = config.getboolean(\"kick\", False)              # Set to True to enable poop kicking after lane loads\n        self.kick_cmd               = config.get('kick_cmd', None)                  # Macro to use when kicking. Change macro name if you would like to use your own kick macro\n        self.wipe                   = config.getboolean(\"wipe\", False)              # Set to True to enable nozzle wiping after lane loads\n        self.wipe_cmd               = config.get('wipe_cmd', None)                  # Macro to use when nozzle wiping. Change macro name if you would like to use your own wipe macro\n        self.poop                   = config.getboolean(\"poop\", False)              # Set to True to enable pooping(purging color) after lane loads\n        self.poop_cmd               = config.get('poop_cmd', None)                  # Macro to use when pooping. Change macro name if you would like to use your own poop/purge macro\n\n        self.form_tip               = config.getboolean(\"form_tip\", False)          # Set to True to tip forming when unloading lanes\n        self.form_tip_cmd           = config.get('form_tip_cmd', None)              # Macro to use when tip forming. Change macro name if you would like to use your own tip forming macro\n\n        # MOVE SETTINGS\n        self.quiet_mode             = False                                         # Flag indicating if quiet move is enabled or not\n        self.auto_home              = config.getboolean(\"auto_home\", False)          # Flag indicating if homing needs to be done if printer is not already homed\n        self.show_quiet_mode        = config.getboolean(\"show_quiet_mode\", True)    # Flag indicating if quiet move is enabled or not\n        self.quiet_moves_speed      = config.getfloat(\"quiet_moves_speed\", 50)      # Max speed in mm/s to move filament during quietmode\n        self.long_moves_speed       = config.getfloat(\"long_moves_speed\", 100)      # Speed in mm/s to move filament when doing long moves\n        self.long_moves_accel       = config.getfloat(\"long_moves_accel\", 400)      # Acceleration in mm/s squared when doing long moves\n        self.short_moves_speed      = config.getfloat(\"short_moves_speed\", 25)      # Speed in mm/s to move filament when doing short moves\n        self.short_moves_accel      = config.getfloat(\"short_moves_accel\", 400)     # Acceleration in mm/s squared when doing short moves\n        self.short_move_dis         = config.getfloat(\"short_move_dis\", 10)         # Move distance in mm for failsafe moves.\n        self.tool_homing_distance   = config.getfloat(\"tool_homing_distance\", 200)  # Distance over which toolhead homing is to be attempted.\n        self.max_move_dis           = config.getfloat(\"max_move_dis\", 999999)       # Maximum distance to move filament. AFC breaks filament moves over this number into multiple moves. Useful to lower this number if running into timer too close errors when doing long filament moves.\n        self.n20_break_delay_time   = config.getfloat(\"n20_break_delay_time\", 0.200)# Time to wait between breaking n20 motors(nSleep/FWD/RWD all 1) and then releasing the break to allow coasting.\n\n        self.tool_max_unload_attempts= config.getint('tool_max_unload_attempts', 4) # Max number of attempts to unload filament from toolhead when using buffer as ramming sensor\n        self.tool_max_load_checks   = config.getint('tool_max_load_checks', 4)      # Max number of attempts to check to make sure filament is loaded into toolhead extruder when using buffer as ramming sensor\n\n        self.rev_long_moves_speed_factor \t= config.getfloat(\"rev_long_moves_speed_factor\", 1.)     # scalar speed factor when reversing filamentalist\n\n        self.z_hop                  = config.getfloat(\"z_hop\", 0)                   # Height to move up before and after a tool change completes\n        self.xy_resume              = config.getboolean(\"xy_resume\", False)         # Need description or remove as this is currently an unused variable\n        self.resume_speed           = config.getfloat(\"resume_speed\", self.speed)   # Speed mm/s of resume move. Set to 0 to use gcode speed\n        self.error_timeout          = config.getfloat(\"error_timeout\", 36000)      # Timeout in seconds to pause before erroring out when AFC is in error state\n        self.resume_z_speed         = config.getfloat(\"resume_z_speed\", self.speed) # Speed mm/s of resume move in Z. Set to 0 to use gcode speed\n\n        self.global_print_current   = config.getfloat(\"global_print_current\", None) # Global variable to set steppers current to a specified current when printing. Going lower than 0.6 may result in TurtleNeck buffer's not working correctly\n\n        self.enable_sensors_in_gui  = config.getboolean(\"enable_sensors_in_gui\", False) # Set to True to show all sensor switches as filament sensors in mainsail/fluidd gui\n        self.load_to_hub            = config.getboolean(\"load_to_hub\", True)        # Fast loads filament to hub when inserted, set to False to disable. This is a global setting and can be overridden at AFC_stepper\n        self.assisted_unload        = config.getboolean(\"assisted_unload\", True)    # If True, the unload retract is assisted to prevent loose windings, especially on full spools. This can prevent loops from slipping off the spool\n        self.bypass_pause           = config.getboolean(\"pause_when_bypass_active\", False) # When true AFC pauses print when change tool is called and bypass is loaded\n        self.unload_on_runout       = config.getboolean(\"unload_on_runout\", False)  # When True AFC will unload lane and then pause when runout is triggered and spool to swap to is not set(infinite spool)\n        self.short_stats            = config.getboolean(\"print_short_stats\", False) # Set to true to print AFC_STATS in short form instead of wide form, printing short form is better for smaller in width consoles\n        # Setting to True enables espooler assist while printing\n        self.enable_assist          = config.getboolean(\"enable_assist\",        True)\n        # Weight spool has to be below to activate print assist\n        self.enable_assist_weight   = config.getfloat(\"enable_assist_weight\",   500.0)\n        self.enable_hub_runout      = config.getboolean(\"enable_hub_runout\",    True)\n        self.enable_tool_runout     = config.getboolean(\"enable_tool_runout\",   True)\n        self.debounce_delay         = config.getfloat(\"debounce_delay\",         0.)\n\n        self.debug                  = config.getboolean('debug', False)             # Setting to True turns on more debugging to show on console\n        self.testing                = config.getboolean('testing', False)           # Set to true for testing only so that failure states can be tested without stats being reset\n        # Get debug and cast to boolean\n        self.logger.set_debug( self.debug )\n        self._update_trsync(config)\n\n        # Setup pin so a virtual filament sensor can be added for bypass and quiet mode\n        self.printer.lookup_object(\"pins\").register_chip(\"afc_virtual_bypass\", self)\n        self.printer.lookup_object(\"pins\").register_chip(\"afc_quiet_mode\", self)\n\n        # Printing here will not display in console, but it will go to klippy.log\n        self.print_version()\n\n        self.BASE_UNLOAD_FILAMENT    = 'UNLOAD_FILAMENT'\n        self.RENAMED_UNLOAD_FILAMENT = '_AFC_RENAMED_{}_'.format(self.BASE_UNLOAD_FILAMENT)\n\n        self.afcDeltaTime = afcDeltaTime(self)\n\n        # Register AFC macros\n        self.show_macros = config.getboolean('show_macros',\n                                             True)  # Show internal python AFC_ macros in the web interfaces (Mainsail/Fluidd)\n\n        self.function.register_commands(self.show_macros, 'AFC_STATS', self.cmd_AFC_STATS, self.cmd_AFC_STATS_help,\n                                        self.cmd_AFC_STATS_options)\n        self.function.register_commands(self.show_macros, 'AFC_QUIET_MODE', self.cmd_AFC_QUIET_MODE,\n                                        self.cmd_AFC_QUIET_MODE_help, self.cmd_AFC_QUIET_MODE_options)\n        self.function.register_commands(self.show_macros, 'AFC_STATUS', self.cmd_AFC_STATUS,\n                                        self.cmd_AFC_STATUS_help)\n        self.function.register_commands(self.show_macros, 'TURN_ON_AFC_LED', self.cmd_TURN_ON_AFC_LED,\n                                        self.cmd_TURN_ON_AFC_LED_help)\n        self.function.register_commands(self.show_macros, 'TURN_OFF_AFC_LED', self.cmd_TURN_OFF_AFC_LED,\n                                        self.cmd_TURN_OFF_AFC_LED_help)\n        self.function.register_commands(self.show_macros, 'AFC_CHANGE_BLADE', self.cmd_AFC_CHANGE_BLADE,\n                                        self.cmd_AFC_CHANGE_BLADE_help)\n        self.function.register_commands(self.show_macros, 'AFC_TOGGLE_MACRO', self.cmd_AFC_TOGGLE_MACRO,\n                                        self.cmd_AFC_TOGGLE_MACRO_help, self.cmd_AFC_TOGGLE_MACRO_options)\n        self.function.register_commands(self.show_macros, 'UNSET_LANE_LOADED', self.cmd_UNSET_LANE_LOADED,\n                                        self.cmd_UNSET_LANE_LOADED_help)\n\n    def _remove_after_last(self, string, char):\n        last_index = string.rfind(char)\n        if last_index != -1:\n            return string[:last_index + 1]\n        else:\n            return string\n\n    def _update_trsync(self, config):\n        # Logic to update trsync values\n        update_trsync = config.getboolean(\"trsync_update\", False)                   # Set to true to enable updating trsync value in klipper mcu. Enabling this and updating the timeouts can help with Timer Too Close(TTC) errors\n        if update_trsync:\n            try:\n                import mcu\n                trsync_value = config.getfloat(\"trsync_timeout\", 0.05)              # Timeout value to update in klipper mcu. Klipper's default value is 0.025\n                trsync_single_value = config.getfloat(\"trsync_single_timeout\", 0.5) # Single timeout value to update in klipper mcu. Klipper's default value is 0.250\n                self.logger.info(\"Applying TRSYNC update\")\n\n                # Making sure value exists as kalico(danger klipper) does not have TRSYNC_TIMEOUT value\n                if hasattr(mcu, \"TRSYNC_TIMEOUT\"): mcu.TRSYNC_TIMEOUT = max(mcu.TRSYNC_TIMEOUT, trsync_value)\n                else : self.logger.info(\"TRSYNC_TIMEOUT does not exist in mcu file, not updating\")\n\n                if hasattr(mcu, \"TRSYNC_SINGLE_MCU_TIMEOUT\"): mcu.TRSYNC_SINGLE_MCU_TIMEOUT = max(mcu.TRSYNC_SINGLE_MCU_TIMEOUT, trsync_single_value)\n                else : self.logger.info(\"TRSYNC_SINGLE_MCU_TIMEOUT does not exist in mcu file, not updating\")\n            except Exception as e:\n                self.logger.info(\"Unable to update TRSYNC_TIMEOUT: {}\".format(e))\n\n    def register_config_callback(self, option):\n        # Function needed for virtual pins, does nothing\n        return\n\n    def register_lane_macros(self, lane_obj):\n        \"\"\"\n        Callback function to register macros with proper lane names so that klipper errors out correctly when users supply lanes that\n        are not valid\n\n        :param lane_obj: object for lane to register\n        \"\"\"\n        self.gcode.register_mux_command('LANE_MOVE',    \"LANE\", lane_obj.name, self.cmd_LANE_MOVE,      desc=self.cmd_LANE_MOVE_help)\n        self.gcode.register_mux_command('LANE_UNLOAD',  \"LANE\", lane_obj.name, self.cmd_LANE_UNLOAD,    desc=self.cmd_LANE_UNLOAD_help)\n        self.gcode.register_mux_command('HUB_LOAD',     \"LANE\", lane_obj.name, self.cmd_HUB_LOAD,       desc=self.cmd_HUB_LOAD_help)\n        self.gcode.register_mux_command('TOOL_LOAD',    \"LANE\", lane_obj.name, self.cmd_TOOL_LOAD,      desc=self.cmd_TOOL_LOAD_help)\n\n    def handle_moonraker_connect(self):\n        \"\"\"\n        Function that should be called at the beginning of PREP so that moonraker has\n        enough time to start before AFC tries to connect. This fixes a race condition that can\n        happen between klipper and moonraker when first starting up.\n        \"\"\"\n\n        try:\n            self.moonraker = AFC_moonraker( self.moonraker_host, self.moonraker_port, self.logger )\n            if not self.moonraker.wait_for_moonraker( toolhead=self.toolhead, timeout=self.moonraker_connect_to ):\n                return False\n            self.spoolman = self.moonraker.get_spoolman_server()\n            self.afc_stats = AFCStats(self.moonraker, self.logger, self.tool_cut_threshold)\n        except Exception as e:\n            self.logger.debug(\"Moonraker/Spoolman/afc_stats error: {}\\n{}\".format(e, traceback.format_exc()))\n            self.spoolman = None                      # set to none if not found\n        return True\n\n    def handle_connect(self):\n        \"\"\"\n        Handle the connection event.\n        This function is called when the printer connects. It looks up the toolhead object\n        and assigns it to the instance variable `self.toolhead`.\n        \"\"\"\n        self.toolhead   = self.printer.lookup_object('toolhead')\n        self.idle       = self.printer.lookup_object('idle_timeout')\n        self.gcode_move = self.printer.lookup_object('gcode_move')\n\n        # Check if hardware bypass is configured, if not create a virtual bypass sensor\n        try:\n            self.bypass = self.printer.lookup_object('filament_switch_sensor bypass').runout_helper\n        except:\n            self.bypass = add_filament_switch(\"virtual_bypass\", \"afc_virtual_bypass:virtual_bypass\", self.printer ).runout_helper\n\n        if self.show_quiet_mode:\n            self.quiet_switch = add_filament_switch(\"quiet_mode\", \"afc_quiet_mode:afc_quiet_mode\", self.printer ).runout_helper\n\n        # Register G-Code commands for macros we don't want to show up in mainsail/fluidd\n        self.gcode.register_command('TOOL_UNLOAD',          self.cmd_TOOL_UNLOAD,           desc=self.cmd_TOOL_UNLOAD_help)\n        self.gcode.register_command('CHANGE_TOOL',          self.cmd_CHANGE_TOOL,           desc=self.cmd_CHANGE_TOOL_help)\n        self.gcode.register_command('SET_AFC_TOOLCHANGES',  self.cmd_SET_AFC_TOOLCHANGES,   desc=self.cmd_SET_AFC_TOOLCHANGES_help)\n        self.gcode.register_command('AFC_CLEAR_MESSAGE',    self.cmd_AFC_CLEAR_MESSAGE,     desc=self.cmd_AFC_CLEAR_MESSAGE_help)\n        self.gcode.register_command('_AFC_TEST_MESSAGES',   self.cmd__AFC_TEST_MESSAGES,    desc=self.cmd__AFC_TEST_MESSAGES_help)\n        self.current_state = State.IDLE\n\n    def print_version(self, console_only=False):\n        \"\"\"\n        Calculated AFC git version and displays to console and log\n        \"\"\"\n        import subprocess\n        import os\n        afc_dir  = os.path.dirname(os.path.realpath(__file__))\n        git_hash = subprocess.check_output(['git', '-C', '{}'.format(afc_dir), 'rev-parse', '--short', 'HEAD']).decode('ascii').strip()\n        git_commit_num = subprocess.check_output(['git', '-C', '{}'.format(afc_dir), 'rev-list', 'HEAD', '--count']).decode('ascii').strip()\n        string  = \"AFC Version: v{}-{}-{}\".format(AFC_VERSION, git_commit_num, git_hash)\n\n        self.logger.info(string, console_only)\n\n    def _reset_file_callback(self):\n        \"\"\"\n        Set timer to check back to see if printer is printing. This is needed as file and print status is set after\n        this callback.\n\n        AFC errors are also reset as well as pause states are cleared in klipper's pause_resume module\n        \"\"\"\n        self.in_print_timer = self.reactor.register_timer( self.in_print_reactor_timer, self.reactor.monotonic() + 5 )\n        self.error.reset_failure()\n        self.gcode.run_script_from_command(\"CLEAR_PAUSE\")\n        self.number_of_toolchanges = 0\n        self.current_toolchange    = -1\n        self.save_vars()\n\n    def in_print_reactor_timer(self, eventtime):\n        \"\"\"\n        Print timer callback to check if printer is currently in a print. If printer is in a print,\n        current filename is looked up and metadata is pulled from moonraker to get total filament change\n        count. Once this is done timer callback is stopped and unregistered.\n        \"\"\"\n        # Remove timer from reactor\n        self.reactor.unregister_timer(self.in_print_timer)\n        # Check to see if printer is printing and return filament\n        in_print, print_filename = self.function.in_print(return_file=True)\n        self.logger.debug(\"In print: {}, Filename: {}\".format(in_print, print_filename))\n        if in_print:\n            # Gather file filament change count from moonraker\n            self.number_of_toolchanges  = self.moonraker.get_file_filament_change_count(print_filename)\n            self.current_toolchange     = -1 # Reset\n            self.logger.info(\"Total number of toolchanges set to {}\".format(self.number_of_toolchanges))\n\n        return self.reactor.NEVER\n\n    def _get_default_material_temps(self, cur_lane):\n        \"\"\"\n        Helper function to get material temperatures\n\n        Defaults to min extrude temperature + 5 if nothing is found.\n\n        Returns value that user has inputted if using spoolman, or tries to parse manually entered values\n        in AFC.cfg and sees if a temperature exists for filament material.\n\n        :param cur_lane: Current lane object\n        :return tuple : float for temperature to heat extruder to,\n                         bool True if user is using min_extruder_temp value\n        \"\"\"\n        try:\n            # Try to get default value from list, if it does not exist then default to min_extrude_temp + 5\n            temp_value = [val for val in self.default_material_temps if 'default' in val][0].split(\":\")[1]\n        except:\n            temp_value = self.heater.min_extrude_temp + 5\n\n        using_min_value = True  # Set it true if default temp/spoolman temps are not being used\n        if cur_lane.extruder_temp is not None:\n            temp_value = cur_lane.extruder_temp\n            using_min_value = False\n        elif self.default_material_temps is not None and cur_lane.material is not None:\n            lane_material = str(cur_lane.material).strip().lower()\n            for mat in self.default_material_temps:\n                m = mat.split(\":\")\n                mat_key = m[0].strip().lower()\n                # Use substring match for material name (case-insensitive, ignore whitespace)\n                if mat_key in lane_material:\n                    temp_value = m[1]\n                    using_min_value = False\n                    break\n        return float(temp_value), using_min_value\n\n    def _check_extruder_temp(self, cur_lane):\n        \"\"\"\n        Helper function that check to see if extruder needs to be heated, and wait for hotend to get to temp if needed\n        \"\"\"\n\n        # Prepare extruder and heater.\n        # This will need to be done a different way for multiple toolhead extruders\n        extruder = self.toolhead.get_extruder()\n        self.heater = extruder.get_heater()\n        pheaters = self.printer.lookup_object('heaters')\n        wait = False\n\n        # If extruder can extrude and printing return and do not update temperature, don't want to modify extruder temperature during prints\n        if self.heater.can_extrude and self.function.is_printing():\n            return\n        target_temp, using_min_value = self._get_default_material_temps(cur_lane)\n\n        current_temp = self.heater.get_temp(self.reactor.monotonic())\n\n        # Check if the current temp is below the set temp, if it is heat to set temp\n        if current_temp[0] < (self.heater.target_temp-5):\n            wait = False\n            pheaters.set_temperature(extruder.get_heater(), current_temp[0], wait=wait)\n            self.logger.info('Current temp {:.1f} is below set temp {}'.format(current_temp[0], target_temp))\n\n        # Check to make sure temp is with +/-5 of target temp, not setting if temp is over target temp and using min_extrude_temp value\n        if self.heater.target_temp <= (target_temp-5) or (self.heater.target_temp >= (target_temp+5) and not using_min_value):\n            wait = False if self.heater.target_temp >= (target_temp+5) else True\n\n            self.logger.info('Setting extruder temperature to {} {}'.format(target_temp, \"and waiting for extruder to reach temperature\" if wait else \"\"))\n            pheaters.set_temperature(extruder.get_heater(), target_temp, wait=wait)\n\n        return wait\n\n    def _set_quiet_mode(self, val):\n        \"\"\"\n        Helper function to set quiet mode to on or off\n\n        :param val: on or off switch\n        \"\"\"\n        if self.show_quiet_mode:\n            self.quiet_switch.sensor_enabled = val\n            self.quiet_switch.filament_present = val\n        else:\n            self.quiet_mode = val\n\n    def _get_quiet_mode(self):\n        \"\"\"\n        Helper function to return if quiet is on or off\n\n        :return Returns current state of quiet switch\n        \"\"\"\n        if self.show_quiet_mode:\n            try:\n                state = self.quiet_switch.sensor_enabled\n                self.quiet_switch.filament_present = state\n                return state\n            except:\n                return False\n        else:\n            return self.quiet_mode\n\n    def _get_bypass_state(self):\n        \"\"\"\n        Helper function to return if filament is present in bypass sensor\n\n        :return Returns current state of bypass sensor. If bypass sensor does not exist, always returns False\n        \"\"\"\n        bypass_state = False\n\n        try:\n            if 'virtual' in self.bypass.name:\n                bypass_state = self.bypass.sensor_enabled\n\n                # Make sure lane is not loaded before enabling virtual bypass, force switch\n                # to disabled if a lane is loaded\n                if bypass_state and self.current is not None:\n                    self.logger.error(f\"Cannot set virtual bypass, {self.current} is currently loaded.\")\n                    self.bypass.sensor_enabled = False\n                    return False\n\n                # Update filament present to match enable button so it updates in guis\n                self.bypass.filament_present = bypass_state\n\n                if self.bypass_last_state != bypass_state:\n                    self.bypass_last_state = bypass_state\n                    self.save_vars()\n\n            else:\n                bypass_state = self.bypass.filament_present\n        except:\n            pass\n\n        return bypass_state\n\n    def _check_bypass(self, unload=False):\n        \"\"\"\n        Helper function that checks if bypass has filament loaded\n\n        :param unload: Set True if user is trying to unload, when set to True and filament is loaded AFC runs users renamed stock UNLOAD_FILAMENT macro\n        :return        Returns true if filament is present in sensor\n        \"\"\"\n        try:\n            if self._get_bypass_state():\n                if unload:\n                    self.logger.info(\"Bypass detected, calling manual unload filament routine\")\n                    self.gcode.run_script_from_command(self.RENAMED_UNLOAD_FILAMENT)\n                    self.logger.info(\"Filament unloaded\")\n                else:\n                    msg = \"Filament loaded in bypass, not doing tool load\"\n                    # If printing report as error, only pause if in a print and bypass_pause variable is True\n                    self.error.AFC_error(msg, pause= (self.function.in_print() and self.bypass_pause), level=2)\n                return True\n        except:\n            pass\n        return False\n\n    cmd_AFC_TOGGLE_MACRO_help = \"Enable/disable TOOL_CUT/PARK/POOP/KICK/WIPE/FORM_TIP macros\"\n    cmd_AFC_TOGGLE_MACRO_options = {\"TOOL_CUT\": {\"type\": \"int\", \"default\": 0},\n                                    \"PARK\": {\"type\": \"int\", \"default\": 0},\n                                    \"POOP\": {\"type\": \"int\", \"default\": 0},\n                                    \"KICK\": {\"type\": \"int\", \"default\": 0},\n                                    \"WIPE\": {\"type\": \"int\", \"default\": 0},\n                                    \"FORM_TIP\": {\"type\": \"int\", \"default\": 0}}\n    def cmd_AFC_TOGGLE_MACRO(self, gcmd):\n        \"\"\"\n        Enable/disable TOOL_CUT/PARK/POOP/KICK/WIPE/FORM_TIP macros.\n\n        Usage\n        -------\n        `AFC_TOGGLE_MACRO TOOL_CUT=<0/1> PARK=<0/1> POOP=<0/1> KICK=<0/1> WIPE=<0/1> FORM_TIP=<0/1> `\n\n        Example\n        -------\n        ```\n        AFC_TOGGLE_MACRO TOOL_CUT=0\n        ```\n        \"\"\"\n        self.tool_cut = bool(gcmd.get_int(\"TOOL_CUT\", self.tool_cut, minval=0, maxval=1))\n        self.park = bool(gcmd.get_int(\"PARK\", self.park, minval=0, maxval=1))\n        self.kick = bool(gcmd.get_int(\"KICK\", self.kick, minval=0, maxval=1))\n        self.poop = bool(gcmd.get_int(\"POOP\", self.poop, minval=0, maxval=1))\n        self.wipe = bool(gcmd.get_int(\"WIPE\", self.wipe, minval=0, maxval=1))\n        self.form_tip = bool(gcmd.get_int(\"FORM_TIP\", self.form_tip, minval=0, maxval=1))\n\n        self.logger.info(\"Tool Cut {}, Park {}\".format(self.tool_cut, self.park))\n        self.logger.info(\"Kick {}, Poop {}\".format(self.kick, self.poop))\n        self.logger.info(\"Wipe {}, Form tip {}\".format(self.tool_cut, self.form_tip))\n\n    cmd_AFC_QUIET_MODE_help = \"Set quiet mode speed and enable/disable quiet mode\"\n    cmd_AFC_QUIET_MODE_options = {\"SPEED\": {\"type\": \"float\", \"default\": 50},\n                                  \"ENABLE\": {\"type\": \"int\", \"default\": 0}}\n    def cmd_AFC_QUIET_MODE(self, gcmd):\n        \"\"\"\n        Set lower speed on any filament moves.\n\n        Mainly this would be used to turn down motor noise during late quiet runs. Only exceptions are during bowden calibration and lane reset, which are manually triggered\n\n        Usage\n        -------\n        `AFC_QUIET_MODE SPEED=<new quietmode speed> ENABLE=<1 or 0>`\n\n        Example\n        -------\n        ```\n        AFC_QUIET_MODE SPEED=75 ENABLE=1\n        ```\n        \"\"\"\n        self._set_quiet_mode(bool(gcmd.get_int(\"ENABLE\", self._get_quiet_mode(), minval=0, maxval=1)))\n        self.quiet_moves_speed = gcmd.get_float(\"SPEED\", self.quiet_moves_speed, minval=10, maxval=400)\n        self.logger.info(\"QuietMode {}, max speed of {} mm/sec\".format(self._get_quiet_mode(), self.quiet_moves_speed))\n\n    cmd_UNSET_LANE_LOADED_help = \"Removes active lane loaded from toolhead loaded status\"\n    def cmd_UNSET_LANE_LOADED(self, gcmd):\n        \"\"\"\n        Unsets the current lane from AFC loaded status.\n\n        Mainly this would be used if AFC thinks that there is a lane loaded into the toolhead but nothing is actually\n        loaded.\n\n        Usage\n        -------\n        `UNSET_LANE_LOADED`\n\n        Example\n        -------\n        ```\n        UNSET_LANE_LOADED\n        ```\n        \"\"\"\n        self.function.unset_lane_loaded()\n\n    cmd_SET_AFC_TOOLCHANGES_help = \"Sets number of toolchanges for AFC to keep track of\"\n    def cmd_SET_AFC_TOOLCHANGES(self, gcmd):\n        \"\"\"\n        This macro can be used to set the total number of tool changes from the slicer. AFC will keep track of tool changes and print out\n        the current tool change number when a T(n) command is called from G-code.\n\n        The following call can be added to the slicer by adding the following lines to the Change filament G-code section in your slicer.\n\n        You may already have `T[next_extruder]`, just make sure the tool change call is after your T(n) call:\n\n        `T[next_extruder] { if toolchange_count == 1 }SET_AFC_TOOLCHANGES TOOLCHANGES=[total_toolchanges]{endif }`\n\n        The following can also be added to your `PRINT_END` section in your slicer to set the number of tool changes back to zero:\n\n        `SET_AFC_TOOLCHANGES TOOLCHANGES=0`\n\n        Usage\n        -----\n        `SET_AFC_TOOLCHANGES TOOLCHANGES=<number>`\n\n        Example\n        -------\n        ```\n        SET_AFC_TOOLCHANGES TOOLCHANGES=100\n        ```\n\n        \"\"\"\n        number_of_toolchanges  = gcmd.get_int(\"TOOLCHANGES\")\n        if number_of_toolchanges > 0:\n            warning_text  = \"Please remove SET_AFC_TOOLCHANGES from your slicers 'Change Filament G-Code' section as SET_AFC_TOOLCHANGES \"\n            warning_text += \"is now deprecated and number of toolchanges will be fetched from files metadata in moonraker when a print starts.\\n\"\n            warning_text += \"Verify that moonrakers version is at least v0.9.3-64 to utilize this feature.\"\n            self.logger.info(f\"<span class=warning--text>{warning_text}</span>\")\n            self.message_queue.append((warning_text, \"warning\"))\n\n    cmd_LANE_MOVE_help = \"Lane Manual Movements\"\n    cmd_LANE_MOVE_options = {\"LANE\": {\"type\": \"string\", \"default\": \"lane1\"}, \"DISTANCE\": {\"type\": \"int\", \"default\": 20}}\n    def cmd_LANE_MOVE(self, gcmd):\n        \"\"\"\n        This function handles the manual movement of a specified lane. It retrieves the lane\n        specified by the 'LANE' parameter and moves it by the distance specified by the 'DISTANCE' parameter.\n\n        Distance's lower than 200 moves extruder at short_move_speed/accel, values above 200 move extruder at long_move_speed/accel\n\n        Usage\n        -----\n        `LANE_MOVE LANE=<lane> DISTANCE=<distance>`\n\n        Example\n        -----\n        ```\n        LANE_MOVE LANE=lane1 DISTANCE=100\n        ```\n        \"\"\"\n        if self.function.is_printing():\n            self.error.AFC_error(\"Cannot move lane while printer is printing\", pause=False)\n            return\n        lane = gcmd.get('LANE', None)\n        distance = gcmd.get_float('DISTANCE', 0)\n        if lane not in self.lanes:\n            self.logger.info('{} Unknown'.format(lane))\n            return\n        cur_lane = self.lanes[lane]\n        self.current_state = State.MOVING_LANE\n\n        speed_mode = SpeedMode.SHORT\n        if abs(distance) >= 200: speed_mode = SpeedMode.LONG\n\n        cur_lane.set_load_current() # Making current is set correctly when doing lane moves\n        cur_lane.do_enable(True)\n        cur_lane.move_advanced(distance, speed_mode, assist_active = AssistActive.YES)\n        cur_lane.do_enable(False)\n        self.current_state = State.IDLE\n        cur_lane.unit_obj.return_to_home()\n        # Put CAM back to lane if its loaded to toolhead\n        self.function.select_loaded_lane()\n\n    def _get_resume_speed(self):\n        \"\"\"\n        Common function for return resume speed\n        \"\"\"\n        return self.resume_speed if self.resume_speed > 0 else self.speed\n\n    def _get_resume_speedz(self):\n        \"\"\"\n        Common function for return resume z speed\n        \"\"\"\n        return self.resume_z_speed if self.resume_z_speed > 0 else self.speed\n\n    def move_z_pos(self, z_amount, string=\"\", wait_moves=False):\n        \"\"\"\n        Common function helper to move z, also does a check for max z so toolhead does not exceed max height\n\n        :param z_amount: amount to add to the base position\n        :param string: String to write to log, this can be used\n        :param wait_moves: Set to True to wait on toolhead moves to finish before moving on\n\n        :return newpos: Position list with updated z position\n        \"\"\"\n        max_z = self.toolhead.get_status(0)['axis_maximum'][2]\n        newpos = self.gcode_move.last_position\n\n        # Determine z movement, get the min value to not exceed max z movement\n        newpos[2] = min(max_z - 1, z_amount)\n\n        self.gcode_move.move_with_transform(newpos, self._get_resume_speedz())\n\n        if wait_moves:\n            self.toolhead.wait_moves()\n\n        self.function.log_toolhead_pos(f\"move_z_pos({string}): \")\n\n        return newpos[2]\n\n    def move_e_pos( self, e_amount, speed, log_string=\"\", wait_tool=False):\n        \"\"\"\n        Common function helper to move extruder position\n\n        :param e_amount: Amount to move extruder either positive(extruder) or negative(retract)\n        :param speed: Speed to perform move at\n        :param log_string: Additional string or name to log to logger when recording toolhead position in log\n        :param wait_tool: Set to True to wait on toolhead moves\n        \"\"\"\n        newpos = self.gcode_move.last_position\n        newpos[3] += e_amount\n\n        self.gcode_move.move_with_transform(newpos, speed)\n\n        if wait_tool: self.toolhead.wait_moves()\n\n    def save_pos(self):\n        \"\"\"\n        Only save previous location on the first toolchange call to keep an error state from overwriting the location\n        \"\"\"\n        if not self.in_toolchange:\n            if not self.error_state and not self.function.is_paused() and not self.position_saved:\n                self.position_saved         = True\n                self.last_toolhead_position = self.toolhead.get_position()\n                self.base_position          = list(self.gcode_move.base_position)\n                self.last_gcode_position    = list(self.gcode_move.last_position)\n                self.homing_position        = list(self.gcode_move.homing_position)\n                self.speed                  = self.gcode_move.speed\n                self.speed_factor           = self.gcode_move.speed_factor\n                self.absolute_coord         = self.gcode_move.absolute_coord\n                self.absolute_extrude       = self.gcode_move.absolute_extrude\n                self.extrude_factor         = self.gcode_move.extrude_factor\n                msg = \"Saving position {}\".format(self.last_toolhead_position)\n                msg += \" Base position: {}\".format(self.base_position)\n                msg += \" last_gcode_position: {}\".format(self.last_gcode_position)\n                msg += \" homing_position: {}\".format(self.homing_position)\n                msg += \" speed: {}\".format(self.speed)\n                msg += \" speed_factor: {}\".format(self.speed_factor)\n                msg += \" absolute_coord: {}\".format(self.absolute_coord)\n                msg += \" absolute_extrude: {}\".format(self.absolute_extrude)\n                msg += \" extrude_factor: {}\\n\".format(self.extrude_factor)\n                self.logger.debug(msg)\n            else:\n                self.function.log_toolhead_pos(\"Not Saving, Error State: {}, Is Paused {}, Position_saved {}, POS: \".format(self.error_state, self.function.is_paused(), self.position_saved))\n        else:\n            self.function.log_toolhead_pos(\"Not Saving In a toolchange, Error State: {}, Is Paused {}, Position_saved {}, in toolchange: {}, POS: \".format(\n                self.error_state, self.function.is_paused(), self.position_saved, self.in_toolchange ))\n\n    def restore_pos(self, move_z_first=True):\n        \"\"\"\n        restore_pos function restores the previous saved position, speed and coord type. The resume uses\n        the z_hop value to lift, move to previous x,y coords, then lower to saved z position.\n\n        :param move_z_first: Enable to move z before moving x,y\n        \"\"\"\n        msg = \"Restoring Position {}\".format(self.last_toolhead_position)\n        msg += \" Base position: {}\".format(self.base_position)\n        msg += \" last_gcode_position: {}\".format(self.last_gcode_position)\n        msg += \" homing_position: {}\".format(self.homing_position)\n        msg += \" speed: {}\".format(self.speed)\n        msg += \" speed_factor: {}\".format(self.speed_factor)\n        msg += \" absolute_coord: {}\".format(self.absolute_coord)\n        msg += \" absolute_extrude: {}\".format(self.absolute_extrude)\n        msg += \" extrude_factor: {}\\n\".format(self.extrude_factor)\n        self.logger.debug(msg)\n        self.function.log_toolhead_pos(\"Resume initial pos: \")\n\n        self.current_state = State.RESTORING_POS\n        newpos = self.gcode_move.last_position\n\n        # Move toolhead to previous z location with z-hop added\n        if move_z_first:\n            newpos[2] = self.move_z_pos(self.last_gcode_position[2] + self.z_hop, \"restore_pos\")\n\n        # Move to previous x,y location\n        newpos[:2] = self.last_gcode_position[:2]\n        self.gcode_move.move_with_transform(newpos, self._get_resume_speed() )\n        self.function.log_toolhead_pos(\"Resume prev xy: \")\n\n        # Update GCODE STATE variables\n        self.gcode_move.base_position       = list(self.base_position)\n        self.gcode_move.homing_position     = list(self.homing_position)\n\n        # Restore absolute coords\n        self.gcode_move.absolute_coord      = self.absolute_coord\n        self.gcode_move.absolute_extrude    = self.absolute_extrude\n        self.gcode_move.extrude_factor      = self.extrude_factor\n        self.gcode_move.speed               = self.speed\n        self.gcode_move.speed_factor        = self.speed_factor\n\n        # Restore the relative E position\n        e_diff = self.gcode_move.last_position[3] - self.last_gcode_position[3]\n        self.gcode_move.base_position[3] += e_diff\n        self.gcode_move.last_position[:3] = self.last_gcode_position[:3]\n\n        # Return to previous xyz\n        self.gcode_move.move_with_transform(self.gcode_move.last_position, self._get_resume_speedz() )\n        self.function.log_toolhead_pos(\"Resume final z, Error State: {}, Is Paused {}, Position_saved {}, in toolchange: {}, POS: \".format(self.error_state, self.function.is_paused(), self.position_saved, self.in_toolchange))\n\n        self.current_state = State.IDLE\n        self.position_saved = False\n\n    def save_vars(self):\n        \"\"\"\n        save_vars function saves lane variables to var file and prints with indents to\n                  make it more readable for users\n        \"\"\"\n\n        # Return early if prep is not done so that file is not overridden until prep is at least done\n        if not self.prep_done: return\n        str = {}\n        for UNIT in self.units.keys():\n            cur_unit=self.units[UNIT]\n            str[cur_unit.name]={}\n            name=[]\n            for NAME in cur_unit.lanes:\n                cur_lane=self.lanes[NAME]\n                str[cur_unit.name][cur_lane.name]=cur_lane.get_status(save_to_file=True)\n                name.append(cur_lane.name)\n\n        str[\"system\"]={}\n        str[\"system\"]['current_load']= self.current\n        str[\"system\"]['num_units'] = len(self.units)\n        str[\"system\"]['num_lanes'] = len(self.lanes)\n        str[\"system\"]['num_extruders'] = len(self.tools)\n        str[\"system\"][\"extruders\"]={}\n        str[\"system\"][\"bypass\"] = {\"enabled\": self._get_bypass_state() }\n\n        for extrude in self.tools.keys():\n            cur_extruder = self.tools[extrude]\n            str[\"system\"][\"extruders\"][cur_extruder.name]={}\n            str[\"system\"][\"extruders\"][cur_extruder.name]['lane_loaded'] = cur_extruder.lane_loaded\n\n        try:\n            with open(self.VarFile+ '.unit', 'w') as f:\n                f.write(json.dumps(str, indent=4))\n        except Exception as e:\n            self.logger.error(\"Error happened when trying to save variables, check AFC.log for error\")\n            self.logger.debug(f\"Error:{e}\\n{traceback.format_exc()}\", only_debug=True)\n\n    # HUB COMMANDS\n    cmd_HUB_LOAD_help = \"Load lane into hub\"\n    def cmd_HUB_LOAD(self, gcmd):\n        \"\"\"\n        This function handles the loading of a specified lane into the hub. It performs\n        several checks and movements to ensure the lane is properly loaded.\n\n        Usage\n        -----\n        `HUB_LOAD LANE=<lane>`\n\n        Example\n        -----\n        ```\n        HUB_LOAD LANE=lane1\n        ```\n        \"\"\"\n\n        if self.function.is_printing():\n            self.error.AFC_error(\"Cannot load lane to hub while printer is printing\", pause=False)\n            return\n\n        lane = gcmd.get('LANE', None)\n        if lane not in self.lanes:\n            self.logger.info('{} Unknown'.format(lane))\n            return\n        cur_lane = self.lanes[lane]\n        cur_hub = cur_lane.hub_obj\n        if not cur_lane.prep_state: return\n        cur_lane.status = AFCLaneState.HUB_LOADING\n        if not cur_lane.load_state:\n            cur_lane.do_enable(True)\n            while not cur_lane.load_state:\n                cur_lane.move_advanced( cur_hub.move_dis, SpeedMode.SHORT)\n        if not cur_lane.loaded_to_hub:\n            cur_lane.move_advanced(cur_lane.dist_hub, SpeedMode.HUB, assist_active = AssistActive.DYNAMIC)\n        while not cur_hub.state:\n            cur_lane.move_advanced(cur_hub.move_dis, SpeedMode.SHORT)\n        while cur_hub.state:\n            cur_lane.move_advanced(cur_hub.move_dis * -1, SpeedMode.SHORT)\n        cur_lane.status = AFCLaneState.NONE\n        cur_lane.do_enable(False)\n        cur_lane.loaded_to_hub = True\n        self.save_vars()\n        cur_lane.unit_obj.return_to_home()\n        # Put CAM back to lane if its loaded to toolhead\n        self.function.select_loaded_lane()\n\n    cmd_LANE_UNLOAD_help = \"Unload lane from extruder\"\n    def cmd_LANE_UNLOAD(self, gcmd):\n        \"\"\"\n        This function handles the unloading of a specified lane from the extruder. It performs\n        several checks and movements to ensure the lane is properly unloaded.\n\n        Usage\n        -----\n        `LANE_UNLOAD LANE=<lane>`\n\n        Example\n        -----\n        ```\n        LANE_UNLOAD LANE=lane1\n        ```\n\n        \"\"\"\n        if self.function.is_printing():\n            self.error.AFC_error(\"Cannot eject lane while printer is printing\", pause=False)\n            return\n\n        lane = gcmd.get('LANE', None)\n        if lane not in self.lanes:\n            self.logger.info('{} Unknown'.format(lane))\n            return\n        cur_lane = self.lanes[lane]\n        self.LANE_UNLOAD( cur_lane )\n\n    def LANE_UNLOAD(self, cur_lane):\n        cur_hub = cur_lane.hub_obj\n\n        self.current_state = State.EJECTING_LANE\n\n        if cur_lane.name != self.current and cur_lane.hub != 'direct':\n            # Setting status as ejecting so if filament is removed and de-activates the prep sensor while\n            # extruder motors are still running it does not trigger infinite spool or pause logic\n            # once user removes filament lanes status will go to None\n            cur_lane.status = AFCLaneState.EJECTING\n            self.save_vars()\n            cur_lane.do_enable(True)\n            if cur_lane.loaded_to_hub:\n                cur_lane.move_advanced(cur_lane.dist_hub * -1, SpeedMode.HUB, assist_active = AssistActive.DYNAMIC)\n            cur_lane.loaded_to_hub = False\n            while cur_lane.load_state:\n                cur_lane.move_advanced(cur_hub.move_dis * -1, SpeedMode.SHORT, assist_active = AssistActive.YES)\n            cur_lane.move_advanced(cur_hub.move_dis * -5, SpeedMode.SHORT)\n            cur_lane.do_enable(False)\n            cur_lane.status = AFCLaneState.NONE\n            cur_lane.unit_obj.return_to_home()\n            # Put CAM back to lane if its loaded to toolhead\n            self.function.select_loaded_lane()\n            self.save_vars()\n\n            # Removing spool from vars since it was ejected\n            self.spool.set_spoolID(cur_lane, \"\")\n            self.logger.info(\"LANE {} eject done\".format(cur_lane.name))\n            self.function.afc_led(cur_lane.led_not_ready, cur_lane.led_index)\n\n        elif cur_lane.name == self.current:\n            self.logger.info(\"LANE {} is loaded in toolhead, can't unload.\".format(cur_lane.name))\n\n        elif cur_lane.hub == 'direct':\n            self.logger.info(\"LANE {} is a direct lane must be tool unloaded.\".format(cur_lane.name))\n\n        self.current_state = State.IDLE\n\n    cmd_TOOL_LOAD_help = \"Load lane into tool\"\n    def cmd_TOOL_LOAD(self, gcmd):\n        \"\"\"\n        This function handles the loading of a specified lane into the tool. It retrieves\n        the lane specified by the 'LANE' parameter and calls the TOOL_LOAD method to perform\n        the loading process.\n\n        Optionally setting PURGE_LENGTH parameter to pass a value into poop macro.\n\n        Usage\n        -----\n        `TOOL_LOAD LANE=<lane> PURGE_LENGTH=<purge_length>(optional value)`\n\n        Example\n        -----\n        ```\n        TOOL_LOAD LANE=lane1 PURGE_LENGTH=80\n        ```\n        \"\"\"\n        self.afcDeltaTime.set_start_time()\n        lane = gcmd.get('LANE', None)\n        if lane not in self.lanes:\n            self.logger.info('{} Unknown'.format(lane))\n            return\n\n        if self.current is not None:\n            self.error.AFC_error(\"Cannot load {}, {} currently loaded\".format(lane, self.current), pause=self.function.in_print())\n            return\n\n        purge_length = gcmd.get('PURGE_LENGTH', None)\n        cur_lane = self.lanes[lane]\n        self.TOOL_LOAD(cur_lane, purge_length)\n\n    def TOOL_LOAD(self, cur_lane, purge_length=None):\n        \"\"\"\n        This function handles the loading of a specified lane into the tool. It performs\n        several checks and movements to ensure the lane is properly loaded.\n\n        :param cur_lane: The lane object to be loaded into the tool.\n        :param purge_length: Amount of filament to poop (optional).\n\n        :return bool: True if load was successful, False if an error occurred.\n        \"\"\"\n        if not self.function.check_homed():\n            return False\n\n        if cur_lane is None:\n            self.error.AFC_error(\"No lane provided to load, not loading any lane.\", pause=self.function.in_print())\n            # Exit early if no lane is provided.\n            return False\n\n        # Check if the bypass filament sensor is triggered; abort loading if filament is already present.\n        if self._check_bypass(): return False\n\n        # Lookup extruder and hub objects associated with the lane.\n        cur_hub = cur_lane.hub_obj\n\n        # Check if the lane is in a state ready to load and hub is clear.\n        if (cur_lane.load_state and not cur_hub.state) or cur_lane.hub == 'direct':\n\n            self.logger.info(\"Loading {}\".format(cur_lane.name))\n\n            # Verify that printer is in absolute mode\n            self.function.check_absolute_mode(\"TOOL_LOAD\")\n\n\n            cur_extruder = cur_lane.extruder_obj\n            self.current_state = State.LOADING\n            self.current_loading = cur_lane.name\n\n            # Set the lane status to 'loading' and activate the loading LED.\n            cur_lane.status = AFCLaneState.TOOL_LOADING\n            self.save_vars()\n            cur_lane.unit_obj.lane_loading( cur_lane )\n\n            if self._check_extruder_temp(cur_lane):\n                self.afcDeltaTime.log_with_time(\"Done heating toolhead\")\n\n            # Enable the lane for filament movement.\n            cur_lane.do_enable(True)\n\n            # Move filament to the hub if it's not already loaded there.\n            if not cur_lane.loaded_to_hub or cur_lane.hub == 'direct':\n                cur_lane.move_advanced(cur_lane.dist_hub, SpeedMode.HUB, assist_active = AssistActive.DYNAMIC)\n                self.afcDeltaTime.log_with_time(\"Loaded to hub\")\n\n            cur_lane.loaded_to_hub = True\n            hub_attempts = 0\n\n            # Ensure filament moves past the hub.\n            while not cur_hub.state and cur_lane.hub != 'direct':\n                if hub_attempts == 0:\n                    cur_lane.move_advanced(cur_hub.move_dis, SpeedMode.SHORT)\n                else:\n                    cur_lane.move_advanced(cur_lane.short_move_dis, SpeedMode.SHORT)\n                hub_attempts += 1\n                if hub_attempts > 20:\n                    message = 'filament did not trigger hub sensor, CHECK FILAMENT PATH\\n||=====||==>--||-----||\\nTRG   LOAD   HUB   TOOL.'\n                    if self.function.in_print():\n                        message += '\\nOnce issue is resolved please manually load {} with {} macro and click resume to continue printing.'.format(cur_lane.name, cur_lane.map)\n                        message += '\\nIf you have to retract filament back, use LANE_MOVE macro for {}.'.format(cur_lane.name)\n                    self.error.handle_lane_failure(cur_lane, message)\n                    return False\n\n            self.afcDeltaTime.log_with_time(\"Filament loaded to hub\")\n\n            # Move filament towards the toolhead.\n            if cur_lane.hub != 'direct':\n                cur_lane.move_advanced(cur_hub.afc_bowden_length, SpeedMode.LONG, assist_active = AssistActive.YES)\n\n            # Ensure filament reaches the toolhead.\n            tool_attempts = 0\n            if cur_extruder.tool_start:\n                while not cur_lane.get_toolhead_pre_sensor_state():\n                    tool_attempts += 1\n                    cur_lane.move(cur_lane.short_move_dis, cur_extruder.tool_load_speed, cur_lane.long_moves_accel)\n                    if tool_attempts > int(self.tool_homing_distance/cur_lane.short_move_dis):\n                        message = 'filament failed to trigger pre extruder gear toolhead sensor, CHECK FILAMENT PATH\\n||=====||====||==>--||\\nTRG   LOAD   HUB   TOOL'\n                        message += '\\nTo resolve set lane loaded with `SET_LANE_LOADED LANE={}` macro.'.format(cur_lane.name)\n                        message += '\\nManually move filament with LANE_MOVE macro for {} until filament is right before toolhead extruder gears,'.format(cur_lane.name)\n                        message += '\\n then load into extruder gears with extrude button in your gui of choice until the color fully changes'\n                        if self.function.in_print():\n                            message += '\\nOnce filament is fully loaded click resume to continue printing'\n                        self.error.handle_lane_failure(cur_lane, message)\n                        return False\n\n            self.afcDeltaTime.log_with_time(\"Filament loaded to pre-sensor\")\n\n            # Synchronize lane's extruder stepper and finalize tool loading.\n            cur_lane.status = AFCLaneState.TOOL_LOADED\n            self.save_vars()\n            cur_lane.sync_to_extruder()\n\n            if cur_extruder.tool_end:\n                while not cur_extruder.tool_end_state:\n                    tool_attempts += 1\n                    self.move_e_pos( cur_lane.short_move_dis, cur_extruder.tool_load_speed, \"Tool end\", wait_tool=True )\n                    if tool_attempts > 20:\n                        message = 'filament failed to trigger post extruder gear toolhead sensor, CHECK FILAMENT PATH\\n||=====||====||==>--||\\nTRG   LOAD   HUB   TOOL'\n                        message += '\\nTo resolve set lane loaded with `SET_LANE_LOADED LANE={}` macro.'.format(cur_lane.name)\n                        message += '\\nAlso might be a good idea to verify that post extruder gear toolhead sensor is working.'\n                        if self.function.in_print():\n                            message += '\\nOnce issue is resolved click resume to continue printing'\n                        self.error.handle_lane_failure(cur_lane, message)\n                        return False\n\n                self.afcDeltaTime.log_with_time(\"Filament loaded to post-sensor\")\n\n            # Adjust tool position for loading.\n            self.move_e_pos( cur_extruder.tool_stn, cur_extruder.tool_load_speed, \"tool stn\" )\n\n            self.afcDeltaTime.log_with_time(\"Filament loaded to nozzle\")\n\n            # Check if ramming is enabled, if it is, go through ram load sequence.\n            # Lane will load until Advance sensor is True\n            # After the tool_stn distance the lane will retract off the sensor to confirm load and reset buffer\n            if cur_extruder.tool_start == \"buffer\":\n                cur_lane.unsync_to_extruder()\n                load_checks = 0\n                while cur_lane.get_toolhead_pre_sensor_state():\n                    cur_lane.move_advanced(cur_lane.short_move_dis * -1, SpeedMode.SHORT)\n                    load_checks += 1\n                    self.reactor.pause(self.reactor.monotonic() + 0.1)\n                    if load_checks > self.tool_max_load_checks:\n                        msg = ''\n                        msg += \"Buffer did not become compressed after {} short moves.\\n\".format(self.tool_max_load_checks)\n                        msg += \"Setting and increasing 'tool_max_load_checks' in AFC.cfg may improve loading reliability.\\n\\n\"\n                        msg += \"Check that the filament is properly loaded into the toolhead extruder. If filament is loaded\\n\"\n                        msg += \"into toolhead extruders gears, then manually run SET_LANE_LOADED LANE={cur_lane.name} then\\n\"\n                        msg += \"manually extrude filament and clean nozzle.\"\n                        if self.function.in_print():\n                            msg += '\\nOnce issue is resolved click resume to continue printing'\n                        self.error.handle_lane_failure(cur_lane, msg)\n                        return False\n                cur_lane.sync_to_extruder()\n            # Update tool and lane status.\n            cur_lane.set_loaded()\n            cur_lane.enable_buffer()\n            self.save_vars()\n\n            # Activate the tool-loaded LED and handle filament operations if enabled.\n            cur_lane.unit_obj.lane_tool_loaded( cur_lane )\n            if self.poop:\n                if purge_length is not None:\n                    self.gcode.run_script_from_command(\"%s %s=%s\" % (self.poop_cmd, 'PURGE_LENGTH', purge_length))\n\n                else:\n                    self.gcode.run_script_from_command(self.poop_cmd)\n\n                self.afcDeltaTime.log_with_time(\"TOOL_LOAD: After poop\")\n                self.function.log_toolhead_pos()\n\n                if self.wipe:\n                    self.gcode.run_script_from_command(self.wipe_cmd)\n                    self.afcDeltaTime.log_with_time(\"TOOL_LOAD: After first wipe\")\n                    self.function.log_toolhead_pos()\n\n            if self.kick:\n                self.gcode.run_script_from_command(self.kick_cmd)\n                self.afcDeltaTime.log_with_time(\"TOOL_LOAD: After kick\")\n                self.function.log_toolhead_pos()\n\n            if self.wipe:\n                self.gcode.run_script_from_command(self.wipe_cmd)\n                self.afcDeltaTime.log_with_time(\"TOOL_LOAD: After second wipe\")\n                self.function.log_toolhead_pos()\n\n            # Update lane and extruder state for tracking.\n            cur_extruder.lane_loaded = cur_lane.name\n            self.spool.set_active_spool(cur_lane.spool_id)\n            cur_lane.unit_obj.lane_tool_loaded( cur_lane )\n            self.save_vars()\n            self.current_state = State.IDLE\n            load_time = self.afcDeltaTime.log_major_delta(\"{} is now loaded in toolhead\".format(cur_lane.name), False)\n            self.afc_stats.average_tool_load_time.average_time(load_time)\n\n            # Increment stat counts\n            self.afc_stats.tc_tool_load.increase_count()\n            cur_lane.lane_load_count.increase_count()\n            cur_lane.espooler.stats.update_database()\n\n        else:\n            # Handle errors if the hub is not clear or the lane is not ready for loading.\n            if cur_hub.state:\n                message = 'Hub not clear when trying to load.\\nPlease check that hub does not contain broken filament and is clear'\n                if self.function.in_print():\n                    message += '\\nOnce issue is resolved please manually load {} with {} macro and click resume to continue printing.'.format(cur_lane.name, cur_lane.map)\n                self.error.handle_lane_failure(cur_lane, message)\n                return False\n            if not cur_lane.load_state:\n                message = 'Current lane not loaded, LOAD TRIGGER NOT TRIGGERED\\n||==>--||----||-----||\\nTRG   LOAD   HUB   TOOL'\n                message += '\\nPlease load lane before continuing.'\n                if self.function.in_print():\n                    message += '\\nOnce issue is resolved please manually load {} with {} macro and click resume to continue printing.'.format(cur_lane.name, cur_lane.map)\n                self.error.handle_lane_failure(cur_lane, message)\n                return False\n        return True\n\n    cmd_TOOL_UNLOAD_help = \"Unload from tool head\"\n    def cmd_TOOL_UNLOAD(self, gcmd):\n        \"\"\"\n        This function handles the unloading of a specified lane from the tool head. It retrieves\n        the lane specified by the 'LANE' parameter or uses the currently loaded lane if no parameter\n        is provided, and calls the TOOL_UNLOAD method to perform the unloading process.\n\n        Usage\n        -----\n        `TOOL_UNLOAD LANE=<lane>`\n\n        Example\n        -----\n        ```\n        TOOL_UNLOAD LANE=lane1\n        ```\n        \"\"\"\n        self.afcDeltaTime.set_start_time()\n        # Check if the bypass filament sensor detects filament; if so unload filament and abort the tool load.\n        if self._check_bypass(unload=True): return False\n\n        lane = gcmd.get('LANE', self.current)\n        if lane is None:\n            return\n        if lane not in self.lanes:\n            self.logger.info('{} Unknown'.format(lane))\n            return\n        cur_lane = self.lanes[lane]\n        self.TOOL_UNLOAD(cur_lane)\n\n        # User manually unloaded spool from toolhead, remove spool from active status\n        self.spool.set_active_spool(None)\n\n    def TOOL_UNLOAD(self, cur_lane):\n        \"\"\"\n        This function handles the unloading of a specified lane from the tool. It performs\n        several checks and movements to ensure the lane is properly unloaded.\n\n        :param cur_lane: The lane object to be unloaded from the tool.\n\n        :return bool: True if unloading was successful, False if an error occurred.\n        \"\"\"\n        # Check if the bypass filament sensor detects filament; if so unload filament and abort the tool load.\n        if self._check_bypass(unload=True): return False\n\n        if not self.function.check_homed():\n            return False\n\n        if cur_lane is None:\n            # If no lane is provided, exit the function early with a failure.\n            self.error.AFC_error(\"No lane is currently loaded, nothing to unload\", pause=self.function.in_print())\n            return False\n\n        self.current_state  = State.UNLOADING\n        self.current_loading = cur_lane.name\n        self.logger.info(\"Unloading {}\".format(cur_lane.name))\n        cur_lane.status = AFCLaneState.TOOL_UNLOADING\n        self.save_vars()\n\n        # Verify that printer is in absolute mode\n        self.function.check_absolute_mode(\"TOOL_UNLOAD\")\n\n        # Lookup current extruder and hub objects using the lane's information.\n        cur_hub = cur_lane.hub_obj\n        cur_extruder = cur_lane.extruder_obj\n\n        # Prepare the extruder and heater for unloading.\n        if self._check_extruder_temp(cur_lane):\n            self.afcDeltaTime.log_with_time(\"Done heating toolhead\")\n\n        # Quick pull to prevent oozing.\n        self.move_e_pos( -2, cur_extruder.tool_unload_speed, \"Quick Pull\", wait_tool=False)\n        self.function.log_toolhead_pos(\"TOOL_UNLOAD quick pull: \")\n\n        # Perform Z-hop to avoid collisions during unloading.\n        pos = self.gcode_move.last_position\n        pos[2] += self.z_hop\n        # toolhead wait is needed here as it will cause TTC for some if wait does not occur\n        self.move_z_pos(pos[2], \"Tool_Unload quick pull\", wait_moves=True)\n\n        # Disable the buffer if it's active.\n        cur_lane.disable_buffer()\n\n        # Activate LED indicator for unloading.\n        self.function.afc_led(cur_lane.led_unloading, cur_lane.led_index)\n\n        if cur_lane.extruder_stepper.motion_queue != cur_lane.extruder_name:\n            # Synchronize the extruder stepper with the lane.\n            cur_lane.sync_to_extruder()\n\n        # Enable the lane for unloading operations.\n        cur_lane.do_enable(True)\n\n        # Perform filament cutting and parking if specified.\n        if self.tool_cut:\n            self.afc_stats.increase_cut_total()\n            self.gcode.run_script_from_command(self.tool_cut_cmd)\n            self.afcDeltaTime.log_with_time(\"TOOL_UNLOAD: After cut\")\n            self.function.log_toolhead_pos()\n\n            if self.park:\n                self.gcode.run_script_from_command(self.park_cmd)\n                self.afcDeltaTime.log_with_time(\"TOOL_UNLOAD: After park\")\n                self.function.log_toolhead_pos()\n\n        # Form filament tip if necessary.\n        if self.form_tip:\n            if self.park:\n                self.gcode.run_script_from_command(self.park_cmd)\n                self.afcDeltaTime.log_with_time(\"TOOL_UNLOAD: After form tip park\")\n                self.function.log_toolhead_pos()\n\n            if self.form_tip_cmd == \"AFC\":\n                self.tip = self.printer.lookup_object('AFC_form_tip')\n                self.tip.tip_form()\n                self.afcDeltaTime.log_with_time(\"TOOL_UNLOAD: After afc form tip\")\n                self.function.log_toolhead_pos()\n\n            else:\n                self.gcode.run_script_from_command(self.form_tip_cmd)\n                self.afcDeltaTime.log_with_time(\"TOOL_UNLOAD: After custom form tip\")\n                self.function.log_toolhead_pos()\n\n        # Attempt to unload the filament from the extruder, retrying if needed.\n        num_tries = 0\n        if cur_extruder.tool_start == \"buffer\":\n            # if ramming is enabled, AFC will retract to collapse buffer before unloading\n            cur_lane.unsync_to_extruder()\n            while not cur_lane.get_trailing() and self.tool_max_unload_attempts > 0:\n                # attempt to return buffer to trailing pin\n                cur_lane.move_advanced(cur_lane.short_move_dis * -1, SpeedMode.SHORT)\n                num_tries += 1\n                self.reactor.pause(self.reactor.monotonic() + 0.1)\n                if num_tries > self.tool_max_unload_attempts:\n                    msg = ''\n                    msg += \"Buffer did not become compressed after {} short moves.\\n\".format(self.tool_max_unload_attempts)\n                    msg += \"Setting and increasing 'tool_max_unload_attempts' in AFC.cfg may improve unloading reliability\\n\\n\"\n                    msg += \"Please check to make sure filament is unloaded from the toolhead's extruder. If filament is still\\n\"\n                    msg += \"loaded manually retract back until its free, then run UNSET_LANE_LOADED and then do manual\\n\"\n                    msg += \"moves with BT_LANE_MOVE until filament is retracted behind your hub. Or you can run AFC_RESET\\n\"\n                    msg += f\"and select {cur_lane.name}, then AFC will slowly move lane until hub is no longer triggered.\\n\"\n                    if self.next_lane_load is not None:\n                        msg += f\"\\nOnce lane is behind hub and hub is no longer triggered manually load {self.next_lane_load}\\n\"\n                        msg += f\"with {self.lanes[self.next_lane_load].map} macro.\\n\"\n                        if self.function.in_print():\n                            msg += \"Once lane is loaded click resume to continue printing\"\n                    self.error.handle_lane_failure(cur_lane, msg)\n                    return False\n            cur_lane.sync_to_extruder(False)\n            with cur_lane.assist_move(cur_extruder.tool_unload_speed, True, cur_lane.assisted_unload):\n                self.move_e_pos( cur_extruder.tool_stn_unload * -1, cur_extruder.tool_unload_speed, \"Buffer Move\")\n\n            self.function.log_toolhead_pos(\"Buffer move after \")\n        else:\n            while cur_lane.get_toolhead_pre_sensor_state() or cur_extruder.tool_end_state:\n                num_tries += 1\n                if num_tries > self.tool_max_unload_attempts:\n                    # Handle failure if the filament cannot be unloaded.\n                    message = 'Failed to unload filament from toolhead. Filament stuck in toolhead.'\n                    if self.function.in_print():\n                        message += \"\\nRetract filament fully with retract button in gui of choice to remove from extruder gears if needed,\"\n                        message += \"\\n  and then use LANE_MOVE to fully retract behind hub so its not triggered anymore.\"\n                        message += \"\\nThen Manually run UNSET_LANE_LOADED to let AFC know nothing is loaded into toolhead\"\n                        # Check to make sure next_lane_loaded is not None before adding instructions on how to manually load next lane\n                        if self.next_lane_load is not None:\n                            message += \"\\nThen manually load {} with {} macro\".format(self.next_lane_load, self.lanes[self.next_lane_load].map)\n                            if self.function.in_print():\n                                message += \"\\nOnce lane is loaded click resume to continue printing\"\n                    self.error.handle_lane_failure(cur_lane, message)\n                    return False\n                cur_lane.sync_to_extruder()\n\n                with cur_lane.assist_move(cur_extruder.tool_unload_speed, True, cur_lane.assisted_unload):\n                    self.move_e_pos( cur_extruder.tool_stn_unload * -1, cur_extruder.tool_unload_speed, \"Sensor move\", wait_tool=True)\n\n                self.function.log_toolhead_pos(\"Sensor move after \")\n\n        self.afcDeltaTime.log_with_time(\"Unloaded from toolhead\")\n\n        # Move filament past the sensor after the extruder, if applicable.\n        if cur_extruder.tool_sensor_after_extruder > 0:\n            with cur_lane.assist_move(cur_extruder.tool_unload_speed, True, cur_lane.assisted_unload):\n                self.move_e_pos(cur_extruder.tool_sensor_after_extruder * -1, cur_extruder.tool_unload_speed, \"After extruder\")\n\n            self.afcDeltaTime.log_with_time(\"Tool sensor after extruder move done\")\n\n        self.save_vars()\n        # Synchronize and move filament out of the hub.\n        cur_lane.unsync_to_extruder()\n        if cur_lane.hub != 'direct':\n            cur_lane.move_advanced(cur_hub.afc_unload_bowden_length * -1, SpeedMode.LONG, assist_active = AssistActive.YES)\n        else:\n            cur_lane.move_advanced(cur_lane.dist_hub * -1, SpeedMode.HUB, assist_active = AssistActive.DYNAMIC)\n\n        self.afcDeltaTime.log_with_time(\"Long retract done\")\n\n        # Clear toolhead's loaded status for easier error handling later.\n        cur_lane.set_unloaded()\n\n        self.save_vars()\n\n        # Ensure filament is fully cleared from the hub.\n        num_tries = 0\n        while cur_hub.state:\n            cur_lane.move_advanced(cur_lane.short_move_dis * -1, SpeedMode.SHORT, assist_active = AssistActive.YES)\n            num_tries += 1\n            if num_tries > (cur_hub.afc_unload_bowden_length / cur_lane.short_move_dis):\n                # Handle failure if the filament doesn't clear the hub.\n                message = 'Hub is not clearing, filament may be stuck in hub'\n                message += '\\nPlease check to make sure filament has not broken off and caused the sensor to stay stuck'\n                message += '\\nIf you have to retract filament back, use LANE_MOVE macro for {}.'.format(cur_lane.name)\n                if self.function.in_print():\n                    # Check to make sure next_lane_loaded is not None before adding instructions on how to manually load next lane\n                    if self.next_lane_load is not None:\n                        message += \"\\nOnce hub is clear, manually load {} with {} macro\".format(self.next_lane_load, self.lanes[self.next_lane_load].map)\n                        if self.function.in_print():\n                            message += \"\\nOnce lane is loaded click resume to continue printing\"\n\n                self.error.handle_lane_failure(cur_lane, message)\n                return False\n\n        self.afcDeltaTime.log_with_time(\"Hub cleared\")\n\n        #Move to make sure hub path is clear based on the move_clear_dis var\n        if cur_lane.hub != 'direct':\n            cur_lane.move_advanced(cur_hub.hub_clear_move_dis * -1, SpeedMode.SHORT, assist_active = AssistActive.YES)\n\n            # Cut filament at the hub, if configured.\n            if cur_hub.cut:\n                if cur_hub.cut_cmd == 'AFC':\n                    cur_hub.hub_cut(cur_lane)\n                else:\n                    self.gcode.run_script_from_command(cur_hub.cut_cmd)\n\n                # Confirm the hub is clear after the cut.\n                while cur_hub.state:\n                    cur_lane.move_advanced(cur_lane.short_move_dis * -1, SpeedMode.SHORT, assist_active = AssistActive.YES)\n                    num_tries += 1\n                    # TODO: Figure out max number of tries\n                    if num_tries > (cur_hub.afc_unload_bowden_length / cur_lane.short_move_dis):\n                        message = 'HUB NOT CLEARING after hub cut\\n'\n                        self.error.handle_lane_failure(cur_lane, message)\n                        return False\n\n                self.afcDeltaTime.log_with_time(\"Hub cut done\")\n\n        # Finalize unloading and reset lane state.\n        cur_lane.loaded_to_hub = True\n        cur_lane.unit_obj.lane_tool_unloaded(cur_lane)\n        cur_lane.status = AFCLaneState.NONE\n\n        if cur_lane.hub == 'direct':\n            while cur_lane.load_state:\n                cur_lane.move_advanced(cur_lane.short_move_dis * -1, SpeedMode.SHORT, assist_active = AssistActive.YES)\n            cur_lane.move_advanced(cur_lane.short_move_dis * -5, SpeedMode.SHORT)\n\n        cur_lane.do_enable(False)\n        cur_lane.unit_obj.return_to_home()\n\n        self.afc_stats.tc_tool_unload.increase_count()\n        cur_lane.espooler.stats.update_database()\n\n        self.save_vars()\n        unload_time = self.afcDeltaTime.log_major_delta(\"Lane {} unload done\".format(cur_lane.name))\n        self.afc_stats.average_tool_unload_time.average_time(unload_time)\n        self.current_state = State.IDLE\n        return True\n\n    cmd_CHANGE_TOOL_help = \"change filaments in tool head\"\n    def cmd_CHANGE_TOOL(self, gcmd):\n        \"\"\"\n        This function handles the tool change process. It retrieves the lane specified by the 'LANE' parameter,\n        checks the filament sensor, saves the current position, and performs the tool change by unloading the\n        current lane and loading the new lane.\n\n        Optionally setting PURGE_LENGTH parameter to pass a value into poop macro.\n\n        Usage\n        -----\n        `CHANGE_TOOL LANE=<lane> PURGE_LENGTH=<purge_length>(optional value)`\n\n        Example\n        ------\n        ```\n        CHANGE_TOOL LANE=lane1 PURGE_LENGTH=100\n        ```\n        \"\"\"\n        # Check if the bypass filament sensor detects filament; if so, abort the tool change.\n        if self._check_bypass(unload=False): return\n\n        if not self.function.check_homed():\n            return False\n\n        purge_length = gcmd.get('PURGE_LENGTH', None)\n\n        # Klipper macros that start with a single letter (ie T0) parse the parameter values with the equals sign\n        # for some sort of backwards compatibility, so for example: T0 PURGE_LENGTH=200, the purge_length would be\n        # equal to \"=200\". So run this check to remove it:\n        if purge_length is not None:\n            if purge_length.startswith('='):\n                purge_length = purge_length[1:]\n\n        command_line = gcmd.get_commandline()\n        self.logger.debug(\"CHANGE_TOOL: cmd-{}\".format(command_line))\n\n        # Remove everything after ; since it could contain strings like CHANGE in a comment and should be ignored\n        command = re.sub( ';.*', '', command_line)\n        command = command.split(' ')[0].upper()\n        tmp = gcmd.get_commandline()\n        cmd = tmp.upper()\n        Tcmd = ''\n        if 'CHANGE' in command:\n            lane = gcmd.get('LANE', None)\n            if lane is not None:\n                for key in self.tool_cmds.keys():\n                    if self.tool_cmds[key].upper() == lane.upper():\n                        Tcmd = key\n                        break\n        else:\n            Tcmd = command\n\n        if Tcmd == '':\n            self.error.AFC_error(\"I did not understand the change -- \" + cmd, pause=self.function.in_print())\n            return\n\n        self.CHANGE_TOOL(self.lanes[self.tool_cmds[Tcmd]], purge_length)\n\n    def CHANGE_TOOL(self, cur_lane, purge_length=None, restore_pos=True):\n        self.afcDeltaTime.set_start_time()\n        # Check if the bypass filament sensor detects filament; if so, abort the tool change.\n        if self._check_bypass(unload=False): return\n\n        self.next_lane_load = cur_lane.name\n\n        # If the requested lane is not the current lane, proceed with the tool change.\n        if cur_lane.name != self.current:\n            # Save the current toolhead position to allow restoration after the tool change.\n            self.save_pos()\n            # Set the in_toolchange flag to prevent overwriting the saved position during potential failures.\n            self.in_toolchange = True\n\n            # Check if the lane has completed the preparation process required for tool changes.\n            if cur_lane._afc_prep_done:\n                # Log the tool change operation for debugging or informational purposes.\n                self.logger.info(\"Tool Change - {} -> {}\".format(self.current, cur_lane.name))\n                if not self.error_state and self.number_of_toolchanges != 0 and self.current_toolchange != self.number_of_toolchanges:\n                    self.current_toolchange += 1\n                    self.logger.raw(\"//      Change {} out of {}\".format(self.current_toolchange, self.number_of_toolchanges))\n\n                # If a current lane is loaded, unload it first.\n                if self.current is not None:\n                    c_lane = self.current\n                    if c_lane not in self.lanes:\n                        self.error.AFC_error('{} Unknown'.format(c_lane))\n                        return\n                    if not self.TOOL_UNLOAD(self.lanes[c_lane]):\n                        # Abort if the unloading process fails.\n                        msg = (' UNLOAD error NOT CLEARED')\n                        self.error.fix(msg, self.lanes[c_lane])  #send to error handling\n                        return\n\n            # Load the new lane and restore the toolhead position if successful.\n            if self.TOOL_LOAD(cur_lane, purge_length) and not self.error_state:\n                if restore_pos:\n                    self.restore_pos()\n                total_time = self.afcDeltaTime.log_total_time(\"Total change time:\")\n                self.afc_stats.average_toolchange_time.average_time(total_time)\n                self.in_toolchange = False\n                # Setting next lane load as none since toolchange was successful\n                self.next_lane_load = None\n                self.afc_stats.increase_toolcount_change()\n            else:\n                # Error happened, reset toolchanges without error count\n                if not self.testing:\n                    self.afc_stats.reset_toolchange_wo_error()\n        else:\n            self.logger.info(\"{} already loaded\".format(cur_lane.name))\n            if not self.error_state and self.current_toolchange == -1:\n                self.current_toolchange += 1\n\n        self.function.log_toolhead_pos(\"Final Change Tool: Error State: {}, Is Paused {}, Position_saved {}, in toolchange: {}, POS: \".format(\n                self.error_state, self.function.is_paused(), self.position_saved, self.in_toolchange ))\n\n    def _get_message(self, clear=False):\n        \"\"\"\n        Helper function to return a message from the error message queue\n\n        :param clear: Set to true to pop the first item out of the list\n        : return Dictionary in {\"message\":\"\", \"type\":\"\"} format\n        \"\"\"\n        message = {\"message\":\"\", \"type\":\"\"}\n        try:\n            message['message'], message[\"type\"] = self.message_queue[0]\n            if clear:\n                message['message'], message[\"type\"] = self.message_queue.pop(0)\n        except IndexError:\n            pass\n        return message\n\n    def get_status(self, eventtime=None):\n        \"\"\"\n        Displays current status of AFC for webhooks\n        \"\"\"\n        str = {}\n        str['current_load']             = self.current\n        str['current_lane']             = self.current_loading\n        str['next_lane']                = self.next_lane_load\n        str['current_state']            = self.current_state\n        str[\"current_toolchange\"]       = self.current_toolchange\n        str[\"number_of_toolchanges\"]    = self.number_of_toolchanges\n        str['spoolman']                 = self.spoolman\n        str['error_state']              = self.error_state\n        str[\"bypass_state\"]             = bool(self._get_bypass_state())\n        str[\"quiet_mode\"]               = bool(self._get_quiet_mode())\n        str[\"position_saved\"]           = self.position_saved\n\n        unitdisplay =[]\n        for UNIT in self.units.keys():\n            CUR_UNIT=self.units[UNIT]\n            type  =CUR_UNIT.type.replace(\" \",\"_\")\n            unitdisplay.append(type.replace(\"'\",\"\") + \" \" + CUR_UNIT.name)\n        str['units'] = list(unitdisplay)\n        str['lanes'] = list(self.lanes.keys())\n        str[\"extruders\"] = list(self.tools.keys())\n        str[\"hubs\"] = list(self.hubs.keys())\n        str[\"buffers\"] = list(self.buffers.keys())\n        str[\"message\"] = self._get_message()\n        str[\"led_state\"] = self.led_state\n        return str\n\n    def _webhooks_status(self, web_request):\n        \"\"\"\n        Webhooks callback for <ip_address>/printer/afc/status, and displays current AFC status for everything\n        \"\"\"\n        str = {}\n        numoflanes = 0\n        for unit in self.units.values():\n            str.update({unit.name: { \"system\": {}}})\n            name=[]\n            for lane in unit.lanes.values():\n                str[unit.name][lane.name]=lane.get_status()\n                numoflanes +=1\n                name.append(lane.name)\n            str[unit.name]['system']['type']        = unit.type\n            str[unit.name]['system']['hub_loaded'] = unit.hub_obj.state if unit.hub_obj is not None else None\n\n        str[\"system\"]                           = {}\n        str[\"system\"]['current_load']           = self.current\n        str[\"system\"]['num_units']              = len(self.units)\n        str[\"system\"]['num_lanes']              = numoflanes\n        str[\"system\"]['num_extruders']          = len(self.tools)\n        str[\"system\"]['spoolman']               = self.spoolman\n        str[\"system\"][\"current_toolchange\"]     = self.current_toolchange\n        str[\"system\"][\"number_of_toolchanges\"]  = self.number_of_toolchanges\n        str[\"system\"][\"extruders\"]              = {}\n        str[\"system\"][\"hubs\"]                   = {}\n        str[\"system\"][\"buffers\"]                = {}\n        str[\"system\"][\"led_state\"] = self.led_state\n\n        for extruder in self.tools.values():\n            str[\"system\"][\"extruders\"][extruder.name] = extruder.get_status()\n\n        for hub in self.hubs.values():\n            str[\"system\"][\"hubs\"][hub.name] = hub.get_status()\n\n        for buffer in self.buffers.values():\n            str[\"system\"][\"buffers\"][buffer.name] = buffer.get_status()\n\n        web_request.send( {\"status:\" : {\"AFC\": str}})\n\n    cmd_AFC_STATUS_help = \"Return current status of AFC\"\n    def cmd_AFC_STATUS(self, gcmd):\n        \"\"\"\n        This function generates a status message for each unit and lane, indicating the preparation,\n        loading, hub, and tool states. The status message is formatted with HTML tags for display.\n\n        Usage\n        -----\n        `AFC_STATUS`\n\n        Example\n        -----\n        ```\n        AFC_STATUS\n        ```\n        \"\"\"\n        status_msg = ''\n\n        for unit in self.units.values():\n            # Find the maximum length of lane names to determine the column width\n            max_lane_length = max(len(lane) for lane in unit.lanes.keys())\n\n            status_msg += '<span class=info--text>{} Status</span>\\n'.format(unit.name)\n\n            # Create a dynamic format string that adjusts based on lane name length\n            header_format = '{:<{}} | Prep | Load |\\n'\n            status_msg += header_format.format(\"LANE\", max_lane_length)\n\n            for cur_lane in unit.lanes.values():\n                lane_msg = ''\n                if self.current is not None:\n                    if self.current == cur_lane.name:\n                        if not cur_lane.get_toolhead_pre_sensor_state() or not cur_lane.hub_obj.state:\n                            lane_msg += '<span class=warning--text>{:<{}} </span>'.format(cur_lane.name, max_lane_length)\n                        else:\n                            lane_msg += '<span class=success--text>{:<{}} </span>'.format(cur_lane.name, max_lane_length)\n                    else:\n                        lane_msg += '{:<{}} '.format(cur_lane.name, max_lane_length)\n                else:\n                    lane_msg += '{:<{}} '.format(cur_lane.name, max_lane_length)\n\n                if cur_lane.prep_state:\n                    lane_msg += '| <span class=success--text><--></span> |'\n                else:\n                    lane_msg += '|  <span class=error--text>xx</span>  |'\n                if cur_lane.load_state:\n                    lane_msg += ' <span class=success--text><--></span> |\\n'\n                else:\n                    lane_msg += '  <span class=error--text>xx</span>  |\\n'\n                status_msg += lane_msg\n\n            if cur_lane.hub_obj.state:\n                status_msg += 'HUB: <span class=success--text><-></span>'\n            else:\n                status_msg += 'HUB: <span class=error--text>x</span>'\n\n            extruder_msg = '  Tool: <span class=error--text>x</span>'\n            if cur_lane.extruder_obj.tool_start != \"buffer\":\n                if cur_lane.extruder_obj.tool_start_state:\n                    extruder_msg = '  Tool: <span class=success--text><-></span>'\n            else:\n                if cur_lane.tool_loaded and cur_lane.extruder_obj.lane_loaded in self.units[unit]:\n                    if cur_lane.get_toolhead_pre_sensor_state():\n                        extruder_msg = '  Tool: <span class=success--text><-></span>'\n\n            status_msg += extruder_msg\n            if cur_lane.extruder_obj.tool_start == 'buffer':\n                status_msg += '\\n<span class=info--text>Ram sensor enabled</span>\\n'\n\n        self.logger.raw(status_msg)\n\n    cmd_TURN_OFF_AFC_LED_help = \"Turns off all LEDs for AFC_led configurations\"\n    def cmd_TURN_OFF_AFC_LED(self, gcmd: Any) -> None:\n        \"\"\"\n        This macro handles turning off all LEDs for AFC_led configurations. Color for LEDs are saved if colors\n        are changed while they are turned off.\n\n        Usage\n        -----\n        `TURN_OFF_AFC_LED`\n\n        Example\n        -----\n        ```\n        TURN_OFF_AFC_LED\n        ```\n        \"\"\"\n        self.led_state = False\n        for led in self.led_obj.values():\n            led.turn_off_leds()\n\n    cmd_TURN_ON_AFC_LED_help = \"Turns on all LEDs for AFC_led configurations and restores state\"\n    def cmd_TURN_ON_AFC_LED(self, gcmd):\n        \"\"\"\n        This macro handles turning on all LEDs for AFC_led configurations. LEDs are restored to last previous state.\n\n        Usage\n        -----\n        `TURN_ON_AFC_LED`\n\n        Example\n        -----\n        ```\n        TURN_ON_AFC_LED\n        ```\n        \"\"\"\n        self.led_state = True\n        for led in self.led_obj.values():\n            led.turn_on_leds()\n\n    cmd_AFC_STATS_help =\"Prints AFC toolchange statistics to console\"\n    cmd_AFC_STATS_options = {\"SHORT\": {\"type\": \"int\", \"default\": 1}}\n    def cmd_AFC_STATS(self, gcmd):\n        \"\"\"\n        This macro handles printing toolchange statistics to console.\n\n        Optional Values\n        ----\n        Set SHORT=1 to have a smaller print that fits better on smaller screens. Setting `print_short_stats`\n        variable in `[AFC]` section in the AFC.cfg file to True will always print statistics in short form.\n\n        Usage\n        -----\n        `AFC_STATS SHORT=<1|0>`\n\n        Example\n        -----\n        ```\n        AFC_STATS\n        ```\n        \"\"\"\n        short = bool(gcmd.get_int(\"SHORT\", self.short_stats))\n\n        self.afc_stats.print_stats(afc_obj=self, short=short)\n\n    cmd_AFC_CHANGE_BLADE_help = \"Sets cutter blade changed date and resets total count since blade was changed\"\n    def cmd_AFC_CHANGE_BLADE(self, gcmd):\n        \"\"\"\n        This macro handles resetting cut total since blade was last changed and updates the data\n        the blade was last changed to current date time when this macro was run.\n\n        Usage\n        -----\n        `AFC_CHANGE_BLADE`\n\n        Example\n        -----\n        ```\n        AFC_CHANGE_BLADE\n        ```\n        \"\"\"\n        self.afc_stats.last_blade_changed.set_current_time()\n        self.afc_stats.cut_total_since_changed.reset_count()\n        self.logger.info(\"Cutter blade stats reset\")\n\n    cmd_AFC_CLEAR_MESSAGE_help = \"Macro to clear error and warning message from AFC message queue\"\n    def cmd_AFC_CLEAR_MESSAGE(self, gcmd):\n        \"\"\"\n        This macro handles clearing one message at a time for messages that show up mainsail/klipperscreen/fluidd gui's.\n\n        USAGE\n        -----\n        `AFC_CLEAR_MESSAGE`\n\n        Example\n        -----\n        ```\n        AFC_CLEAR_MESSAGE\n        ```\n        \"\"\"\n        self._get_message(clear=True)\n\n    cmd__AFC_TEST_MESSAGES_help = \"Macro to send test messages for testing\"\n    def cmd__AFC_TEST_MESSAGES(self, gcmd):\n        self.logger.error(\"Test Message 1\")\n        self.logger.error(\"Test Message 2\")\n        self.logger.error(\"Test Message 3\")",
    'extras.AFC_error': "# Armored Turtle Automated Filament Changer\n#\n# Copyright (C) 2024 Armored Turtle\n#\n# This file may be distributed under the terms of the GNU GPLv3 license.\nimport traceback\nimport logging\nimport inspect\n\nfrom configparser import Error as error\n\ntry: from extras.AFC_utils import ERROR_STR\nexcept: raise error(\"Error when trying to import AFC_utils.ERROR_STR\\n{trace}\".format(trace=traceback.format_exc()))\n\ntry: from extras.AFC import State\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC\", trace=traceback.format_exc()))\n\ntry: from extras.AFC_lane import AFCLaneState\nexcept: raise error(ERROR_STR.format(import_lib=\"AFC_lane\", trace=traceback.format_exc()))\n\ndef load_config(config):\n    return afcError(config)\n\nclass afcError:\n    def __init__(self, config):\n        self.printer = config.get_printer()\n        self.printer.register_event_handler(\"klippy:connect\", self.handle_connect)\n        self.errorLog= {}\n        self.pause= False\n\n    def handle_connect(self):\n        \"\"\"\n        Handle the connection event.\n        This function is called when the printer connects. It looks up AFC info\n        and assigns it to the instance variable `self.AFC`.\n        \"\"\"\n        self.afc            = self.printer.lookup_object('AFC')\n        self.pause_resume   = self.printer.lookup_object(\"pause_resume\")\n        self.logger         = self.afc.logger\n        self.error_timeout  = self.afc.error_timeout\n        self.idle_timeout_obj = self.printer.lookup_object(\"idle_timeout\")\n        self.idle_timeout_val = self.idle_timeout_obj.idle_timeout\n\n        # Constant variable for renaming RESUME macro\n        self.BASE_RESUME_NAME       = 'RESUME'\n        self.AFC_RENAME_RESUME_NAME = '_AFC_RENAMED_{}_'.format(self.BASE_RESUME_NAME)\n        self.BASE_PAUSE_NAME        = 'PAUSE'\n        self.AFC_RENAME_PAUSE_NAME  = '_AFC_RENAMED_{}_'.format(self.BASE_PAUSE_NAME)\n\n        self.afc.gcode.register_command('RESET_FAILURE', self.cmd_RESET_FAILURE, desc=self.cmd_RESET_FAILURE_help)\n        self.afc.gcode.register_command('AFC_RESUME', self.cmd_AFC_RESUME, desc=self.cmd_AFC_RESUME_help)\n\n    def fix(self, problem, LANE):\n        self.pause= True\n        self.afc = self.printer.lookup_object('AFC')\n        error_handled = False\n        if problem is None:\n            self.PauseUserIntervention('Paused for unknown error')\n        if problem=='toolhead':\n            error_handled = self.ToolHeadFix(LANE)\n        else:\n            self.PauseUserIntervention(problem)\n        if not error_handled:\n            self.afc.function.afc_led(self.afc.led_fault, LANE.led_index)\n\n        return error_handled\n\n    def ToolHeadFix(self, cur_lane):\n        if cur_lane.get_toolhead_pre_sensor_state():   #toolhead has filament\n            if cur_lane.extruder_obj.lane_loaded == cur_lane.name:   #var has right lane loaded\n                if not cur_lane.load_state: #Lane has filament\n                    self.PauseUserIntervention('Filament not loaded in Lane')\n                else:\n                    self.PauseUserIntervention('no error detected')\n            else:\n                self.PauseUserIntervention('laneloaded does not match extruder')\n\n        else: #toolhead empty\n            if cur_lane.load_state: #Lane has filament\n                while cur_lane.load_state:  # slowly back filament up to lane extruder\n                    cur_lane.move(-5, self.afc.short_moves_speed, self.afc.short_moves_accel, True)\n                while not cur_lane.load_state:  # reload lane extruder\n                    cur_lane.move(5, self.afc.short_moves_speed, self.afc.short_moves_accel, True)\n\n                cur_lane.tool_load = False\n                cur_lane.loaded_to_hub = False\n                cur_lane.extruder_obj.lane_loaded = ''\n                self.afc.save_vars()\n                self.pause = False\n                return True\n\n            else:\n                self.PauseUserIntervention('Filament not loaded in Lane')\n\n    def PauseUserIntervention(self,message):\n        #pause for user intervention\n        self.logger.error(message)\n        if self.afc.function.is_homed() and not self.afc.function.is_paused():\n            self.afc.save_pos()\n            if self.pause:\n                self.pause_print()\n\n    def pause_print(self):\n        \"\"\"\n        pause_print function verifies that the printer is homed and not currently paused before calling\n        the base pause command\n        \"\"\"\n        self.set_error_state( True )\n        self.logger.info ('PAUSING')\n        self.afc.gcode.run_script_from_command('PAUSE')\n        self.logger.debug(\"After User Pause\")\n        self.afc.function.log_toolhead_pos()\n\n    def set_error_state(self, state=False):\n        logging.warning(\"AFC debug: setting error state {}\".format(state))\n        # Only save position on first error state call\n        if state and not self.afc.error_state:\n            self.afc.save_pos()\n        self.afc.error_state = state\n        self.afc.current_state = State.ERROR if state else State.IDLE\n\n    def AFC_error(self, msg, pause=True, level=1):\n        # Print to logger since respond_raw does not write to logger\n        logging.warning(msg)\n        # Handle AFC errors\n        self.logger.error( message=msg, stack_name=inspect.stack()[level].function )\n        if pause: self.pause_print()\n\n    cmd_RESET_FAILURE_help = \"CLEAR STATUS ERROR\"\n    def cmd_RESET_FAILURE(self, gcmd):\n        \"\"\"\n        This function clears the error state of the AFC system by setting the error state to False.\n\n        Usage\n        -----\n        `RESET_FAILURE`\n\n        Example\n        -----\n        `RESET_FAILURE`\n        \"\"\"\n        self.reset_failure()\n\n    def reset_failure(self):\n        \"\"\"\n        Common function to reset error_state, pause, and position_saved variables\n        \"\"\"\n        self.logger.debug(\"Resetting failures\")\n        self.set_error_state(False)\n        self.pause              = False\n        self.afc.position_saved = False\n        self.afc.in_toolchange  = False\n\n    cmd_AFC_RESUME_help = \"Clear error state and restores position before resuming the print\"\n    def cmd_AFC_RESUME(self, gcmd):\n        \"\"\"\n        During the PREP phase of startup, the user's RESUME macro is renamed and replaced with AFC_RESUME.\n        This function clears the error state of the AFC system, sets the in_toolchange flag to False,\n        runs the resume script, and restores the toolhead position to the last saved position.\n\n        This is not a macro that should normally need to be called by the user.\n\n        Usage\n        -----\n        `AFC_RESUME`\n\n        Example\n        -----\n        ```\n        AFC_RESUME\n        ```\n        \"\"\"\n        self.afc.in_toolchange = False\n        if not self.afc.function.is_paused():\n            self.logger.debug(\"AFC_RESUME: Printer not paused, not executing resume code\")\n            return\n\n        # Save current pause state\n        temp_is_paused = self.afc.function.is_paused()\n\n        # Verify that printer is in absolute mode\n        self.afc.function.check_absolute_mode(\"AFC_RESUME\")\n\n        move_z_pos = self.afc.last_gcode_position[2] + self.afc.z_hop\n        # Check if current position is below saved gcode position, if its lower first raise z above last saved\n        #   position so that toolhead does not crash into part\n        if self.afc.gcode_move.last_position[2] <= move_z_pos:\n            self.afc.move_z_pos(move_z_pos, \"AFC_RESUME\")\n        else:\n            self.logger.debug(f\"AFC_RESUME: not moving in z cur_pos:{self.afc.gcode_move.last_position} move_z_pos:{move_z_pos}\")\n\n        self.logger.debug(\"AFC_RESUME: Before User Restore\")\n        self.afc.function.log_toolhead_pos()\n        self.afc.gcode.run_script_from_command(\"{macro_name} {user_params}\".format(macro_name=self.AFC_RENAME_RESUME_NAME, user_params=gcmd.get_raw_command_parameters()))\n\n        # The only time our resume should restore position is if there was an error that caused the pause\n        if self.afc.error_state or temp_is_paused or self.afc.position_saved:\n            self.set_error_state(False)\n            self.afc.restore_pos(False)\n            self.pause = False\n\n        self.logger.debug(\"RESUME-Error State: {}, Is Paused {}, Position_saved {}, in toolchange: {}\".format(\n            self.afc.error_state, self.afc.function.is_paused(), self.afc.position_saved, self.afc.in_toolchange ))\n\n    cmd_AFC_PAUSE_help = \"Pauses print, raises z by z-hop amount, and then calls users pause macro\"\n    def cmd_AFC_PAUSE(self, gcmd):\n        \"\"\"\n        During the PREP phase of startup, the user's PAUSE macro is renamed and replaced with AFC_PAUSE.\n        This function pauses the print, raises the Z axis by the z-hop amount, and then calls the user's pause macro.\n\n        This is not a macro that should normally need to be called by the user.\n\n        Usage\n        -----\n        `AFC_PAUSE`\n\n        Example\n        -----\n        ```\n        AFC_PAUSE\n        ```\n        \"\"\"\n        # Check to make sure printer is not already paused\n        if not self.afc.function.is_paused():\n            self.logger.debug(\"AFC_PAUSE: Pausing\")\n            # Save position\n            self.afc.save_pos()\n            # Need to pause as soon as possible to stop more gcode from executing, this needs to be done before movement in Z\n            self.pause_resume.send_pause_command()\n            # Verify that printer is in absolute mode\n            self.afc.function.check_absolute_mode(\"AFC_PAUSE\")\n            move_z_pos = self.afc.last_gcode_position[2] + self.afc.z_hop\n            # Check to see if current position is less than saved position plus z-hop\n            if self.afc.gcode_move.last_position[2] <= move_z_pos:\n                # Move Z up by z-hop value\n                self.afc.move_z_pos(move_z_pos, \"AFC_PAUSE\")\n            else:\n                self.logger.debug(f\"AFC_PAUSE: not moving in z cur_pos:{self.afc.gcode_move.last_position} move_z_pos:{move_z_pos}\")\n            # Call users PAUSE\n            self.afc.gcode.run_script_from_command(\"{macro_name} {user_params}\".format(macro_name=self.AFC_RENAME_PAUSE_NAME, user_params=gcmd.get_raw_command_parameters()))\n\n            timeout_to_use = max(self.error_timeout, self.idle_timeout_val)\n            self.afc.gcode.run_script_from_command(f\"SET_IDLE_TIMEOUT TIMEOUT={timeout_to_use}\")\n\n        else:\n            self.logger.debug(\"AFC_PAUSE: Not Pausing\")\n\n        self.logger.debug(\"PAUSE-Error State: {}, Is Paused {}, Position_saved {}, in toolchange: {}\".format(\n            self.afc.error_state, self.afc.function.is_paused(), self.afc.position_saved, self.afc.in_toolchange ))\n\n\n    handle_lane_failure_help = \"Get load errors, stop stepper and respond error\"\n    def handle_lane_failure(self, cur_lane, message, pause=True):\n        # Disable the stepper for this lane\n        cur_lane.do_enable(False)\n        cur_lane.status = AFCLaneState.ERROR\n        msg = \"{} {}\".format(cur_lane.name, message)\n        self.AFC_error(msg, pause, level=2)\n        self.afc.function.afc_led(self.afc.led_fault, cur_lane.led_index)\n",
}


def _load_ams_modules():
    for name, source in AMS_MODULE_SOURCES.items():
        module = types.ModuleType(name)
        module.__file__ = f"<AFC_AMS:{name}>"
        module.__package__ = name.rpartition('.')[0]
        sys.modules[name] = module
        exec(compile(source, module.__file__, 'exec'), module.__dict__)

# Load modules when this file is imported
_load_ams_modules()

from extras.AFC import load_config as _ams_load_config

def load_config(config):
    """Proxy load_config that returns the AFC AMS implementation."""
    return _ams_load_config(config)
